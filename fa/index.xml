<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Amirreza's blog </title>
    <link>https://amirrezaghaderi.com/fa/</link>
    <language>en-US</language>
    <author>Amirreza Ghaderi</author>
    <rights>Except where otherwise noted, content on this site is licensed under a Attribution-NonCommercial 4.0 International license.</rights>
    <updated>Wed, 18 Apr 2018 00:00:00 UTC</updated>
    
    <item>
      <title>کالبد شکافی GraalVM</title>
      <link>https://amirrezaghaderi.com/fa/blog/graalvm/</link>
      <pubDate>April 18, 2018</pubDate>
      <author>Amirreza Ghaderi</author>
      <guid>https://amirrezaghaderi.com/fa/blog/graalvm/</guid>
      <description>

&lt;p&gt;&lt;a name=&#34;toc&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;فهرست-مطالب&#34;&gt;فهرست مطالب&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#machine&#34;&gt;ماشین چیست؟ (Machine)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vm&#34;&gt;ماشین مجازی چیست؟ (VM)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#jvm&#34;&gt;ماشین مجازی جاوا (JVM)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#graalvm&#34;&gt;GraalVm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#graalcompiler&#34;&gt;Graal Compiler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#truffle&#34;&gt;Truffle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#substratevm&#34;&gt;SubstrateVM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tools&#34;&gt;ابزارهای جانبی&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;جمع بندی مطالب&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;در زمان نگارش این پست، هنوز ۲۴ ساعت نشده است که &lt;a href=&#34;http://graalvm.org&#34;&gt;شرکت Oracle از VM جدید خود با اسم GraalVM رونمایی کرده.&lt;/a&gt;
 و تعداد زیادی از برنامه‌نویسان مطمئن نیستند که GraalVM دقیقا چیست و چه کاری انجام می‌دهد. در این پست قصد داریم GraalVM را کالبدشکافی کنیم&amp;hellip;&lt;/p&gt;

&lt;p&gt;بگذارید از صفر شروع نماییم!&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;machine&#34;&gt;&lt;/a&gt;&lt;a name=&#34;ماشین چیست؟ (Machine)&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ماشین-چیست-machine&#34;&gt;ماشین چیست؟ (Machine)&lt;/h2&gt;

&lt;p&gt;در مطالب مربوط به برنامه‌نویسی، مفهوم «ماشین» (Machine) برابر با سیستمی است که قابلیت اجرای دستورات را داشته باشد. در هر دستگاه کامپیوتر، CPU قسمتی است که مسئول پردازش فرامین شماست؛ بنابراین در این سناریو، CPU برابر با «ماشین» است!&lt;/p&gt;

&lt;p&gt;وقتی کدهای‌تان را در یک زبان برنامه‌نویسی نگارش می‌کنید، این کدها باید به نحوی روی CPU اجرا شوند. اما CPU چیزی به غیر از 0 و 1 (که توسط ولتاژ‌های الکتریکی بیان می‌شوند) را درک نمی‌کند. از همین رو CPU از نظر سخت افزاری به گونه‌ای طراحی می‌شود که «الگو» های مشخصی از 0 و 1 برایش دارای معنی شوند! فرضا اگر چهار 0 و چهار 1 پشت سر هم اتفاق افتاد، فلان عملیات را انجام بده!&lt;/p&gt;

&lt;p&gt;این الگو‌ها برای CPU شرایطی را فراهم می‌آورند تا بتواند فرمان‌های مختلف را درک کند. به عبارتی این الگوها، تنها «زبان» ای هستند که CPU قادر به فهمیدن آن است. ما به این زبان، «زبان ماشین» می‌گوییم! (یا «کُدِ ماشین»)&lt;/p&gt;

&lt;p&gt;زبان ماشین، برای تمام CPU ها یکسان نیست. یعنی همه‌ی CPU ها قادر به درک الگوهای یکسانی از 0 و 1 ها نیستند. کارخانه‌های مختلف، CPU های مختلفی تولید می‌کنند و هرکدام‌شان نیز الگوهای منحصر به فردی دارند. تفاوت در زبان ماشین (به همراه تعداد زیادی فاکتور دیگر)، معین کننده‌ی «معماری پردازشگر» است. فرضا معماری CPU لپ‌تاپ شما که توسط اینتل تولید شده است x86 می‌باشد، و معماری CPU های تولید شده توسط اپل که در آیفون شما به کار رفته‌اند ARM است.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;vm&#34;&gt;&lt;/a&gt;&lt;a name=&#34;ماشین مجازی چیست؟ (VM)&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ماشین-مجازی-چیست-vm&#34;&gt;ماشین مجازی چیست؟ (VM)&lt;/h2&gt;

&lt;p&gt;در بالاتر گفتیم که CPU ها معماری‌های مختلفی دارند و هر معماری دارای زبان ماشین منحصر به فرد خودش است.
اگر برنامه‌ای نوشته باشید و بخواهید آن را روی CPU های گوناگون اجرا کنید، باید به ازای هر معماری یک بار برنامه‌تان را از اول کامپایل کنید تا «کد ماشین» مخصوص آن معماری بدست آید.&lt;/p&gt;

&lt;p&gt;اما موضوع فقط تفاوت در معماری‌های مختلف CPU نیست، باید این را هم در نظر بگیرید که برنامه شما قرار است روی یک «سیستم عامل» اجرا شود؛ سیستم عامل‌ها نیز هر کدام راه و روش خودشان را برای اجرای برنامه‌ها دارند و نمی‌توان برنامه‌ها را به شکلی یکسان روی تمام آن‌ها اجرا کرد. معماری CPU در کنار سیستم‌عامل، مفهومی به نام «سکو» یا «پلتفرم» را پدید می‌آورد.&lt;/p&gt;

&lt;p&gt;تفاوت در پلتفرم‌های مختلف، توسعه‌ی برنامه‌ها را بسیار سخت خواهد کرد. برای این مشکل راه حل‌هایی وجود دارد:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;کامپایلر‌هایی داشته باشیم که بتوانند برای هر معماری و هر سیستم عامل، به طور جداگانه کد ماشین تولید کنند. مانند کاری که C و ++C انجام می‌دهند. این کار شدنی است، اما بسیار سخت است و باعث کند شدن روند توسعه‌ی زبان و ابزارهای پیرامون آن خواهد شد. ( تا اینکه LLVM آمد و دنیای برنامه‌نویسی را از این وضعیت نجات داد).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;از ماشین مجازی استفاده کنیم!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;قضیه اینگونه است:&lt;/p&gt;

&lt;p&gt;به جای اینکه مستقیما با ده‌ها معماری و سیستم‌عامل مختلف طرف شویم، «یک» محیط نرم‌افزاری یکسان طراحی می‌کنیم تا زبان برنامه‌نویسی ما از این به بعد فقط با این محیط مواجه شود. به این محیط نرم افزاری، «ماشین مجازی» می‌گوییم. بنابراین هنگام توسعه‌ی برنامه‌ی خود، دیگر لازم نیست نگران تفاوت‌هایی که بین پلتفرم‌های مختلف وجود دارد باشید. تنها کافیست که کدهای خود را برای این «ماشین مجازی» توسعه دهید.&lt;/p&gt;

&lt;p&gt;در پشت صحنه، ماشین مجازی توسط زبان‌هایی مانند C و ++C توسعه داده شده است تا بتواند برای معماری‌ها و سیستم‌عامل‌های مختلف کد ماشین تولید کند. ماشین مجازی خودش یک برنامه‌ی نرم‌افزاری به حساب می‌آید و لازم است با پلتفرم‌های مختلف هماهنگ شود. اما هماهنگ کردن «یک» برنامه با «ده‌ها» پلتفرم، بهتر از هماهنگ کردن «میلیون‌ها» برنامه با «ده‌ها» پلتفرم است!&lt;/p&gt;

&lt;p&gt;ماشین مجازی با اینکه از نظر منطقی یک مفهوم منفرد است، اما در واقع ممکن است از تعداد زیادی ابزار و تکنولوژی مختلف تشکیل شده باشد.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;jvm&#34;&gt;&lt;/a&gt;&lt;a name=&#34;ماشین مجازی جاوا (JVM)&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ماشین-مجازی-جاوا-jvm&#34;&gt;ماشین مجازی جاوا (JVM)&lt;/h2&gt;

&lt;p&gt;مجموعه ابزارها و تکنولوژی‌هایی است که کنار یکدیگر قرار گرفته‌اند تا یک ماشین مجازی با توانایی اجرای برنامه‌های Java را ارائه کنند. JVM در طی سال‌ها پیشرفت کرده و بهینه‌سازی‌های زیادی رو آن انجام شده. همانطور که گفتیم، JVM از بخش‌های گوناگونی تشکیل شده؛ موتور پردازشی برنامه‌ها در JVM ، با نام HotSpot شناخته می‌شود.&lt;/p&gt;

&lt;p&gt;از مهم‌ترین قابلیت‌هایی که در HotSpot وجود دارد، کامپایلر JIT است. هنگامی که برنامه‌ی شما روی HotSpot در حال اجرا است، در همان حال نیز یک فرآیند جانبی در حال مانیتور کردن و آنالیز کردن نحوه‌ی اجرای برنامه‌ی شماست. این فرآیند می‌تواند نقاط پراستفاده‌ی برنامه‌ی شما را شناسایی کند، و کدهای آن قسمت را در همان حین اجرا به زبان ماشین ترجمه نماید. یکی از دلایلی که جاوا سرعت به مراتب بالاتری به نسبت زبان‌های دیگر دارد وجود همین قابلیت است.&lt;/p&gt;

&lt;p&gt;به کامپایلر‌هایی مانند JIT که کدهای شما را در حین اجرا (و به عبارتی روی هوا) کامپایل می‌کنند، «کامپایلر داینامیک» می‌گوییم (هیچ ربطی به مبحث تایپ سیستم‌ها ندارد).&lt;/p&gt;

&lt;p&gt;امروزه علاوه بر زبان جاوا، زبان‌های دیگری مانند کلوژور و اسکالا و کاتلین و &amp;hellip; نیز روی JVM اجرا می‌شوند. و مشکل دقیقا همینجاست!&lt;/p&gt;

&lt;p&gt;در آن سال‌های دور که JVM ساخته شد، مشخصا برای زبان جاوا طراحی شده بود. و هنوز هم می‌توان گفت تنها زبانی که برای JVM اهمیت دارد جاوا است. بقیه زبان‌هایی که دوست دارند تحت JVM اجرا شوند، مجبورند با این قضیه بسازند و بسوزند.&lt;/p&gt;

&lt;p&gt;این در حالی است که به گفته جیمز گاسلینگ (خالق زبان جاوا)، این در واقع JVM بوده که در مرکز توجهات قرار داشته و «زبان جاوا» موضوع اصلی نبوده! هدف نهایی و بزرگ‌تر آن‌ها این بود که یک VM مناسب برای ساخت برنامه‌ها طراحی کنند؛ اما در عمل اینطور نشد و JVM به ماشینی تبدیل شد که مشخصا برای اهداف یک زبان خاص به اسم جاوا فعالیت می‌کند.&lt;/p&gt;

&lt;p&gt;هر روز زبان‌های بیشتری برای اجرا شدن روی JVM علاقه نشان می‌دهند. و هزینه‌های زیادی نیز برای JVM انجام می‌شود تا این سیستم بتواند هر روز بهینه تر از دیروز باشد. اما این همه زحمت و تلاش و هزینه به هدر می‌رود اگر قرار باشد فقط برای یک زبان بخصوص خرج شود.&lt;/p&gt;

&lt;p&gt;جدای از این‌ها، JVM در حال حاضر یک محصول نرم‌افزاری مُسن به حساب می‌آید. توسعه‌ی بخش‌های مختلف آن دیگر آنقدر راحت و سریع اتفاق نمی‌افتد و نمی‌تواند با زبان‌های مدرن امروزی همپا شود. شاید اگر قرار باشد امروز JVM را از صفر طراحی کنند، تصمیمات زیادی را به گونه‌ی دیگری می‌گرفتند&amp;hellip;&lt;/p&gt;

&lt;p&gt;همه‌ی این‌ها باعث شد تا اوراکل از چندین سال پیش تحقیقات روی پروژه‌ای را در آزمایشگاه‌های خود استارت بزند تا بتواند VM ای بسازد که:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;از JVM بهینه تر باشد. هم از نظر سرعت اجرا، و هم از نظر مصرف منابع (مثل رم).&lt;/li&gt;
&lt;li&gt;طراحی آن ماژولارتر باشد تا بتوان براحتی آن را توسعه داد و همگام با تحولات روز برنامه‌نویسی پیش رفت.&lt;/li&gt;
&lt;li&gt;به هیچ زبانی وابسته نباشد تا بتواند تعداد زیادی از زبان‌های مختلف را پشتیبانی کند.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;و حاصل این چند سال تحقیق و توسعه، امروز به طور stable با نام GraalVM منتشر شد!&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;graalvm&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;graalvm&#34;&gt;GraalVm&lt;/h2&gt;

&lt;p&gt;GraalVM هم یک نرم افزار منفرد نیست. مجموعه‌ای از ابزارها و تکنولوژی‌هایی است که کنار یکدیگر قرار گرفته‌اند تا یک ماشین مجازیِ مستقل از زبان ارائه دهند؛ با این هدف که بتوان از این VM برای اجرای تعداد زیادی از زبان‌های برنامه‌نویسی استفاده کرد و همچنین بتوان میان کدهایی که در این زبان‌ها می‌نویسید براحتی ارتباط برقرار نمود. به زبان ساده: One VM to rule them all&lt;/p&gt;

&lt;p&gt;GraalVM هم می‌تواند به صورت مستقل اجرا شود، و هم تحت JVM یا Node اجرا شود.&lt;/p&gt;

&lt;p&gt;GraalVM از بخش‌های اصلی زیر تشکیل شده است:&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;graalcompiler&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;graal-compiler&#34;&gt;Graal Compiler&lt;/h2&gt;

&lt;p&gt;وقتی Java9 منتشر شد، همه توجه شان به سیستم ماژول با نام Jigsaw یا ترمینال جدید JShell منعطف شد. ولی مهم‌ترین قابلیتی که در این نسخه وجود داشت از چشم همه پنهان ماند: JVMCI&lt;/p&gt;

&lt;p&gt;JVMCI که مختصر شده‌ی عبارت Java based JVM Compiler Interface است، قابلیت جدیدی در Java9 است که امکان ساخت یک «کامپایلر داینامیک» در زبان جاوا را مهیا می‌سازد، با این هدف که بتوان برای JVM کامپایلرهای JIT اختصاصی و کاستوم شده طراحی کرد!&lt;/p&gt;

&lt;p&gt;کامپایلر JIT فعلی که در JVM وجود دارد با نام C2 شناخته می‌شود. C2 همان چیزی است که جاوا بخش زیادی از سرعت خود را مدیون آن است. اما این کامپایلر چند اشکال اساسی دارد:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;در ++C ساخته شده. ++C زبان راحتی نیست. نوشتن برنامه‌های «ایمن» با این زبان و در چنین ابعاد بزرگ و حساسی، بسیار سخت است. هر کجا از C2 را که دست می‌زدند، باگ دیگری از جای دیگر ظاهر می‌شد. ( تصور کنید که موزیلا برای حل مشکلات فایرفاکس و فرار از ++C، کلا یک زبان دیگر به اسم Rust را از صفر طراحی کرد! و اپل و گوگل نیز همینطور&amp;hellip; تا این حد اوضاع خراب است!)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;معماری کدهای C2 در حال حاضر بسیار متزلزل است و توسعه‌ی آن نه تنها کار راحتی نیست، بلکه کار هر کسی هم نیست! افراد زیادی وجود ندارند که بتوانند براحتی کدهای آن را بفهمند!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C2 مشخصا برای بهینه سازی Bytecode ها طراحی شده. Bytecode هایی که خودشان هم انحصارا برای زبان جاوا طراحی شده بودند.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;اما حالا به کمک JVMCI  این قابلیت را دارید تا:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;کامپایلر JIT را در یک زبان راحت‌تر مانند جاوا توسعه دهید.&lt;/li&gt;
&lt;li&gt;خودتان از اول یک کامپایلر با معماری بهتر و ماژولارتر طراحی کنید تا توسعه‌ی آن راحت باشد.&lt;/li&gt;
&lt;li&gt;بتوانید این کامپایلر JIT جدید را با C2 جایگزین کنید تا JVM بتواند از آن بهره برداری کند.&lt;/li&gt;
&lt;li&gt;و حالا که دارید یک کامپایلر JIT جدید می‌سازید، لازم نیست فقط زبان جاوا را هدف قرار دهید. دست شما باز است تا به زبان‌های دیگر هم توجه کنید.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;و این شد که Graal Compiler به عنوان یک آلترنایو جدید برای C2 ساخته شد. حالا می‌توانید به جای JIT پیشفرض موجود در JVM، از Graal استفاده کنید. Graal چند خصوصیت اصلی دارد:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;در زبان جاوا توسعه داده شده.&lt;/li&gt;
&lt;li&gt;هوشمند‌تر از C2 است و کدهای سریع‌تری تولید می‌کند.&lt;/li&gt;
&lt;li&gt;کدهایی که تولید می‌کند از نظر مصرف منابع سیستم بهینه‌تر هستند.&lt;/li&gt;
&lt;li&gt;هیچ چیزی تحت مفهوم «زبان برنامه‌نویسی» ندارد!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;این مورد آخر ممکن است توجه شما را جلب کرده باشد. درست خواندید:&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;in-red&#34;&gt;
« Graal چیزی تحت عنوان زبان برنامه نویسی ندارد. کاری ندارد که زبان شما جاوا است یا کاتلین یا پایتون یا هر چیز دیگر. با bytecode ها هم کاری ندارد و نمی تواند آن ها را درک کند! بلکه Graal مستقیما روی AST فعالیت می‌کند!»
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;کدهایی که شما می‌نویسید حالت متنی دارند. قبل از اینکه زبان برنامه‌نویسی بتواند با این کدها کاری انجام دهد، ابتدا باید آن‌ها را «درک» کند. یعنی باید آن‌ها را Parse کند. وقتی که یک Parser کدهای شما را Parse می‌کند، اطلاعات موجود در کدهای شما را در یک ساختار داده‌ای درختی شکل، روی حافظه قرار می دهد تا کامپایلر بتواند از آن استفاده کند. این ساختار درختی شکل AST نام دارد. به عبارتی کدهای متنی چیزهایی هستند که شما به عنوان یک انسان می‌بینید، و ساختار AST چیزی است که کامپایلر قادر به دیدن آن است.&lt;/p&gt;

&lt;p&gt;قبلا برای اجرای برنامه‌های شما در JVM این مراحل طی می‌شد:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;کدهای‌تان را بنویسید.&lt;/li&gt;
&lt;li&gt;parser کدهای شما را به AST تبدیل کند.&lt;/li&gt;
&lt;li&gt;کامپایلر AST را بهینه سازی کند و پس از بهینه سازی، bytecode تولید نماید.&lt;/li&gt;
&lt;li&gt;HotSpot شروع به اجرای bytecode ها نماید.&lt;/li&gt;
&lt;li&gt;C2 در حین اجرای برنامه، bytecode را به کد ماشین تبدیل کند.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;حالا با Graal وضعیت اینطوری است:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;کدهای‌تان را بنویسید.&lt;/li&gt;
&lt;li&gt;parser کدهای شما را به AST های بهینه تبدیل کند.&lt;/li&gt;
&lt;li&gt;Graal در حین اجرای برنامه، AST را مستقیما به کد ماشین تبدیل کند.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;خوب تا اینجای کار، متوجه شدیم که JVM یک کامپایلر JIT جدید به نام Graal دارد و زبان‌هایی مثل جاوا و اسکالا و کاتلین و غیره از همین امروز می‌توانند از امکانات و بهینه‌سازی های آن استفاده کنند. حتی تویتر، همین الآن نیز در حال استفاده از Graal برای کدهای اسکالا است!&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;truffle&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;truffle&#34;&gt;Truffle&lt;/h2&gt;

&lt;p&gt;برای ساخت یک برنامه وب، شما از فریم‌ورک‌هایی مانند Django یا Laravel یا Rails یا&amp;hellip; استفاده می‌کنید. دلیل این کار چیست؟ این فریم‌ورک‌ها خیلی از ابزارها و کدهایی که برای ساخت یک برنامه‌ی وب نیاز است را از قبل آماده کرده‌اند تا کار ما راحت‌تر و سریع‌تر انجام شود. علاوه بر آن، برنامه‌های شما نیز حالت یونیفرم تری به خود می‌گیرند. مثلا تمام برنامه‌هایی که با Laravel نوشته می‌شوند، با API یکسانی به دیتابیس متصل می‌شوند.&lt;/p&gt;

&lt;p&gt;حالا فرض کنید به همین حالت که می‌توانید یک برنامه‌ی وب را به کمک وب‌فریم‌ورم‌ها بسازید، فریم‌ورکی هم وجود داشت که بتوانید به کمک آن یک زبان‌برنامه نویسی بسازید!&lt;/p&gt;

&lt;p&gt;Truffle فریم‌ورکی است به زبان جاوا که به کمک آن، شما قادر هستید برای خودتان یک زبان برنامه نویسی بسازید. و اگر زبان برنامه‌نویسی خود را بر مبنای Truffle بسازید، قادر خواهید بود از روی کدهای‌تان ASTهایی دریافت کنید که قابل کامپایل با Graal باشند! تازه موضوع جالب شد!&lt;/p&gt;

&lt;p&gt;در بخش قبل گفتیم که Graal به زبان اهمیت نمید‌هد و فقط AST برایش مهم است. AST هایی که Graal می‌تواند آن‌ها را کامپایل کند توسط Truffle تولید می‌شوند. بنابراین اگر با کمک Truffle یک مفسر برای پایتون، روبی، یا جاوااسکریپت بسازید، تمام آن‌ها می‌توانند به خورد Graal داده شوند و قابلیت اجرا شدن روی سیستم جدید JVM را داشته باشند.&lt;/p&gt;

&lt;p&gt;و خبر خوش اینکه، مفسر این زبان‌ها از قبل توسط تیم اوراکل با Truffle ساخته شده‌اند:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;زبان‌های نرمال JVM مانند جاوا، اسکالا، کاتلین&amp;hellip; از طرف اوراکل. هماهنگی ۱۰۰٪ با کدهای نرمال این زبان‌ها.&lt;/li&gt;
&lt;li&gt;JavaScript ، از طرف اوراکل. هماهنگی ۱۰۰٪ با کدهای نرمال جاوا اسکریپت&lt;/li&gt;
&lt;li&gt;Ruby ، از طرف اوراکل. هماهنگی ۱۰۰٪ با کدهای نرمال روبی (هنوز حالت بتا دارد)&lt;/li&gt;
&lt;li&gt;Python ، از طرف دانشگاه ایرواین (UC Irvine) هنوز تکمیل نشده.&lt;/li&gt;
&lt;li&gt;R ، از طرف اوراکل. هنوز کامل نیست ولی قابل استفاده است.&lt;/li&gt;
&lt;li&gt;Sulong ، از طرف اوراکل. این یک مفسر برای Bitcode های (زبان میانی) LLVM است و می‌تواند هر زبانی که مبتنی بر LLVM است را ساپورت کند (مثل C و C++ و Swift و Rust و&amp;hellip;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;قبل از Truffle و Graal اگر می خواستید یک زبان برنامه‌نویسی بسازید، اوضاع اینچنین بود:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;مقدمات ساخت یک زبان را توسعه دهید: parser و &amp;hellip;&lt;/li&gt;
&lt;li&gt;از صفر برای زبان‌تان یک VM توسعه دهید: مفسر، runtime ، gc ، &amp;hellip;&lt;/li&gt;
&lt;li&gt;بعد از اینکه زبان پایدار شد، تازه شروع می‌کردید که VM را در گذر زمان بهینه سازی کنید: کامپایلر JIT، بهینه سازی GC ، &amp;hellip;&lt;/li&gt;
&lt;li&gt;کلی زمان می‌برد که کامیونیتی برای زبان شما کتابخانه‌ها و فریم‌ورک‌های گوناگون بنویسد&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;اما حالا با وجود Truffle و Graal اوضاع اینگونه است:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;مقدمات ساخت یک زبان را توسعه دهید: parser و &amp;hellip;&lt;/li&gt;
&lt;li&gt;و&amp;hellip;. تمام&amp;hellip;. بقیه چیزها برای شما آماده است!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;تنها کاری که شما باید بکنید، این است که مفسر زبان‌تان را با Truffle توسعه دهید تا بتوانید برای Graal ساختار AST تولید کنید. Truffle یک فریم‌ورک جاوا است و شما زبان‌تان را با جاوا توسعه خواهید داد و لازم نیست با C یا C++ که زبان‌های سختی هستند درگیر شوید.&lt;/p&gt;

&lt;p&gt;هر زبانی که مفسر آن توسط Truffle ساخته شود و بتواند قابل کامپایل با Graal باشد، می‌تواند با زبان‌های دیگری که به این روش تولید شده‌اند ارتباط مستقیم داشته باشند. ساختار‌های داده‌ای، کلاس‌ها، متدها، &amp;hellip; همه‌ی این‌ها با پروتکل‌هایی که در GraalVM قرار داده شده است قابل اشتراک خواهند بود. فرضا می‌توانید براحتی فلان کتابخانه از جاوا را در کدهای روبی صدا بزنید (و برعکس).&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;in-red&#34;&gt;
می‌توان اینطور گفت که GraalVM همان کاری را برای زبان‌های VM دار انجام می‌دهد، که پروژه LLVM برای زبان‌های Native انجام می‌دهد!
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;substratevm&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;substratevm&#34;&gt;SubstrateVM&lt;/h2&gt;

&lt;p&gt;کامپایلر Graal علاوه بر اینکه می تواند به عنوان یک کامپایلر JIT فعالیت کند، قابلیت کامپایل کدها به صورت AOT را نیز دارد. در مجموعه‌ی نرم افزاری GraalVM ابزاری به نام native-image وجود دارد که می‌تواند از کامپایلر Graal برای ساخت بسته‌ها/ایمیج‌های Native استفاده کند.&lt;/p&gt;

&lt;p&gt;مجموعه‌ی GraalVM یک VM سبک‌تر (به نسبت JVM) ارائه کرده است که با نام SubstrateVM ارا‌یه می‌شود. SubstrateVM مسئول اجرای ایمیج‌های Native است، به این معنی که امکاناتی نظیر runtime یا gc که مورد نیاز زبان‌های مختلف می‌باشند را فراهم می‌کند. SubstrateVM به ایمیج نهایی الحاق خواهد شد.&lt;/p&gt;

&lt;p&gt;بدین ترتیب جاوا یا زبان های دیگری که روی Graal فعال خواهند بود، علاوه بر اینکه می‌توانند روی JVM اجرا شوند، خواهند توانست به طور Native و بدون نیاز به VM نیز اجرا شوند. البته وقتی می‌گوییم به طور Native اجرا می‌شوند، انتظار چیزی در حد و اندازه ++C/C یا Go یا Swift یا Rust را نداشته باشید. این AOT چیزی شبیه ART در اندروید است:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;سیستم runtime و gc در ایمیج وجود دارند و جایی نرفته اند. این امکانات توسط SubstrateVM ارايه شده‌اند.&lt;/li&gt;
&lt;li&gt;امکانات SubstrateVM در ایمیج نهایی الحاق خواهد شد و شما در نهایت «یک» فایل اجرایی «مستقل» تحویل خواهید گرفت.&lt;/li&gt;
&lt;li&gt;ایمیج‌های Native ای که به این صورت ساخته می‌شوند، دیگر نیاز به وجود JVM ندارند. می‌توانید براحتی آن‌ها را روی کامپیوترهای دیگر کپی کنید و اجرا نمایید.&lt;/li&gt;
&lt;li&gt;ایمیج‌هایی Native دارای حجم بالایی نیستند و برای ساخت ابزارهای کوچک مناسب می‌باشند.&lt;/li&gt;
&lt;li&gt;استارتاپ برنامه‌ها با ایمیج‌هایی Native، چندین برابر (حتی گاهی بیشتر از ده برابر) سریعتر از استارتاپ JVM خواهد بود.&lt;/li&gt;
&lt;li&gt;مصرف حافظه با ایمیج‌هایی Native، بسیار پایین‌تر از JVM خواهد بود.&lt;/li&gt;
&lt;li&gt;ایمیج‌هایی Native به طور پیش‌فرض دارای JIT نخواهند شد، بنابراین ممکن است سرعتی پایین‌تر از JVM داشته باشید. (فقط ممکن است، در تمام شرایط اینطور نیست).&lt;/li&gt;
&lt;li&gt;می‌توانید درخواست کنید که JIT نیز به  ایمیج نهایی اضافه شود تا از بهینه‌سازی‌هایش بهره‌مند شوید (ولی به همان نسبت سرعت استارتاپ و مصرف حافظه بالاتر خواهد رفت. بنابراین باید چنین تصمیمی را با توجه به نیازتان بگیرید).&lt;/li&gt;
&lt;li&gt;برنامه‌های Native شما می‌توانند به دیگر کدهای Native لینک شوند.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/oracle/graal/blob/master/substratevm/LIMITATIONS.md&#34;&gt;همچنین SubstrateVM دارای محدودیت‌هایی نیز هست که باید حتما به آن توجه کنید.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;فرضا می‌توانید برنامه‌های سرور را با JVM اجرا کنید، ولی برای برنامه‌های ترمینال یا GUI ایمیج‌های Native تهیه کنید تا سبک‌تر باشند.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;tools&#34;&gt;&lt;/a&gt;&lt;a name=&#34;ابزارهای جانبی&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ابزارهای-جانبی&#34;&gt;ابزارهای جانبی&lt;/h2&gt;

&lt;p&gt;شرایطی که GraalVM مهیا کرده است باعث شده که بتواند ابزارهای جانبی مانند Profiler یا Debugger را هم به طور مشترک برای تمام زبان‌های Truffle قابل استفاده کند. این قضیه طراحان زبان را از دوباره کاری برای ساخت چنین ابزارهایی راحت می‌کند.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;conclusion&#34;&gt;&lt;/a&gt;&lt;a name=&#34;جمع بندی مطالب&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;جمع-بندی-مطالب&#34;&gt;جمع بندی مطالب&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;GraalVM یک سیستم منفرد نیست، بلکه چتری از سیستم‌های گوناگون است.&lt;/li&gt;
&lt;li&gt;GraalVM دارای یک فریم‌ورک به نام Truffle برای ساخت زبان‌های برنامه‌نویسی است.&lt;/li&gt;
&lt;li&gt;GraalVM دارای یک کامپایلر جدید به نام Graal است که در زبان جاوا نوشته شده و قابلیت کامپایل کردن تمام زبان‌هایی که با Truffle ساخته شده است را دارد.&lt;/li&gt;
&lt;li&gt;GraalVM می‌تواند از کامپایلر Graal، هم به عنوان کامپایلر JIT استفاده کند و هم به عنوان کامپایلر AOT.&lt;/li&gt;
&lt;li&gt;کامپایلر Graal از کامپایلر JIT پیش‌فرضی که در JVM وجود دارد و با نام C2 شناخته می‌شود، باهوش‌تر است و کدهای بهینه‌تری تولید می‌کند.&lt;/li&gt;
&lt;li&gt;GraalVM می‌تواند کامپایلر Graal را جایگزین کامپایلر JIT پیش‌فرضی که در حال حاضر در JVM وجود دارد نماید (کامپایلر C2).&lt;/li&gt;
&lt;li&gt;GraalVM می‌تواند از کامپایلر Graal به عنوان کامپایلر AOT نیز استفاده نماید و به کمک ابزار native-image ، ایمیج‌های مستقل و Native تولید کند.&lt;/li&gt;
&lt;li&gt;GraalVM دارای یک VM سبک به نام SubstrateVM است که به نوعی مسئول ارائه‌ی تدراکات برای ایمیج‌های Native است.&lt;/li&gt;
&lt;li&gt;GraalVM به طور پیش‌فرض، روی JVM اجرا خواهد شد و  از تمام امکانات JVM مانند runtime یا gc های موجود در آن بهره‌مند خواهد شد. با این تفاوت، که قسمت‌هایی از JVM را برای بهره‌وری بیشتر با سیستم‌هایی که خودش توسعه داده جایگزین می‌کند.&lt;/li&gt;
&lt;li&gt;به همان صورتی که در مورد بالا گفته شد، GraalVM می‌تواند روی ماشین Node نیز اجرا شود (V8).&lt;/li&gt;
&lt;li&gt;GraalVM تعدادی زبان برنامه‌نویسی را در همین اول کار برای شما مهیا کرده است. بقیه زبان‌ها به مرور زمان می‌توانند توسط Truffle ساخته شوند.&lt;/li&gt;
&lt;li&gt;تمام زبان‌هایی که به این صورت توسعه پیدا کنند، می‌توانند به طور مستقیم با یکدیگر در ارتباط باشند.&lt;/li&gt;
&lt;li&gt;GraalVM در حال حاضر Stable به حساب می‌آید و تویتر از GraalVM استفاده می‌کند.&lt;/li&gt;
&lt;li&gt;چون GraalVM تازه عمومی شده، هنوز شک و شبهه‌هایی درباره موضوع مجوز‌های آن وجود دارد. ممکن است فقط برای توسعه‌ی آزاد بتوانید از آن استفاده کنید و برای برنامه‌های تجاری قابل استفاده نباشد، مگر اینکه لیسانس آن تهیه شود (&lt;a href=&#34;https://github.com/oracle/graal/issues/269&#34;&gt;https://github.com/oracle/graal/issues/269&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>تایپ هایی که به آن ایمان داریم!</title>
      <link>https://amirrezaghaderi.com/fa/blog/in-types-we-trust/</link>
      <pubDate>March 5, 2018</pubDate>
      <author>Amirreza Ghaderi</author>
      <guid>https://amirrezaghaderi.com/fa/blog/in-types-we-trust/</guid>
      <description>

&lt;p&gt;&lt;a name=&#34;toc&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;فهرست-مطالب&#34;&gt;فهرست مطالب&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#intro&#34;&gt;مقدمه&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dec&#34;&gt;گواهی لغو مسئولیت!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#prereq&#34;&gt;پیش نیاز&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#why&#34;&gt;چرا زبان‌های استاتیک؟&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#correctness&#34;&gt;صحت&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#speed&#34;&gt;سرعت&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#docs&#34;&gt;مستندات&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tools&#34;&gt;ابزارهای جانبی&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#model&#34;&gt;مدل‌سازی، قبل از پیاده‌سازی&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#refactoring&#34;&gt;بازسازی (Refactoring)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#confidence&#34;&gt;اعتماد به نفس بالاتر!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#faq&#34;&gt;سوال و جواب‌های متداول&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#test&#34;&gt;با وجود تست ها، باز هم به تایپ نیاز داریم؟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#erlang&#34;&gt;چطور یکی از پایدارترین سیستم‌های نرم‌افزاری دنیا با ارلنگ که یک زبان داینامیک است نوشته شده؟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#facebook-php&#34;&gt;پس چرا فیسبوک هنوز از PHP که یک زبان داینامیک است استفاده می‌کند؟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#insta-python&#34;&gt;پس چرا اینستاگرام هنوز از پایتون که یک زبان داینامیک است استفاده می‌کند؟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#i-dont-need-speed&#34;&gt;من برایم سرعت مهم نیست؛ آیا باز هم به استاتیک تایپنگ نیاز دارم؟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#i-have-small-project&#34;&gt;برنامه‌ی من زیاد بزرگ نیست، آیا باز هم به استاتیک تایپنگ نیاز دارم؟&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#end&#34;&gt;سخن آخر&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;intro&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;مقدمه&#34;&gt;مقدمه&lt;/h2&gt;

&lt;p&gt;درباره انتشار این مطلب مردد بودم! به دو دلیل:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;مقایسه  زبان‌های استاتیک و داینامیک در گروه «جنگ‌های تاریخی» صنعت نرم افزار جا می‌گیرد (در کنار مقایسه‌هایی مثل ویندوز یا لینوکس، ویم یا ایمکس، تب یا اسپیس!&amp;hellip;). یعنی به محض انتشار چنین پستی، باید خودتان را آماده حرف شنیدن کنید!&lt;/li&gt;
&lt;li&gt;این بحث بعد از سال‌های متمادی حالت کلیشه‌ای پیدا کرده. اغلب برنامه‌نویسان که مدت طولانی وبلاگ می‌نویسند، به طور مستقیم یا غیر مستقیم مطلبی درباره این موضوع دارند.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;اما چرا در نهایت تصمیم به انتشار این پست گرفتم:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;این مقایسه بر خلاف مقایسه‌های رایج دنیای کامپیوتر، جنبه‌ی فنی و تخصصی دارد؛ یعنی نمی شود همینطور از روی «علاقه»ی شخصی راجع بهش حرف زد. تا جایی که توانستم سعی کردم فقط به مزایای زبان‌های استاتیک بپردازم و از جبهه‌ی مقابل بد نگویم!&lt;/li&gt;
&lt;li&gt;راستش را بخواهید، مطلب مناسبی در وب فارسی در باب این موضوع پیدا نکردم!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;dec&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;گواهی-لغو-مسئولیت&#34;&gt;گواهی لغو مسئولیت!&lt;/h2&gt;

&lt;p&gt;این پست، از طرف شخصی نوشته شده که بخش بزرگی از دوران برنامه‌نویسی خودش را در زبان‌های کاملا داینامیک کد زده و هنوز هم می‌زند! (Python, PHP, JS, &amp;hellip;). یعنی با چم و خم این زبان‌ها دست و پنجه نرم کرده‌ام. با تمام فواید و یا دردسرهای‌شان هم آشنایی دارم. این مطلب مبتنی بر تجربه‌ی واقعی خواهد بود و همینطور روی هوا حرفی نخواهم زد. اما می‌دانم که تجربیات شما ممکن است با من متفاوت باشد.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;prereq&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;پیش-نیاز&#34;&gt;پیش نیاز&lt;/h2&gt;

&lt;p&gt;برای مطالعه‌ی این مطلب، پیشنهاد میکنم ابتدا مطالب زیر را که در همین وبلاگ موجود هستند مطالعه فرمایید:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://amirrezaghaderi.ir/post/types/&#34;&gt;مفاهیم بنیادین تایپ سیستم ها&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://amirrezaghaderi.ir/post/adt/&#34;&gt;دیتا تایپ‌های جبری (‌‌ADT)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;اگر حوصله‌ی خواندن این مطالب را ندارید، پس حداقل به طور خلاصه این موارد را به یاد داشته باشید:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;تایپ: خصوصیتی است که تعیین می‌کند یک «داده» می‌تواند شامل چه «محتوا» ای باشد و چه کارهایی می‌توان با آن انجام داد. هر تایپ، مشخص کننده‌ی «مجموعه مقادیر یا حالاتی» است که یک داده می‌تواند به خود بگیرد.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;زبان Static Type: به زبانی «استاتیک تایپ» می‌گوییم که در آن فرآیند چک کردن تایپ‌ها «قبل از اجرای برنامه» اتفاق بیفتد.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;زبان Dynamic Type: به زبانی «داینامیک تایپ» می‌گوییم که در آن فرآیند چک کردن تایپ‌ها «در زمان اجرای برنامه» اتفاق بیفتد.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;زبان Strong Type: جدای از این قضیه که زبان استاتیک تایپ باشد یا داینامیک تایپ، اگر زبانی سیستم تایپ را با جدیت کامل اعمال کند، می‌گوییم که آن زبان دارای تایپ مستحکم یا استرانگ تایپ است. مثلا زبان نباید اجازه دهد داده‌ی عددی 12 با داده‌ی رشته‌ای “hi” جمع و تفریق شود.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;زبان Weak Type: جدای از این قضیه که زبان استاتیک تایپ باشد یا داینامیک تایپ، اگر زبانی سیستم تایپ را با جدیت کامل اعمال نکند، می‌گوییم که آن زبان دارای تایپ سُست یا ویک تایپ است. از نمونه‌های بارز چنین زبان‌هایی JS و PHP هستند. مثلا در این زبان‌ها عدد 6 را می‌توان با رشته‌ی &amp;ldquo;Hello&amp;rdquo; جمع بست؛ که از نظر منطقی بی‌معنی است!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;استاتیک بودن زبان، حتما به این معنی نیست که «اعلان‌های تایپ» را در کدهای‌مان ذکر کنیم: مثلا int (هرچند که اکثر این زبان‌ها چنین خصوصیتی دارند).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;استاتیک بودن زبان، ربطی به کامپایلری بودن یا نبودن زبان ندارد. (هرچند که اکثر آن‌ها کامپایلری می‌باشند). مثلا ارلنگ، الیکسیر، یا کلوژور همگی زبان‌های کامپایلری هستند، ولی تمام آن‌ها داینامیک تایپ می‌باشند!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;با این توضیحات، مطلب را ادامه می‌دهیم.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;why&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;چرا-زبان-های-استاتیک&#34;&gt;چرا زبان‌های استاتیک؟&lt;/h2&gt;

&lt;p&gt;تمام مزایای زبان‌های استاتیک تایپ، به طور مستقیم یا غیر مستقیم به این موضوع برمی‌گردد که «کامپایلر» یا «تایپ چِکِر» می‌تواند به کمک تایپ‌ها، اطلاعات بیشتری نسبت به کدهای ما داشته باشد. و همین اطلاعاتی که کامپایلر جمع آوری می‌کند، باعث می‌شود تا توانایی یاری رساندن به ما در زمان توسعه‌ی کدهایمان را داشته باشد.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;correctness&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;صحت&#34;&gt;صحت&lt;/h3&gt;

&lt;p&gt;عده‌ای فکر می‌کنند وقتی گفته می‌شود زبان‌های استاتیک تایپ ضریب «صحت» بالاتری برای کدها به ارمغان می آورند، منظور فقط این است که نوع متغیرها باهم اشتباه نمی‌شود! مثلا اگر پارامتر تابعی را از نوع int تعریف کنیم، و بعد‌ها به اشتباه به جایش یک داده‌ی string را ارسال کنیم، کامپایلر متوجه این خطا می‌شود. درست است، این هم در نوع خودش باعث بالا رفتن صحت کدها خواهد شد، ولی قضیه خیلی فراتر از این حرف هاست&amp;hellip;&lt;/p&gt;

&lt;p&gt;زبان‌های استاتیکی داریم که به کمک تایپ سیستم خود، مشکل تاریخیِ ارجاعات Null را حل کرده‌اند! یا مثلا زبانی مانند &lt;a href=&#34;https://www.rust-lang.org/en-US/&#34;&gt;Rust&lt;/a&gt; داریم که به کمک تایپ سیستم خود شرایطی را مهیا کرده است که بدون وجود GC،  بتوانیم براحتی حافظه را مدیریت کنیم؛ اگر کدهای شما در این زبان کامپایل شود، یعنی تایپ سیستم تایید کرده است که Memory leak در آن‌ها وجود نخواهد داشت. اگر کدهای شما در این زبان کامپایل شود، یعنی تایپ سیستم تایید کرده است که در بین Thread های شما Data Race اتفاق نخواهد افتاد!&lt;/p&gt;

&lt;p&gt;چنین چیزهایی فاکتور‌های &lt;strong&gt;بسیار&lt;/strong&gt; مهمی هستند. و تمام شان به کمک استاتیک تایپینگ ممکن شده‌اند و لازم نیست شما زحمت خاصی را برای‌شان متحمل شوید. کافیست در گوشه و کنار کدهای‌تان به طور خیلی مختصر یک سری اطلاعات را در اختیار کامپایلر قرار دهید، تا کامپایلر بتواند خودش بقیه کارها را برای‌تان انجام دهد.&lt;/p&gt;

&lt;p&gt;موضوع دیگر، بازخورد سریع در صورت وقوع خطاست. یعنی اگر کدهای شما دارای موارد اشتباهی بود، در همان پروسه‌ی کامپایل مشخص می‌شود و شما کلا به مرحله‌ی اجرا نمی‌رسید. در صورتی که زبان های داینامیک نمی‌توانند خطا ها را بدون اجرا کردن برنامه تشخیص دهند.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;speed&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;سرعت&#34;&gt;سرعت&lt;/h3&gt;

&lt;p&gt;کامپایلر با اطلاعاتی که به کمک استاتیک تایپینگ درباره کدهای شما بدست می‌آورد، می‌تواند تا جایی که برایش امکان دارد کدهای‌تان را قبل از اجرا بهینه سازی نمایند. به همین دلیل در اکثر اوقات (نه در همه‌ی اوقات)، زبان‌های استاتیک سرعت بالاتری به نسب زبان‌های داینامیک دارند.&lt;/p&gt;

&lt;p&gt;هر چه یک زبان تایپ سیستم بهتری داشته باشد، و هرچه برنامه‌نویس بتواند بهتر از تایپ سیستم در کدهایش استفاده کند، کامپایلر قادر خواهد بود اطلاعات بیشتری از کدها بدست بیاورد. و هر چقدر هم که کامپایلر بیشتر اطلاعات بدست بیاورد، ضریب بهینه‌سازی هایی که می‌تواند روی کدها انجام دهد بالاتر خواهد رفت.&lt;/p&gt;

&lt;p&gt;در زبان‌های داینامیک نمی توان قبل از اجرای برنامه هیچ حدسی راجع به کدها داشته باشیم! راه حلی که برای بهینه‌سازی در زبان‌های داینامیک پیشنهاد می‌شود استفاده از سیستم JIT است. این سیستم می‌تواند به منظور کسب اطلاعات مورد نیاز برای بهینه‌سازی، کدها را در زمان اجرا زیر نظر داشته باشد تا بر مبنای اطلاعاتی که جمع آوری می‌کند کدهای‌تان در همان حالی که در حال اجرا هستند بهینه سازی کند!&lt;/p&gt;

&lt;p&gt;مشکل اینجاست که خود JIT نوعی سربار است! چرا که این سیستم همگام با برنامه‌ی اصلی شما اجرا خواهد شد و به طور مداوم در حال کاوش در کدهای تان خواهد بود. یعنی خودش نیاز به CPU و حافظه اضافی دارد. از طرفی JIT یک راه حل «موقتی» است! زیرا زبان‌های استاتیک در هر نسخه‌ی جدیدی که ارائه می‌کنند سعی در این دارند که تایپ سیستم شان را نیز تقویت می‌کنند؛ به همین موازات کامپایلر به اطلاعات بیشتری دسترسی پیدا می‌کند و می‌تواند بهینه‌سازی های بیشتری انجام دهد. مثلا خیلی از بهینه‌سازی ‌هایی که امروزه در زبان‌های استاتیک صورت می‌گیرد، شاید تا همین ۵-۶ سال پیش ممکن نبوده‌اند.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;docs&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;مستندات&#34;&gt;مستندات&lt;/h3&gt;

&lt;p&gt;از خصوصیت‌های مستند سازی این است هر کسی با یک لحن متفاوت و از زوایه دید خودش آن‌ها را می‌نویسد. فرضا یک برنامه‌نویس شاید فکر کند که تابعی به بیشتر از یک خط مستندات نیاز نداشته باشد، در صورتی که برنامه نویس دیگر حس کند که توضیحات بیشتری باید لحاظ شود.&lt;/p&gt;

&lt;p&gt;از طرفی مستندات نیاز به حوصله‌ی بالایی دارند و ممکن است خیلی وقت‌ها زیر فشار و استرس ناشی از پروداکشن نادیده گرفته شوند؛ تا بعد‌ها در فرصت بهتری به آن‌ها رسیدگی شود. بنابراین این احتمال دارد که شما کدهای‌تان را تغییر دهید، ولی مستندات آن را چند روز بعد آپدیت کنید.&lt;/p&gt;

&lt;p&gt;تایپ، خودش یک نوع مستند سازی است! یعنی حتی اگر برای تابعی هیچ مستنداتی هم ارائه ندهیم، باز هم درک آن تابع از نسخه‌ی مترادف‌اش در یک زبان داینامیک راحت‌تر خواهد بود؛ چون این‌جا حداقل برنامه‌نویس لازم نیست نوع داده‌های ورودی و خروجی را خودش «حدس» بزند.&lt;/p&gt;

&lt;p&gt;مستندات فقط نوشته می‌شوند، ولی قابل چک شدن و اعتبارسنجی نیستند!&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;tools&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;ابزارهای-جانبی&#34;&gt;ابزارهای جانبی&lt;/h3&gt;

&lt;p&gt;یکی از اصلی ترین مزایای زبان‌های استاتیک این است که «کامپایلر» تنها عاملی نیست که می‌تواند درباره کدها اطلاعات جمع آوری کند! «ابزارهای جانبی» نیز می‌توانند کدهای شما را آنالیز کنند و اطلاعات مورد نیازشان را از آن استخراج نمایند.&lt;/p&gt;

&lt;p&gt;آن‌ها به کمک این اطلاعات قادر خواهند بود خدمات زیادی به برنامه‌نویسان ارائه کنند. مثلا IDE ها با آنالیز کدها، هنگامی که برنامه‌نویس مشغول نگارش است مدام او را در امر نوشتن راهنمایی می کنند و گزینه‌های مختلف را به او نشان می‌دهند. وجود چنین ابزارهایی زبان را برای استفاده در تیم‌های بزرگ آماده می‌کند.&lt;/p&gt;

&lt;p&gt;خوبی زبان‌های استاتیک این است که وقتی از طرف یک ابزار جانبی می خواهید با آن‌ها طرف شوید، به شکل یکسانی با آن‌ها در ارتباط خواهید بود. همه‌ی برنامه‌نویسان می‌دانند که قرار است به چه حالتی با تایپ سیستم در ارتباط باشند. فرضا سیستم‌هایی داریم که در صورت مشاهده‌ی پیغام خطا در ترمینال، می‌تواند آن را پردازش نمایند و به برنامه‌نویس اطلاع دهند. در زبان‌های داینامیک خیلی از پیغام ها بسته به سلیقه‌ی برنامه نویس آن پروژه نگارش می‌شوند در صورتی که در زبان های استاتیک از طرف خود زبان تولید می‌شوند و همیشه فرم یکسانی دارند.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;model&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;مدل-سازی-قبل-از-پیاده-سازی&#34;&gt;مدل‌سازی، قبل از پیاده‌سازی&lt;/h3&gt;

&lt;p&gt;در زبان‌های استاتیک قبل از اینکه کدهای اصلی‌تان را بنویسید، ابتدا به کمک تایپ‌ها ملزومات برنامه را مدل سازی می کنید. کامپایلر با کمک این مدل‌ها با کاری که قرار است انجام گیرد آشنا می‌شود؛ تا در هنگامی که به پیاده‌سازی این مدل‌ها می‌رسید، کامپایلر بتواند شما را در پیاده‌سازی بهتر کد‌های‌تان راهنمایی کند.&lt;/p&gt;

&lt;p&gt;در زبان‌های داینامیک شما یک سری از تشریفات این‌چنینی را لازم ندارید و می‌توانید به سرعت کد‌های‌تان را پیاده سازی کنید. این هم در نوع خودش یک مزیت است! ولی اینجا دیگر فقط خودتان هستید و خودتان! یعنی دیگر دستیاری در کار نیست که شما را در کار همراهی کند.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;refactoring&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;بازسازی-refactoring&#34;&gt;بازسازی (Refactoring)&lt;/h3&gt;

&lt;p&gt;فرض کنید به هر دلیلی تصمیم دارید قسمتی از کدهای‌تان را تغییر دهید. اگر کل کدهای‌تان در حد چندصد خط باشد، شاید خیلی این قضیه برای‌تان مهم جلوه نکند. ولی وقتی پروژه بزرگی را در اختیار داشته باشید متوجه می‌شوید که حتی اعمال تغییر در یکی از خطوط، می‌تواند در عملکرد چندین سورس کد دیگر تاثیر گذار باشد. اوضاع وقتی بدتر می‌شود که چند نفره در حال توسعه‌ی این پروژه باشید و اطلاع نداشته باشید که همکارتان چیزی را در جایی تغییر داده است.&lt;/p&gt;

&lt;p&gt;بدون وجود استاتیک تایپینگ، شما خیلی از مواقع متوجه این تدخلات نمی‌شوید. حتی ممکن است برنامه در ابتدا درست کار کند. شما هم آن را به مشتری تحویل دهید و یا روی پروداکشن فعال‌اش کنید. یکدفعه دو روز بعد مشتری زنگ می‌زند و اطلاع می‌دهد که در فلان جای برنامه مشکلی پیش آمده. باور کنید یا نکنید، خیلی از این خطاها با یونیت تست هم آشکار نمی‌شود. مخصوصا در برنامه‌های GUI یا برنامه‌های وب که تست کردن قسمت‌های گرافیکی برنامه خیلی راحت نیست.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;confidence&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;اعتماد-به-نفس-بالاتر&#34;&gt;اعتماد به نفس بالاتر!&lt;/h3&gt;

&lt;p&gt;به عنوان برنامه نویسی که کدهای داینامیک زیادی نوشته، اعتراف میکنم که همیشه هنگام تحویل پروژه به مشتری بسیار استرس داشته‌ام! حتی همین الان که در حال نوشتن این مطلب هستم میدانم که کدهای چند سال قبل‌ام در برخی پروژه‌ها، ممکن است در یک سری از سناریوهای خاص به مشکل بربخورد (و در حقیقت از روی شانس است تا الان بدون مشکل کار کرده‌اند!).&lt;/p&gt;

&lt;p&gt;همین استرس را موقع تحویل دادن کدهای استاتیک نیز دارم، ولی به مراتب کمتر! چون خیالم راحت بوده که کدهایم حداقل از لایه نظارتی تایپ سیستم عبور کرده است و این موضوع از شدت نگرانی‌هایم کم می‌کند. اگر هم بعدها لازم باشد پروژه را تغییر دهم، دیگر تک به تک خط‌ها را با ترس ادیت نمی‌کنم! می‌دانم که کامپایلر از کدهایی که من یک سال قبل نوشته‌ام، بهتر از خودم اطلاع دارد! کامپایلر پشتیبان من خواهد بود!&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;faq&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;سوال-و-جواب-های-متداول&#34;&gt;سوال و جواب‌های متداول&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
&lt;a name=&#34;just-test&#34;&gt;&lt;/a&gt;
&lt;strong&gt;با وجود تست ها، باز هم به تایپ نیاز داریم؟&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;تایپ ها می‌توانند شما را از تست نوشتن برای گروه بزرگی از موارد راحت کنند! و شما را قادر می‌سازند تا برای آن گروه از موارد دیگر نیز تست های موثر تری ارایه دهید. یعنی حالا تست های شما متوجه موارد خاص تر و مهم تر خواهد بود. نه اینکه بیایید و تست کنید که آیا اگر در فلان تابع به جای مقدار عددی، مقدار رشته ای وارد کردیم، تابع قرار است چگونه عکس العمل نشان دهد!&lt;/p&gt;

&lt;p&gt;حالا خودمانیم! واقعا فکر می‌کنید همه‌ی برنامه‌نویس‌ها با وسواس برای کدهای‌شان تست می‌نویسند؟ یا همان‌هایی هم که می نویسند، چند درصد از تست‌هایشان واقعا موثر هست و چند درصد فقط جنبه‌ی نمایشی دارد برای راضی نگه مدیر پروژه؟&lt;/p&gt;

&lt;p&gt;&lt;br&gt;
&lt;a name=&#34;erlang&#34;&gt;&lt;/a&gt;
&lt;strong&gt;چطور یکی از پایدارترین سیستم‌های نرم‌افزاری دنیا با ارلنگ که یک زبان داینامیک است نوشته شده؟&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;این داستان برمی‌گردد به آپ‌تایم 99.9999999% برخی از سرویس‌های اریکسون که با &lt;a href=&#34;https://www.erlang.org/&#34;&gt;ارلنگ&lt;/a&gt; نوشته شده‌اند. بدست آوردن این درصد بالا از آپ‌تایم، کلا در هیچ زبانی راحت نیست؛ فرقی هم ندارد که زبان استاتیک باشد یا داینامیک.&lt;/p&gt;

&lt;p&gt;درباره ارلنگ، باید چند موضوع را در نظر داشته باشید:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;اصلی‌ترین مزیت ارلنگ، خصوصیت Fault tolerance بودن آن است. یعنی مکانیز‌های زیادی در آن پیش‌بینی شده تا در مواجه با خطا، سیستم بتواند به کار مداوم خود ادامه دهد. بنابراین آن آپ‌تایم عجیب و غریبی که می‌بینید به این خاطر نیست که در ارلنگ هیچ خطایی پیش نخواهد آمد؛ ممکن است در همان سیستم نیز روزانه صدها و شاید هزاران خطا پیش می‌آمده، ولی مهندسان حتما از خصوصیت‌های Fault tolerance استفاده کرده‌اند تا سیستم حتی با وجود این خطاها نیز متوقف نشود. قضیه کلا ربطی به استاتیک بودن یا داینامیک بودن ارلنگ ندارد!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;داینامیک بودن ارلنگ، بر مبنای «نیاز سیستم» بوده است؛ و نه بر مبانی «راحتی»! قضیه این است که ران‌تایم ارلنگ به منظور خاصیت Fault tolerance بودن آن، طبیعت‌ای بسیار داینامیک دارد. و منطقی است که برای طرف شدن با چنین ران‌تایمی، از یک زبان داینامیک استفاده شود.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;سیستم‌های ارلنگ در اریکسون، توسط خود سازندگان ارلنگ و تیم توسعه دهنده آن ساخته شده است. افرادی که بسیار بهتر از من و شما از داخل و خارح ارلنگ خبر دارند. مشخص است اگر کار را به چنین چنین گروهی بدهید نتیجه مناسبی خواهید گرفت. واقعا فکر می‌کنید تمام دیگر شرکت‌هایی که از ارلنگ استفاده کرده‌اند هم همینطور آپ‌تایم بالا داشته‌اند؟&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;به گفته‌ی جو آرمسترانگ استفاده از &lt;a href=&#34;http://learnyousomeerlang.com/dialyzer&#34;&gt;Dialyzer&lt;/a&gt; موقع توسعه‌ی کدهای ارلنگ برای پروداکشن، یک پیشفرض محسوب می‌شود! باید مطلع باشید که ارلنگ از مدت‌ها قبل  به استاتیک‌تایپینگ اختیاری مجهز شده است؛ Dialyzer تایپ‌چِکِرِ مختص به ارلنگ است که می‌تواند کدهای ارلنگ را از نظر درستی تایپ‌ها بررسی کند. درصد بالایی از برنامه‌نویسان ارلنگ کدهای‌شان را تایپ نگاری می کنند.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;
&lt;a name=&#34;facebook-php&#34;&gt;&lt;/a&gt;
&lt;strong&gt;پس چرا فیسبوک هنوز از PHP که یک زبان داینامیک است استفاده می‌کند؟&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;استفاده نمی‌کند! با بزرگ شدن فیسبوک، خودشان متوجه شدند که PHP دیگر جواب گوی نیازشان نیست. فیسبوک در نهایت به خاطر کمبود سرعت و مشکل در ریفکتور کردن کدها، مجبور به ساختن &lt;a href=&#34;http://hacklang.org/&#34;&gt;Hack&lt;/a&gt; و HHVM شد. &lt;a href=&#34;https://code.facebook.com/posts/264544830379293/hack-a-new-programming-language-for-hhvm/&#34;&gt;اطلاعات بیشتر درباره وضعیت PHP در فیسبوک&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;
&lt;a name=&#34;insta-python&#34;&gt;&lt;/a&gt;
&lt;strong&gt;پس چرا اینستاگرام هنوز از پایتون که یک زبان داینامیک است استفاده می‌کند؟&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;پایتون در اینستاگرام، آن چیزی نیست که شما از سایت رسمیِ پایتون دانلود می کنید! پایتونی که در اینستاگرام استفاده می‌شود از بالا و پایین و چپ و راست بهینه سازی شده! جدای از مشکل سرعت، اینستاگرام هم در رفکتور کردن کدها به مشکل برخورده و کدهاش را کم کم به سمت &lt;a href=&#34;http://mypy-lang.org/&#34;&gt;MyPy&lt;/a&gt; که تایپ سیستم اختیاری پایتون است می‌برد. مدتی پیش اعلام کرد که توانسته یک/سوم کدهایش را با MyPy سازگار کند. &lt;a href=&#34;https://engineering.instagram.com/let-your-code-type-hint-itself-introducing-open-source-monkeytype-a855c7284881&#34;&gt;اطلاعات بیشتر درباره وضعیت پایتون در اینستاگرام&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;
&lt;a name=&#34;i-dont-need-speed&#34;&gt;&lt;/a&gt;
&lt;strong&gt;من برایم سرعت مهم نیست؛ آیا باز هم به استاتیک تایپنگ نیاز دارم؟&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;زبان‌های مبتنی بر جاوا اسکریپت همگی روی استاتیک تایپ بودن مانور می‌دهند. PHP در هر نسخه‌ی جدید که منتشر می‌کند در حال توسعه‌ی تایپ نگاری در کدهاست تا با ابزارهای نظیر &lt;a href=&#34;https://github.com/phan/phan&#34;&gt;Phan&lt;/a&gt; بتواند کدها را آنالیز کند. پایتون برای خودش پروژه‌ی MyPy را راه انداخته که خالق پایتون نیز مدیر این پروژه است. کلوژور در ورژن‌های جدیدتر تایپ نگاری را جدی گرفته. ارلنگ و الیکسیر از دیرباز دارای استاتیک تایپینگ اختیاری بوده‌اند&amp;hellip;&lt;/p&gt;

&lt;p&gt;نکته این جاست: اضافه کردن قابلیت‌های استاتیک تایپینگ در این زبان‌هایی که اسم بردم، هیچ منفعتی از نظر سرعت برایشان نداشته است! فرضا اگر کدهای پایتون را تایپ نگاری کنید، هیچ فرقی از سرعت با کدهای تایپ نگاری نشده نخواهند داشت. پس اگر همه چیز سرعت بود، چرا سازندگان و توسعه دهندگان این زبان‌ها در تکاپو هستند که امکانات استاتیک تایپینگ را به زبان اضافه کنند؟ سرعت، «فقط یکی» از عوامل سودمند استاتیک تایپینگ است.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;
&lt;a name=&#34;i-have-small-project&#34;&gt;&lt;/a&gt;
&lt;strong&gt;برنامه‌ی من زیاد بزرگ نیست، آیا باز هم به استاتیک تایپنگ نیاز دارم؟&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;اول باید مشخص کرد که منظور ما از یک «برنامه‌ی بزرگ» چیست! فرضا من اگر پروژه ای داشته باشم که کدهایش بیشتر از ۲-۳ هزار خط شود، آن پروژه را یک برنامه‌ی بزرگ به حساب می‌آورم! ممکن است بگویید مقیاسی که عنوان کردی بسیار ناچیز و کوچک است؛ اما من بزرگ بودن برنامه را به میزان سرعت، یا بزرگی تیم، یا شمار بالای مشتریان نمی‌بینم؛ برای من بزرگی پروژه مبتنی بر این است که تا چه حد بتوانم بخش‌های مختلف آن را ذهن نگه داری کنم؟&lt;/p&gt;

&lt;p&gt;فرضا اگر خواستم در فایل B، یکی از توابعی را که خودم در فایل A نوشته‌ام را استفاده کنم، باید بتوانم خیلی راحت این کار را انجام دهم. اما اگر طرز کار یا پارامترهای آن تابع را یادم رفت و مجبور شدم برای یادآوری فایل A را دوباره باز کنم تا بتوانم نگاهی به آن تابع بیندازم، یعنی پروژه به قدری بزرگ شده که من نتوانسته‌ام تمام بخش‌های آن را در ذهن نگه داری کنم. در این چنین شرایطی استفاده از یک زبان استاتیک تایپ مناسب خواهد بود.&lt;/p&gt;

&lt;p&gt;بنابراین جواب این سوال بستگی به خودتان دارد. اگر مقیاس برنامه در حدی بود که براحتی توانستید بخش‌های مختلف آن را به ذهن بسپارید، بنابراین زبان‌های داینامیک هم گزینه‌ی مناسبی هستند.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;end&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;سخن-آخر&#34;&gt;سخن آخر&lt;/h2&gt;

&lt;p&gt;اصلی ترین مزیت زبان‌های داینامیک تمرکز روی الگوریتم  است. یعنی با کمترین تشریفات و پیش‌نیازها، بتوانیم فکر و وقت خود را به پیاده سازی الگوریتم اختصاص دهیم.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;in-red&#34;&gt;
زبان‌های استاتیک مانند یک سرمایه گذاری هستند!
&lt;/span&gt;
یعنی شما کمی بیشتر وقت میگذارید تا کدهای تان را بهتر برای کامپایلر توضیح دهید، اما از آن طرف هم کامپایلر هوای شما را خواهد داشت. اگر این سرمایه گذاری را انجام دهید و زبان نتواند به میزان کافی به شما سود برساند آن موقع می گوییم که زبان، تایپ سیستم مناسبی ندارد؛ یا شاید هم ما بدرستی از تایپ سیستم زبان استفاده نکرده ایم! که در بیشتر مواقع این دومی است!&lt;/p&gt;

&lt;p&gt;به صرف این قضیه که در یک زبان استاتیک کد می‌نویسید، کدهای شما ایمن نخواهند شد. و اگر هم در یک زبان داینامیک کد بزنید، قرار نیست حتما دچار مشکل شوید. نقش شما به عنوان برنامه نویس در این قضایا بسیار مهم است. انتخاب بین زبان‌های استاتیک و داینامیک نیز به تصمیم شما و سناریو ای که برای پروژه پیش روی خود دارید وابسته است&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>دیتا تایپ‌های جبری (‌‌ADT)</title>
      <link>https://amirrezaghaderi.com/fa/blog/adt/</link>
      <pubDate>February 6, 2018</pubDate>
      <author>Amirreza Ghaderi</author>
      <guid>https://amirrezaghaderi.com/fa/blog/adt/</guid>
      <description>

&lt;p&gt;&lt;a name=&#34;toc&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;فهرست-مطالب&#34;&gt;فهرست مطالب&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#intro&#34;&gt;مقدمه&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#type-is-set&#34;&gt;هر تایپ، یک مجموعه است&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adt&#34;&gt;دیتا تایپ جبری&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#product-type&#34;&gt;ضرب یا Product&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#create-product-type&#34;&gt;چگونه یک Product Type تعریف کنیم؟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#c-struct&#34;&gt;struct در C&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sum-type&#34;&gt;جمع یا Sum&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#create-sum-type&#34;&gt;چگونه یک Sum Type تعریف کنیم؟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#c-union&#34;&gt;Union ها در زبان C&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#c-enum&#34;&gt;Enum ها در زبان C&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#c-tagged-union&#34;&gt;Tagged Union در زبان C&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sum-types-in-modern-pl&#34;&gt;تعریف Sum Type در زبان های مدرن&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#option-type&#34;&gt;تایپ Option&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#end&#34;&gt;سخن آخر&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;intro&#34;&gt;&lt;/a&gt;&lt;a name=&#34;مقدمه&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;مقدمه&#34;&gt;مقدمه&lt;/h2&gt;

&lt;p&gt;مدتی پیش یک پست بُلندبالا نوشتم و تعدادی از مفاهیم مربوط به تایپ سیستم‌ها را در آن شرح دادم؛ اما یکی از مهم‌ترین مفاهیمی که باید در آن پست قرار می‌دادم را از قلم انداختم. دلیل اصلی‌اش هم این بود که فکر می‌کردم این مفهموم آنقدر مهم هست که باید یک پست مجزا را به آن اختصاص دهم.&lt;/p&gt;

&lt;p&gt;«دیتا تایپ‌های جبری» یا Algebraic Data Types (که با نام اختصاری ADT) شناخته می‌شوند، از مهم‌ترین و پایه‌ای ترین مفاهیم تایپ سیستم‌ها هستند که متاسفانه خیلی از برنامه‌نویسان آشنایی مناسبی با آن‌ها ندارند؛ این قضیه هم مختص برنامه‌نویسان ایرانی نیست. نکته‌ی عجیب ماجرا اینجاست که تقریبا تمام برنامه‌نویسان کم و بیش با این تایپ‌ها سر و کار داشته اند.&lt;/p&gt;

&lt;p&gt;دیتا تایپ‌های جبری با زبان ML معروف شدند؛ و هر زبانی که به نوعی ایده‌هایی از ML را در خود دارد نیز کم و بیش دارای دیتا تایپ‌های جبری می‌باشد. زبان‌هایی مانند Haskell ، Scala، Rust، Swift، Clojure، Erlang/Elixir، Ocaml، TypeScript و&amp;hellip; برای همین تصمیم گرفتم مطابق مطالب پیشین این وبلاگ، در این پست به زبانی ساده مفهموم دیتا تایپ‌های جبری را شرح دهم.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;type-is-set&#34;&gt;&lt;/a&gt;&lt;a name=&#34;هر تایپ، یک مجموعه است&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;هر-تایپ-یک-مجموعه-است&#34;&gt;هر تایپ، یک مجموعه است&lt;/h2&gt;

&lt;p&gt;در مقاله‌ی مربوط به «مفاهیم بنیادین تایپ سیستم‌ها»، مفهوم «تایپ» را به این صورت تعریف کردیم:&lt;/p&gt;

&lt;p&gt;«خصوصیتی است که تعیین می‌کند یک «داده»، می‌تواند شامل چه «محتوا» ای باشد و چه کارهایی می‌توان با آن انجام داد».&lt;/p&gt;

&lt;p&gt;فرضا وقتی می‌گوییم متغیر A از تایپ int است منظورمان چیست؟ یعنی متغیر A می‌تواند شامل «یکی» از حالاتی باشد که از طرف تایپ int قابل ارائه است.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;سوال: تایپ int چه حالاتی را ارائه میکند؟&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;با فرض بر اینکه int را از نوع ۳۲بیتی در نظر گرفته باشیم، مقادیر قابل ارائه در تایپ int یکی از اعدادی خواهد بود که بین منفی 2147483648 تا مثبت 2147483647 هستند. میتوان اینطور گفت که int در واقع بیان کننده‌ی «مجموعه» مقادیری است که بین این دو عدد قرار دارد. اگر بخواهیم به زبان ریاضی توضیح دهیم یعنی این:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Text&#34; data-lang=&#34;Text&#34;&gt;int = {-2147483648, -2147483647, -2147483646, . . . , 2147483647}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;چنین تعریفی برای بقیه تایپ‌ها نیز صدق می‌کند. مثلا تایپ string شامل «مجموعه»ای است که از تمام کاراکترهای یونیکد تشکیل شده است. یا مثلا تایپ bool یا boolean شامل «مجموعه» ای دو عضوی است: true یا false&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;in-red&#34;&gt;
پس هر تایپ، در قالب یک «مجموعه» قابل تعریف است. (Set)
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;adt&#34;&gt;&lt;/a&gt;&lt;a name=&#34;دیتا تایپ جبری&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;دیتا-تایپ-جبری&#34;&gt;دیتا تایپ جبری&lt;/h2&gt;

&lt;p&gt;از آنجایی که هر تایپ یک مجموعه است، پس قادر هستیم عملیات جبری مربوط به مجموعه‌ها مثل «اشتراک» و «اجتماع» و &amp;hellip; را روی آن‌ها اعمال کنیم! بنابراین دیتا تایپ‌های جبری را می‌توان اینچنین تعریف کرد:&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;in-red&#34;&gt;
«تایپ‌هایی که می‌توانیم عملیات‌های جبری مربوط به مجموعه‌ها را روی آن‌ها اعمال کنیم. در این تعریف، منظورمان از عملیات جبری مشخصا عمل «ضرب» و «جمع» می‌باشد.»
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;در تعریف بالا:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;منظورمان از «ضرب»، همان «ضرب دکارتی» است که به انگلیسی با عنوان Product یا Cartesian product شناخته می‌شود.&lt;/li&gt;
&lt;li&gt;و منظورمان از «جمع»، همان «اجتماع» یا Union است.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;من خودم با اینکه ارزش بسیار زیادی برای ریاضیات قائل هستم، اما هیچوقت در آن خوب نبودم! بنابراین مطمئن باشید که این تعاریف را به ساده‌ترین حالت ممکن توضیح خواهم داد.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;product-type&#34;&gt;&lt;/a&gt;&lt;a name=&#34;ضرب یا Product&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ضرب-یا-product&#34;&gt;ضرب یا Product&lt;/h2&gt;

&lt;p&gt;همانطور که گفتیم در این مقاله منظورمان از «ضرب»، همان ضرب دکارتی است.&lt;/p&gt;

&lt;p&gt;تعریف ضرب دکارتی:&lt;/p&gt;

&lt;p&gt;اگر دو مجموعه داشته باشیم به نام‌های A و B ، حاصلضرب دکارتی این دو مجموعه را با نماد  A × B نشان خواهیم داد؛ و نتیجه‌ی آن برابر است با مجموعه‌ای که عضوهایش شامل تمام ترکیباتی باشد که عنصر اول آن از اعضای A انتخاب شده باشد و عنصر دیگر آن از اعضای B باشد.&lt;/p&gt;

&lt;p&gt;مثال:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Text&#34; data-lang=&#34;Text&#34;&gt;A = { x, y }

B = { 3, 4, 5 }

A × B = { (x , 3), (x , 4), (x , 5),
          (y , 3), (y , 4), (y , 5) }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;دقت کنید اعضای مجموعه‌ی نهایی که از حاصلضرب دکارتی دو مجموعه‌ی اول بدست آمده‌اند، هر کدام در قالب یک «ترکیب» در مجموعه حاضر شده‌اند. مثلا مانند (x , 3).&lt;/p&gt;

&lt;p&gt;اگر همین تعاریف را بخواهیم در برنامه‌نویسی وارد کنیم، میگوییم که:&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;in-red&#34;&gt;
اگر یک «پروداکت تایپ» داشته باشیم، مقدار مورد قبول آن می‌تواند شامل عناصر ترکیبی ای باشد که در مجموعه حالات آن تایپ تعریف شده است.
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;create-product-type&#34;&gt;&lt;/a&gt;&lt;a name=&#34;چگونه یک Product Type تعریف کنیم؟&#34;&gt;&lt;/a&gt;
&lt;strong&gt;چگونه یک Product Type تعریف کنیم؟&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;پروداکت تایپ ها در اکثر زبان‌های برنامه نویسی حضور دارند و همه‌ی شما با آن‌ها کار کرده اید! برای تعریف یک پروداکت تایپ جدید، می توانید از ساختار‌های ترکیبی مانند struct یا class یا tuple استفاده کنید. مثلا میخواهیم یک تایپ تعریف کنیم که وضعیت حضور و غیاب و شماره صندلی دانش آموزان را با آن بیان نماییم. میتوانیم این تایپ را به شکل یک پرداکت تایپ تعریف کنیم. کد آن در زبان C چیزی شبیه این خواهد بود:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;present&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;seatNumber&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ClassRoomStudent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(حواس‌تان باشد که تایپ bool در ویرایش C99 به زبان C اضافه شده است)&lt;/p&gt;

&lt;p&gt;و در قسمت‌های دیگر کدهای خود می‌توانیم به چنین شکلی از این تایپ استفاده کنیم:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;n&#34;&gt;ClassRoomStudent&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sara&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ClassRoomStudent&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;john&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ClassRoomStudent&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;steve&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sara&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;present&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Sara is here and her seat number is: %d&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sara&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;seatNumber&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a name=&#34;c-struct&#34;&gt;&lt;/a&gt;&lt;a name=&#34;struct در C&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;struct-در-c&#34;&gt;struct در C&lt;/h2&gt;

&lt;p&gt;یک struct در زبان C می‌تواند چندین تایپ گوناگون را در قالب یک تایپ جدید در کنار هم گردآوری کند. برای هر کدام از تایپ هایی که در struct لیست شده‌اند نیز اسمی در نظر گرفته می‌شود تا توسط آن‌ها بتوان تایپ ها را مقدار دهی کرد. (مثل present یا seatNumber در مثال بالا).&lt;/p&gt;

&lt;p&gt;سایز یک struct در حافظه، برابر است با مجموع سایز تمام تایپ هایی که در آن لیست شده اند. فرضا در مثال بالا یک تایپ bool و یک تایپ int را در struct لیست کرده ایم پس سایز این struct برابر است با : 1+4 = 5 بایت. (فرض کرده ایم که هر int را معادل ۴ بایت است. همچنین ۳ بایت هم برای padding اضافه خواهد شد)&lt;/p&gt;

&lt;p&gt;دقت کنید که وقتی خواستیم یک نمونه از روی struct خود ایجاد کنیم، چگونه متغیرهای sara یا john  را به صورت ترکیبی مقدار دهی کردیم&amp;hellip; این ترکیب برابر است با همان ترکیبی که در تایپ ClassRoomStudent مشخص کرده بودیم.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;سوال: مجموعه مقادیری که پروداکت تایپ ClassRoomStudent میتواند ارائه کند چیست؟&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;عنصر اول از تایپ ClassRoomStudent برابر با bool است و bool شامل دو عضو true یا false می‌باشد.&lt;/li&gt;
&lt;li&gt;عنصر دوم از تایپ ClassRoomStudent برابر با int است و int شامل 4294967296 رقم مختلف است که بین اعداد منفی 2147483648 تا مثبت 2147483647 قرار دارند.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;بنابراین مجموعه حالات ClassRoomStudent برابر مجموعه‌ی زیر است:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Text&#34; data-lang=&#34;Text&#34;&gt;ClassRoomStudent = { (true , -2147483648), (true , -2147483647), . . ., (false , 2147483647) }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;اگر تا الآن برایتان سوال بود که کامپایلر چگونه مقادیر مربوط به تایپ‌های شما را از نظر درستی چک میکند، حالا دیگر جواب آن را می‌دانید. کامپایلر مقداری که عنوان کرده اید را بررسی میکند و جویای این می‌شود که آیا مقدار شما جزو مجموعه‌ی مقادیر تایپ مورد نظرتان هست یا خیر. در حقیقت اعمال ریاضی مربوط به تئوری مجموعه‌ها در حال انجام کارتان هستند!&lt;/p&gt;

&lt;p&gt;همانطور که دیدید بدون اینکه تا قبل از این با مفهوم پروداکت تایپ ها آشنا باشید، به صورت روزمره از آن ها استفاده می‌کردید. پس تا اینجای کار مشکلی نیست&amp;hellip; اژدها در بخش بعدی وارد خواهد شد!&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;sum-type&#34;&gt;&lt;/a&gt;&lt;a name=&#34;جمع یا Sum&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;جمع-یا-sum&#34;&gt;جمع یا Sum&lt;/h2&gt;

&lt;p&gt;بالاتر اشاره کردیم که منظورمان  از «جمع»، همان «اجتماع» یا Union است. (در برنامه‌نویسی با گونه‌ای از Union ها به اسم Tagged union بیشتر طرف خواهید شد.)&lt;/p&gt;

&lt;p&gt;تعریف اجتماع:&lt;/p&gt;

&lt;p&gt;اگر دو مجموعه داشته باشیم به نام‌های A و B ، اجتماع این دو مجموعه را با نماد  A ∪ B  نشان خواهیم داد؛ و نتیجه‌ی آن برابر است با مجموعه‌ای که اعضایش «یا» در A هستند، «یا» در B هستند، و «یا» در هردوی آن‌ها. (حواس‌تان باشد که روی «یا» حساسیت به خرج داده ام!)&lt;/p&gt;

&lt;p&gt;مثال:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Text&#34; data-lang=&#34;Text&#34;&gt;A = { x, y }

B = { 3, 4, 5 }

A ∪ B = { x, y, 3, 4, 5 }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;بر خلاف پرداکت، اینجا میبینید که اعضای مجموعه‌ی نهایی به صورت فردی و تنها ظاهر شده‌اند.&lt;/p&gt;

&lt;p&gt;اگر همین تعاریف را بخواهیم در برنامه‌نویسی وارد کنیم، میگوییم که:&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;in-red&#34;&gt;
اگر یک «سام تایپ» داشته باشیم، مقدار مورد قبول آن می‌تواند «یکی»، و &lt;strong&gt;فقط «یکی»&lt;/strong&gt;، از عناصری باشد که در مجموعه حالات آن تایپ تعریف شده است.
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;چگونه یک Sum Type تعریف کنیم؟&#34;&gt;&lt;/a&gt;&lt;a name=&#34;create-sum-type&#34;&gt;&lt;/a&gt;
&lt;strong&gt;چگونه یک Sum Type تعریف کنیم؟&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;برعکس پروداکت تایپ ها که در اکثر زبان های برنامه نویسی براحتی تعریف می‌شوند، متاسفانه سام تایپ ها در هر زبانی وجود ندارند! در زمان نگارش این مقاله، بیشتر زبان‌های رده اول دنیا پشتیبانی مناسبی از سام تایپ ها ارائه نمی‌کنند. زبان‌های داینامیک مانند Python، PHP، Ruby یا JS که کلا استاتیک تایپ نیستند؛ زبان‌هایی مانند C، ++C، Java و #C نیز پشتیبانی مناسبی از سام تایپ ها ندارد.&lt;/p&gt;

&lt;p&gt;اما زبان‌های مدرن تر مثل Scala، Rust، Swift، TypeScript، OCaml، #F یا Haskell همگی دارای پشتیبانی خوبی از سام تایپ ها می باشند.&lt;/p&gt;

&lt;p&gt;برای اینکه بدانید داستان از چه قرار است، باید کمی برگردیم به عقب و یک سری از ساختارهای موجود در زبان C را با هم مررو کنیم.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;Union ها در زبان C&#34;&gt;&lt;/a&gt;&lt;a name=&#34;c-union&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;union-ها-در-زبان-c&#34;&gt;Union ها در زبان C&lt;/h2&gt;

&lt;p&gt;union یکی از قدرتمند‌ترین و در عین حال خطرناک ترین قابلیت‌‌ها در زبان C است! تعریف یک union در زبان C دقیقا مانند تعریف کردن یک struct است:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;union&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;weight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PersonInfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;اما union چند فرق اساسی با struct دارد:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;در هر لحظه، فقط یکی از فیلدهای موجود در union می تواند فعال باشد و مورد استفاده قرار گیرد!&lt;/li&gt;
&lt;li&gt;فضای موجود در union به صورت اشتراکی بین فیلدهایش استفاده خواهد شد.&lt;/li&gt;
&lt;li&gt;سایز یک union برابر است با سایز بزرگ‌ترین تایپ ای که در آن وجود دارد.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;یعنی سایز union در مثال بالا برابر است با سایز char* که بزرگ‌ترین فیلد union است: 8 بایت! در حالی که اگر به صورت struct تعریف‌اش می‌کردیم، سایز برابر بود با: 8+4+4+4 = 20 به اضافه‌ی 4 بایت برای padding.&lt;/p&gt;

&lt;p&gt;همانطور که می‌بینید در زمان‌هایی که بین چندین حالت، فقط نیاز به یکی از آن حالات داریم، استفاده از union ها می‌تواند بسیار در مصرف حافظه صرفه جویی کند!&lt;/p&gt;

&lt;p&gt;«صرفه جویی در مصرف حافظه» چیزی است که نظر بیشتر برنامه‌نویسان را به خود جلب می‌کند؛ ولی همین قضیه باعث می‌شود که به نکته‌ی بسیار مهم‌تری توجه کافی نکنند! این نکته‌ی مهم چیست:&lt;/p&gt;

&lt;p&gt;ما می‌خواستیم داده‌ای را راجع به یک شخص بیان کنیم. فرضا بگوییم اسم او چیست؛ یا سن او چقدر است؛ یا قد او چند سانت است؛ اما برای بیان این داده‌ها باید با تایپ‌های مختلفی سر و کله می‌زدیم. مثلا اسم از تایپ رشته‌ایست، یا قد از تایپ عددی است. اما با کمک union بالا، ما می توانیم تمام این داده‌ها را با تایپ PersonInfo ابراز کنیم! یعنی ما یک تایپ با اسم PersonInfo ساختیم که قابلیت این را دارد تا با توجه به نیاز ما، حالت یک رشته یا عدد یا هر چیز دیگری را به خود بگیرد! همین یک قضیه به تنهایی درهای زیادی را به روی شما باز خواهد کرد!&lt;/p&gt;

&lt;p&gt;کاری که یک Union می‌تواند برای تایپ ها انجام دهد (و در کل سام تایپ ها)، مانند کاری است که Docker برای برنامه‌ها انجام می‌دهد! اگر از بیرون نگاه کنید تایپ ما یک هویت واحد دارد، ولی از داخل می‌تواند به شیوه‌ی های مختلفی بیان شود. با سام تایپ ها می‌توان خلا موجود در بین مفاهیمی مثل Inheritance و Interface و Generic را پر کرد! (در آینده و در یک مطلب مجزا این موضوع را بیشتر برای‌تان شرح خواهم داد). فعلا همین قدر بدانید که Sum Type ها از جمله‌ی مهم ترین مفاهیم در مبحث تایپ سیستم ها می‌باشند!&lt;/p&gt;

&lt;p&gt;تا اینجا با دلیل قدرت‌مند بودن union ها آشنا شدیم؛ اما چرا گفتیم که union ها بسیار خطرناک هستند؟ در بخش قبل گفتیم که فضای موجود در یک union به طور اشتراکی توسط فیلدهایش استفاده می‌شود. یعنی در union بالا اگر به فیلد age مقدار بدهیم، مقدار موجود در فیلدهای دیگر مثل height  یا  weight را بازنویسی یا overwrite خواهد کرد! اگر در آن لحظه بخواهیم به فیلدهای height یا  weight دسترسی داشته باشیم، با داده‌ای غلط و درهم و برهم مواجه خواهیم شد!&lt;/p&gt;

&lt;p&gt;هیچ راهی هم نداریم که بتوانیم از یک union سوال کنیم در حال حاضر کدام یک از فیلدهایش فعال است. یعنی تنها راه این است که خودمان تمام دسترسی هایی که به فیلدهایش انجام می‌دهیم را به ذهن بسپاریم و حواس‌مان باشد که به اشتباه فیلدی را صدا نزنیم که غیر فعال است. این موضوع باعث به وجود آمدن خطاهای بسیار زیاد خواهد شد. خوشبختانه برنامه‌نویسان C راه حلی برای این مورد پیدا کرده‌اند&amp;hellip; فعلا این را در ذهن نگه دارید تا پایین‌تر به آن برگردیم&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;Enum ها در زبان C&#34;&gt;&lt;/a&gt;&lt;a name=&#34;c-enum&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;enum-ها-در-زبان-c&#34;&gt;Enum ها در زبان C&lt;/h2&gt;

&lt;p&gt;با enum می‌توانید تعدادی «ثابتِ عددی» که با یکدیگر دارای ارتباط منطقی هستند را در کنار هم گرد آورید! همچنین می توانید برای هر کدام از این ثابت‌های عددی یک اسم تعیین کنید تا کدهای‌تان با معنی‌تر شوند.&lt;/p&gt;

&lt;p&gt;مثلا به جای اینکه «روز هفته» را با اعداد ۱ یا ۲ یا ۳ یا &amp;hellip; تعریف کنید، می توانید به شکل زیر از enum استفاده کنید تا کدهای‌تان تمیزتر و بامعنی‌تر شود:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
    &lt;span class=&#34;n&#34;&gt;Sunday&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;Monday&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;Tuesday&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;Wednesday&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;Thursday&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;Friday&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;Saturday&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WeekDay&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;


&lt;span class=&#34;n&#34;&gt;WeekDay&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;day&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Monday&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;مخصوصا وقتی می‌خواهید در کدهای‌تان مقادیری برای Flag ها یا Status Code ها تعریف کنید، استفاده از enum ها توصیه می‌شود.&lt;/p&gt;

&lt;p&gt;ویژگی‌های enum :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;هر تعداد ثابت که دوست داشته باشید می‌توانید در یک enum تعریف کنید، ولی در هر لحظه فقط یکی از آن‌ها قابل انتخاب شدن خواهد بود.&lt;/li&gt;
&lt;li&gt;ثابت‌ها به ترتیب تعریف شدن‌شان، به طور اتوماتیک مترادف با عدد 0 تا n خواهند شد.&lt;/li&gt;
&lt;li&gt;تایپ تمام این ثابت‌ها برابر با int است.&lt;/li&gt;
&lt;li&gt;سایز کلی یک enum برابر با سایز تایپ int است (معمولا 4 بایت). فرقی هم ندارد که چند ثابت در آن تعریف کرده باشید.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;enum ها در زبان‌های دیگری مانند C++ یا Java یا C# هم کم و بیش همین ویژگی‌ها را دارند (هر کدام مقداری قابلیت‌های مختلف به enum ها اضافه کرده‌اند، ولی اساس کارشان یک‌ایست)&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;Tagged Union در زبان C&#34;&gt;&lt;/a&gt;&lt;a name=&#34;c-tagged-union&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;tagged-union-در-زبان-c&#34;&gt;Tagged Union در زبان C&lt;/h2&gt;

&lt;p&gt;در بخشی که union ها را توضیح دادیم، مشکل اساسی آن‌ها را نیز بیان کردیم؛ همچنین گفتیم که برنامه‌نویسان C راه حلی برای دور زدن این مشکل پیدا کرده‌اند. این راه حل به شرح زیر است:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;union مد نظرمان را درون یک struct بسته‌بندی می‌کنیم.&lt;/li&gt;
&lt;li&gt;درون آن struct یک فیلد اضافه با نام tag در کنار union قرار می‌دهیم. با این فیلد تعیین می‌کنیم که کدام یک از عناصر union در آن لحظه فعال است.&lt;/li&gt;
&lt;li&gt;هر بار که بخواهیم عنصری از union را مقداردهی کنیم، باید مقدار tag را هم به تناسب آن تغییر دهیم.&lt;/li&gt;
&lt;li&gt;و هر بار که بخواهیم عنصری از union را بخوانیم، ابتدا باید فیلد tag را چک کنیم تا بفهمیم کدام یک از عناصر union در آن لحظه فعال است.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;مثال: فرض کنید می‌خواهیم جوابی که یک سرور ممکن است برای ما ارسال کند را به شکل یک تایپ بیان کنیم. اما این سرور به چندین مدل مختلف به ما جواب خواهد داد؛ گاهی اوقات یک عدد را به عنوان Status Code برمی‌گرداند، و گاهی اوقات هم یک پیغام متنی را برای‌مان می‌فرستد. قصد داریم تایپی تعریف کنیم که بتواند با توجه به شرایط مختلف، هر دوی این حالات را پوشش دهد:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        
        &lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        
        &lt;span class=&#34;k&#34;&gt;union&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;statusCode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TaggedInfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    
    
    &lt;span class=&#34;n&#34;&gt;TaggedInfo&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;statusCode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;404&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;This is your status code: %d &lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;statusCode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;This is your message: %s &lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;در مثال بالا tag با تایپ short تعریف شده که یک تایپ عددی است. یعنی باید مقادیری مثل ۱ یا ۲ یا ۳ &amp;hellip; را به آن نسبت دهیم که بسیار شبهه برانگیز خواهد بود. برای این منظور، خیلی از برنامه‌نویسان C فیلد tag را به شکل یک enum تعریف می کنند تا کدهای‌شان معنی دار شود:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        
        &lt;span class=&#34;k&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;Data_StatusCode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;Data_Message&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    
        &lt;span class=&#34;k&#34;&gt;union&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;statusCode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TaggedInfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    
    
    &lt;span class=&#34;n&#34;&gt;TaggedInfo&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Data_StatusCode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;statusCode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;404&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Data_StatusCode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;This is your status code: %d &lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;statusCode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Data_Message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;This is your message: %s &lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;این راه حل در بین برنامه نویسان C تبدیل به یک «عُرف» شده است. به union هایی که با این روش تعریف می‌شود Tagged Union می‌گویند. اما با تمام این اوصاف، هنوز هم هیچ امنیتی در کار نیست؛ یعنی تایپ سیستم هیچ چیزی از این راه حل نمی‌داند و اشتباه برنامه‌نویس در سِت کردن درست و به موقع tag، می تواند کل برنامه را با خطا مواجه کند.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;تعریف Sum Type در زبان های مدرن&#34;&gt;&lt;/a&gt;&lt;a name=&#34;sum-types-in-modern-pl&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;تعریف-sum-type-در-زبان-های-مدرن&#34;&gt;تعریف Sum Type در زبان های مدرن&lt;/h2&gt;

&lt;p&gt;همه‌ی این توضیحات را دادم تا برسم به این:&lt;/p&gt;

&lt;p&gt;سام تایپ ها با Tagged Union قابل تعریف شدن هستند. حتی خیلی وقت‌ها اسم Sum Type مترادف با Tagged Union بیان می‌شود! همانطور که می‌بینید Tagged Union ها در زبان C نزدیک‌ترین چیزی هستند که شما می‌توانید در زبان‌های متداول‌تر برنامه‌نویسی داشته باشید.&lt;/p&gt;

&lt;p&gt;وقتی گفتیم زبان‌هایی مانند Haskell یا Rust یا Swift از سام تایپ ها پشتیبانی می کنند، در واقع داستان این است که همین Tagged Union هایی که اینجا دیدید را به طور سازمان یافته و با سینتکس ای مناسب در بطن تایپ سیستم خود پیاده سازی کرده اند.&lt;/p&gt;

&lt;p&gt;مثلا تایپ Info که در بالاتر تعریف کردیم، در Haskell به این شکل خواهد بود:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-haskell&#34; data-lang=&#34;haskell&#34;&gt;&lt;span class=&#34;kr&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Info&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Status&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Message&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;یا در Swift به این شکل خواهد بود:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Swift&#34; data-lang=&#34;Swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Info&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;یا در Rust به این شکل خواهد بود:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Rust&#34; data-lang=&#34;Rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Info&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;دقت کنید طراحان Rust و Swift برای تعریف سام تایپ ها از کلید واژه‌ی enum استفاده کرده اند؛ ولی این enum برابر با آن چیزی نیست که در C یا C++ یا Java می‌شناسید. enum در Rust و Swift در واقع مترادف با ورژنِ مدرن‌ترِ Tagged Union است!&lt;/p&gt;

&lt;p&gt;غالبا پیش از استفاده از سام تایپ‌ها، ابتدا نیاز پیدا خواهید کرد مقداری که در حال حاضر فعال است را شناسایی کنید. در زبان‌هایی مانند C این کار توسط if یا select یا switch انجام می‌پذیرد. و شما با توجه به اینکه کدام یکی از آن مقادیر فعال هستند، عکس العمل مناسب را نشان خواهید داد. (از روی فیلد tag)&lt;/p&gt;

&lt;p&gt;در زبان‌های برنامه نویسی مدرن‌تر و به خصوص زبان‌های فانکشنال، قابلیت «تطبیق الگو» یا Pattern Matching در زبان حضور دارد که شما را از هرچه if و switch و امثال‌شان است خلاص می‌کند و کدهایی تمیزتر و قابل فهم تر تولید می‌نماید. سام تایپ ها و مکانیزم تطبیق الگو، به نوعی لازم و ملزوم یکدیگر هستند.&lt;/p&gt;

&lt;p&gt;تا اینجای کار چون استفاده‌ی سام تایپ ها در دنیای واقعی را مشاهده نکرده‌اید، شاید هنوز قدرت سام تایپ ها را بدرستی درک نکرده باشید؛ در بخش بعد یک نمونه‌ی واقعی از سام تایپ ها را باهم مرور می‌کنیم&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;تایپ Option&#34;&gt;&lt;/a&gt;&lt;a name=&#34;option-type&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;تایپ-option&#34;&gt;تایپ Option&lt;/h2&gt;

&lt;p&gt;این تایپ از شناخته شده ترین و پرکاربرد ترین سام تایپ‌هایی است که در اکثر زبان‌های برنامه‌نویسی حضور دارد. در بعضی زبان‌ها اسمش Option است، در بعضی دیگر با اسم Optional شناخته می‌شود، و گاهی هم آن را Maybe صدا می‌زنند.&lt;/p&gt;

&lt;p&gt;شمایل این تایپ در زبان Swift اینگونه است:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Swift&#34; data-lang=&#34;Swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Optional&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;some&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;none&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;یا فرضا در زبان Rust اینگونه تعریف شده است:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Rust&#34; data-lang=&#34;Rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;pub&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;Option&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Some&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;تعریف بالا یعنی Option دو حالت را ارائه خواهد که در هر لحظه فقط یکی از حالات می‌تواند وجود داشته باشد:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;حالت None که یعنی هیچ چیزی وجود ندارد.&lt;/li&gt;
&lt;li&gt;حالت Some که یعنی یک مقدار که دارای تایپِ T است در دسترس است و توسط Some کپسوله شده است.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;حالا چنین چیزی در چه زمان‌هایی ممکن است بدرد بخورد؟ تایپ Option بیشتر برای هندل کردن خطاهایی که ممکن است به دلیل وجود یا عدم وجود یک داده اتفاق بیفتد کاربرد پیدا می‌کند. خیلی از مواقع توابعی دارید که در صورت موفقیت، مقدار مناسبی را بر‌میگردانند؛ و در صورت ناموفق بودن، ایجاد خطا خواهند کرد.&lt;/p&gt;

&lt;p&gt;مثلا تابعی دارید که دو عدد را به عنوان آرگومان می‌پذیرد، و نتیجه‌ی تقسیم آن دو عدد بر یکدیگر را برمیگرداند. خطایی که ممکن است پیش بیاید این است که اعداد بر صفر تقسیم نخواهند شد بنابراین پارامتر دوم نمی‌تواند صفر باشد. پس یکی از دو اتفاق زیر ممکن است در این تابع صورت بگیرد (و شما مطمئن نیستید کدام!):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;یا رقم دوم صفر خواهد بود. که در این صورت تابع خطا خواهد داشت.&lt;/li&gt;
&lt;li&gt;یا تقسیم بدون مشکل انجام می‌شود و نتیجه به درستی برگشت داده خواهد شد.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;حالا با این توضیحات، تایپ خروجی تابع را باید چگونه انتخاب کنیم؟ در حالت عادی، میتوانیم بگوییم که خروجی این تابع یک مقدار اعشاری است. اما می‌دانیم که همیشه اینطور نخواهد بود. این حس «مطمئن نبودن» را چگونه می‌خواهید برای تایپ سیستم توضیح دهید؟&lt;/p&gt;

&lt;p&gt;اینجاست که شما می‌توانید از تایپ Option استفاده کنید! یعنی تایپِ خروجی این تابع را از نوع Option انتخاب می‌کنید و با اینکار به کامپایلر می‌گویید که این تابع هم ممکن است خطا بدهد و هم ممکن است بدون ایراد کار کند. تعریف چنین تابعی در زبانی مثل Rust اینگونه است:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Rust&#34; data-lang=&#34;Rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;divide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;: &lt;span class=&#34;kt&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;: &lt;span class=&#34;kt&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nb&#34;&gt;Option&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;           &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// Fail, without panic!
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Some&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// Wrap division result in Some(), and return it.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;و در قسمت‌های دیگر کدهای خود می‌توانیم به این شکل از این تابع استفاده کنیم:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Rust&#34; data-lang=&#34;Rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;divide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;error: could not do this division!&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Some&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;result is: {}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;اگر تابع بالا را اجرا کنید، برنامه بدون اینکه وسط کار کرش کند، براحتی خطای صورت گرفته را متوجه می‌شود و توضیح مناسبی برای آن چاپ خواهد کرد.  ده‌ها مورد دیگر از این موارد وجود دارند که شما از وجود یک مقدار نهایی اطمینان کافی ندارید و می‌توانید با استفاده از تایپ Option خیال خود را از وقوع اتفاقات نامطلوب در چنین شرایطی راحت کنید.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;end&#34;&gt;&lt;/a&gt;&lt;a name=&#34;سخن آخر&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;سخن-آخر&#34;&gt;سخن آخر&lt;/h2&gt;

&lt;p&gt;دیتا تایپ‌های جبری، اساسی و جذاب هستند! وجود پشتیبانی مناسب از آن‌ها در یک زبان برنامه‌نویسی، می‌تواند امنیت کدهایتان را بسیار بالا ببرد. فرضا همین تایپ Option که بالاتر درباره‌اش توضیح دادیم، می‌تواند شما را از خطاهای مربوط به مقادیر null خلاص کند! در بین زبان‌های مختلف اشتیاق مناسبی برای پشتیبانی بهتر از این تایپ‌ها وجود دارد. فرضا جاوا ۸ همین تایپ Optional را به زبان اضافه کرد. یا مثلا TypeScript هم تا حدی دیتا تایپ‌های جبری را در ورژن ۲ به زبان اضافه کرده تا شما در  جاوا اسکریپت هم بتوانید به مزایای این تایپ‌ها دسترسی داشته باشد. از همین رو مطالعه‌ی دیتا تایپ‌های جبری برای تمام برنامه‌نویسان سودمند خواهد بود.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>شرکت شما، خانواده‌ی شما نیست</title>
      <link>https://amirrezaghaderi.com/fa/blog/not-family/</link>
      <pubDate>August 9, 2017</pubDate>
      <author>Amirreza Ghaderi</author>
      <guid>https://amirrezaghaderi.com/fa/blog/not-family/</guid>
      <description>

&lt;p&gt;اگر مقام‌های بالادستیِ تان مدام از این حرف می‌زنند که شما برایشان مثل یک «خانواده» هستید، حواس‌تان را خوب جمع کنید! وقتی آن‌ها می‌گویند شما مانند خانواده‌شان هستید، منظورشان این نیست که در هر شرایطی از شما حمایت خواهند کرد و بی هیچ چون و چرایی شما را دوست خواهند داشت (مانند کاری که یک «خانواده‌ی واقعی» انجام می‌دهد)، بلکه احتمالا انگیزه‌ی دیگری دارند: اینکه شما را راضی به از خودگذشتگی هایی کنند که به طور عادی در محیطی به غیر از محیط خانواده زیر بارشان نخواهید رفت!&lt;/p&gt;

&lt;p&gt;با ایجاد یک تصویر ساختگی از «خانواده»، ارزش تمام کارهای شما با چنین نگاهی بررسی خواهد شد. فرضا اگر شب‌ها تا دیر وقت کار کنید یا از تفریحات شخصی خود بزنید تا کار شرکت را جلو ببرید، چیز خاصی اتفاق نیفتاده است! چون شما دارید این کار را برای آن شرکت که مثل «خانواده» تان است انجام می‌دهید! القای این قبیل احساسات، برای این است که شخصی می‌خواهد منطق شما را تحت تاثیر قرار دهد تا شما دید احساسی به قضایا پیدا کنید.&lt;/p&gt;

&lt;p&gt;برای درست رفتار کردن یا مهربان بودن با دیگران، لازم نیست وانمود کنید که آن‌ها مثل خانواده‌ی شما هستند. اتفاقا برعکس، این قضایا با اتکا به اصول، سیاست ها، و از همه مهم‌تر اعمال واقعی، می‌توانند خیلی بهتر جلوه پیدا کنند.&lt;/p&gt;

&lt;p&gt;از این‌ها گذشته، آیا شما در خارج از محیط کاری، خانواده یا دوستان بسیار نزدیکی ندارید؟ یک شرکت امروزی، مانند آواره‌های خیابانی نیست که در خیابان دار و دسته‌ راه می‌اندازند تا در کنار یکدیگر خود را از دنیای سخت و سرد بیرون نجات دهند. خیر&amp;hellip; اینکه شرکتی بخواهد خودش را مثل خانواده‌ی شما جا بزند، در واقع در تلاش است که نیازهای این خانواده‌ی خودخوانده را (شرکت)، بالاتر از خانواده‌ی واقعی تان قرار دهد. و این شرم آور است.&lt;/p&gt;

&lt;p&gt;شرکت‌های خوب، خودشان را جای خانواده‌ی تان جا نمی‌زنند. شرکت‌های خوب پشتیبان خانواده‌ی شما خواهند بود؛ در کنار خانواده‌ی شما خواهند بود. آن‌ها با فراهم کردن محیطی سالم و مناسب، کاری می کنند که کارکنان‌شان وقتی به خانه رفتند، بتوانند برای خانواده‌های خودشان شوهر، همسر، والدین، یا فرزندان خوبی باشند.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;پ-ن&#34;&gt;پ.ن:&lt;/h3&gt;

&lt;p&gt;در هر جایی که مشغول به کار هستید، حواس‌تان باشد این تنها شما نیستید که نسبت به کار مسئولید! «کار» یه موضوع دو طرفه است. شما به عنوان کارمند، وظیفه دارید کارهایی که جزو شرح وظایف‌تان است را به بهترین شکل ممکن انجام دهید، و کارفرما نیز وظیفه دارد علاوه فراهم کردن یک محیط سالم، حقوق و مزایای شما را بدرستی تحویل‌تان دهد. هیچ وقت نگذارید با تحریک احساسات‌تان، بیش از اندازه از شما کار بکشند.&lt;/p&gt;

&lt;p&gt;سعی کنید همه چیز روی اصول و ضوابط باشد؛ کارِ بیشتر از طرف کارمند، باید مترادف با مزایای بیشتر از طرف کارفرما باشد. اگر چنین نبود، بدانید که کارفرما نیازهای شخصی خود را بالاتر از نیازهای شما قلمداد کرده و اینکه «ما همه مثل یک خانواده هستیم&amp;hellip;» تنها برای گول زدن شما برای انجام دادن خواسته‌هایش است.&lt;/p&gt;

&lt;p&gt;برگردان:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://m.signalvnoise.com/the-company-isnt-a-family-d24f26c3f3fe&#34;&gt;https://m.signalvnoise.com/the-company-isnt-a-family-d24f26c3f3fe&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;توجه: متن بالا، یک ترجمه نظیر به نظیر نیست. شخصا فکر می‌کنم حاصل ترجمه‌ی واژه به واژه جملات از زبانی به زبان دیگر، متنی بی روح خواهد شد.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>جامعه‌ی نرم‌افزارهای آزاد: از ما بهتران!</title>
      <link>https://amirrezaghaderi.com/fa/blog/fsfiran/</link>
      <pubDate>July 23, 2017</pubDate>
      <author>Amirreza Ghaderi</author>
      <guid>https://amirrezaghaderi.com/fa/blog/fsfiran/</guid>
      <description>

&lt;p&gt;اعتدال! چه واژه‌ی زیبایی؛ و چقدر پیچیده! پیچیده به این دلیل که حدس زدن مرز تعادل و میان‌روی، کار بسیار دشواری است. افرادی که «اعتدال» و «میانه‌رو» بودن را فراموش کرده‌اند و به «تندروی» گراییده‌اند، خودشان با دست خودشان زندانی برای افکار خود ساخته‌اند.&lt;/p&gt;

&lt;p&gt;من به اندازه‌ی کافی در جامعه‌ی نرم افزارهای آزاد ایران پرسه زده‌ام. با زیر و بم آن به قدر کافی آشنا هستم. همه نوع نظری را هم در آن شنیده‌ام. هم نظرات منطقی و قابل احترام، و هم نظراتی مانند این:&lt;/p&gt;

&lt;p&gt;«&amp;hellip;که کسانی که ویندوز کار می‌کنند یا محصولات اپل می خرند خنگ هستند. احمق هستند. جامعه برایشان مهم نیست. دزد هستند!&amp;hellip;» و نظرات بسیاری از این قبیل&amp;hellip; متاسفانه اغلب این نظرها را از دهان افرادی شنیدم که بسیار در جامعه‌ی نرم افزارهای آزاد ایران فعال هستند&amp;hellip;&lt;/p&gt;

&lt;p&gt;راستش را بخواهید، این قضایا دور از ذهن نیست&amp;hellip; چرا؟ فرضا، این چیزی بود که ریچارد استالمن درباره استیو جابز نوشت:&lt;/p&gt;

&lt;p&gt;«&amp;hellip;استیو جابز، پیشگام در ساخت کامپیوتر‌های جالب ولی زندان مانند، که آزادی را از احمق‌هایی که خواهان‌شان بودند می‌گرفت، درگذشت.
یاد شهردار شیگاگو  «هارولد واشنگتن» می‌افتم که درباره شهردار فاسد قبلی گفته بود: خوشحال نیستم که او مرده، ولی خوشحالم که دیگر زنده نیست&amp;hellip;»&lt;/p&gt;

&lt;p&gt;می‌دانید حرف بالا را در چه زمانی منتشر کرد؟ درست بعد از مرگ استیو جابز! زمانی که حتی بزرگ ترین رقبای جابز هم در حال تسلیت گفتن به خانواده اش بودند! وقتی رهبر یک جنبش چنین رفتاری دارد، چه انتظاری از دنباله رو هایش باید داشت؟&lt;/p&gt;

&lt;p&gt;میدانم&amp;hellip; ایده‌ی وجود نرم افزار‌های آزاد، ایده‌ی زیبایی است. اما دنیای واقعی همیشه آنقدر زیبا نیست!&lt;/p&gt;

&lt;p&gt;وقتی در خانه پدر و مادرتان با شلوارک زیر کولر نشسته‌اید، حرف زدن از آزادی نرم افزار برایتان خیلی راحت خواهد بود!
اما وقتی مسئول یک شرکت چند ملیتی هستید (که هر ملیت هم قوانین خاص خود را دارند)، و چشم هزاران نفر کارمند و خانواده‌هایشان به شماست، آن موقع قضیه خیلی فرق خواهد کرد!&lt;/p&gt;

&lt;p&gt;پشت لپ‌تاپ می‌نشینید و چهار تا توییت راجع به آزادی نرم افزار می‌نویسید و در خیال خود فکر می‌کنید مرزهای تکنولوژی را جا به جا کرده‌اید؛ اما هیچ کدام از کمپانی‌های کامپیوتری را نمی‌بینید که با سرمایه‌گذاری‌های عظیمِ مالی و انسانی چگونه دست به تولید نرم افزارهای آزاد می‌زنند.&lt;/p&gt;

&lt;p&gt;ممکن است بگویید آن‌ها برای سود خودشان چنین کاری می‌کنند؛ همین حرف خودش جای بحث دارد، ولی فرض را بر این بگذاریم که این حرف درست باشد، آیا ایرادی دارد اگر در قبال خدمتی که می‌کنند سودی حاصل شان شود؟ هر کسی که نرم افزار آزاد تولید می‌کند (یا کلا هر محصولی را با زحمت به سرانجام می‌رساند) قرار است به نوعی از آن سود ببرد:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;یکی نرم افزار آزاد تولید می‌کند تا برای خود در جامعه احترام بدست بیاورد و رزومه‌ی چرب تری داشته باشد. مواردی که شانس استخدام را در شرکت‌های بزرگ بالا می‌برد.&lt;/li&gt;
&lt;li&gt;یکی نرم افزار آزاد تولید می کند تا قسمتی از توسعه‌ی آن بدست عموم انجام پذیرد و در هزینه‌های داخلی شرکت صرفه جویی کند (یکی از دلایل اصلی تولید نرم افزارهای آزاد توسط کمپانی‌های بزرگ)&lt;/li&gt;
&lt;li&gt;یکی نرم افزاد آزاد تولید می‌کند تا آن بفروشد یا با ارائه‌ی پشتیبانی برای آن سودی به جیب بزند&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;هیچکس در زندگی کاری انجام نخواهد داد اگر بداند که هیچ سودی برایش ندارد! شما حتی نوشیدن یک لیوان آب را هم به دلیل فایده‌هایی که برای بدن تان دارد انجام می دهید. پس همه در این میان فکر سود و ضرر خود هستند. حتی خود fsf هم تاکید زیادی می‌کند بر اینکه آزادی نرم افزار ربطی به مباحث مالی ندارد و شما آزاد هستید از نرم افزارهای آزاد کسب درآمد کنید. ولی باز هم خیلی از طرفداران این جنبش وقتی یک کمپانی بزرگ، نرم افزار آزادی را تولید می‌کند، می‌گویند حتما برایش سودی داشته و به فکر منفعت خودش بوده است&amp;hellip;. خوب معلوم است که برایش سودی داشته! مگر می‌شود غیر از این باشد؟ چطور است که خود fsf با این قضیه مشکلی ندارد ولی شما کاسه داغ تر از آش می‌شوید؟&lt;/p&gt;

&lt;p&gt;حرف زدن خیلی آسان است. و آرمان‌گرایی حس خوبی دارد. مخصوصا وقتی مسئولیت خاصی در زندگی ندارید! اغلب افرادی که موقع حرف زدن از نرم افزارهای آزاد رگ گردن‌شان باد می‌کرد (که یکی از نمونه‌هایش خودم بودم)، کم کم وقتی بزرگ شدند و با خرج خانه و زندگی و همسر و فرزندان و بدهکاری و وام بانک مواجه شدند، نظرات‌شان کمی عوض شد!&lt;/p&gt;

&lt;p&gt;فکر می‌کنم تنها دلیل این موضوع، مواجه شدن با دنیای واقعی بوده است. دنیایی که در آن مسئولیت هایی زیادی به گردنشان است و با کمال گرایی راه به جایی نخواهند برد. دنیایی که در آن ممکن است بگویند گور پدر نرم افزار آزاد، شهریه مدرسه‌ی بچه‌ام را چکار کنم؟ دنیایی که در آن اولویت‌های زندگی شام فردا شب و قبض برق است، و نه آزاد بودن یا نبودن یک برنامه‌ی کامپیوتری!&lt;/p&gt;

&lt;p&gt;خنده ام می‌گیرد از افرادی که کار روز و شب شان این است که در شبکه‌های اجتماعی به شما گیر بدهند که نگویید لینوکس، بگویید گنو/لینوکس!&lt;/p&gt;

&lt;p&gt;وقتی از توروالدز درباره اسم «گنو/لینوکس» سوال می‌شود، این جوابی است که می‌دهد:
«این اسم برحق خواهد بود اگر گنو خودش یک توزیع از لینوکس را بسازد. همانطور که اسم‌هایی مانند «ردهت لینوکس»، «سوزی لینوکس» یا «دبیان لینوکس» درست هستند. اگر شما توزیعی از لینوکس را بسازید، حق دارید که اسم دلخواه‌تان را روی آن بگذارید؛ ولی مسخره است اگر فکر کنید باید کلا همه جا «گنو/لینوکس» خطاب‌اش کنید.»&lt;/p&gt;

&lt;p&gt;من هم با تورولدز هم نظر هستم؛ «گنو/لینوکس» خطاب کردن چنین سیستم‌ای به نظر مسخره است! به چه دلیلی باید مردم با چنین نامی آن را صدا کنند؟ فقط چون قسمتی از سیستم را پروژه گنو توسعه داده است؟ فکر میکنید این قسمت دقیقا چقدر بزرگ است؟ بخش‌هایی از یک توزیع لینوکس که توسط پروژه گنو توسعه داده شده بیشتر شامل جعبه ابزار کامپایلر و کتابخانه‌های وابسته به آن، و برنامه‌های پایه‌ای ترمینال است. بقیه قسمت‌ها اصلا توسط گنو توسعه داده نشده اند.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;مرورگرهای وب مثل فایرفاکس یا کروم&lt;/li&gt;
&lt;li&gt;مدیا پلیر‌ها معروف مثل VLC&lt;/li&gt;
&lt;li&gt;اغلب تکست ادیتورها و آی‌دی‌ای‌های معروف (به غیر از ایمکس)،&lt;/li&gt;
&lt;li&gt;اغلب زبان‌های برنامه‌نویسی (جاوا، پایتون، روبی و &amp;hellip;)&lt;/li&gt;
&lt;li&gt;اغلب برنامه‌های ایمیل&lt;/li&gt;
&lt;li&gt;میز کارهایی مانند کی‌دی‌ای، Xfce&lt;/li&gt;
&lt;li&gt;اغلب درایورهای سخت افزاری&lt;/li&gt;
&lt;li&gt;و این لیست ادامه دارد&amp;hellip;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;هیچ کدام از موارد بالا توسط گنو توسعه داده نشده‌اند. حتی امروزه گنوم نیز تحت یک بنیاد جداگانه و با حمایت کمپانی‌های بزرگ نرم‌افزاری در حال توسعه است. درست است که قسمت‌های توسعه داده شده توسط گنو مهم و حیاتی هستند، ولی آیا بقیه قسمت‌ها بدردنخور و بی فایده هستند؟ یک سیستم عامل ترکیبی از تمام این پروژه‌ها و نرم افزارهاست. بنابر دیدگاه گنو، پس بقیه پروژه‌ها هم باید بیایند و ادعا کنند که چرا اسمشان روی لینوکس نیست؟&lt;/p&gt;

&lt;p&gt;کل این قضیه واقعا بچه‌گانه است که تمام جوانب منطقی و تکنیکال را رها کنیم و به جایش به مردم گیر بدهیم که نگویید لینوکس، بگویید گنو/لینوکس&amp;hellip; اینقدر ظاهر یک موضوع برایتان مهم است؟  آیا مشکل موی جوانان ماست؟ اینکه اسم اش چه صدا کنید؟ تازه آن هم اسمی که به غیر از طرفداران گنو کس دیگری آن را به رسمیت نمی‌شناسد؟ به نظرم چنین چیزی جدا شدن از اصل، و چسبیدن به فرع است!&lt;/p&gt;

&lt;p&gt;چیزی که آن‌ها درک نمی‌کنند این است که نرم افزارهای آزاد قبل از پروژه‌ی گنو نیز وجود داشته‌اند. یادم هست کن تامپسون در یک مصاحبه می‌گفت ما آن قدیم‌ها اصلا مجوز برای‌مان مهم نبود. همینطور کدها رو می‌نوشتیم و هرکس که دلش می خواست آزادانه از آن‌ها استفاده می‌کرد. حتی بعضی از مجوز‌های آزاد، قبل از انتشار GPL منتشر شده بودند. به عبارتی، پروژه گنو «شروع کننده» چیزی نبوده است!&lt;/p&gt;

&lt;p&gt;تنها کاری که پروژه گنو انجام داده این است که در یک حرکت سیستماتیک و جامع، نظرات و تفکرات خود را مبنی بر اینکه «نرم افزار آزاد باید چگونه باشد» را اعلام کرده و با دنبال کردن آن به شکل عملی، این تفکرات را پیاده سازی کرده و برایش تبلیغ می کند. تفکراتی که اتفاقا همه با آن موافق نیستند. یعنی همه بر این قضیه توافق ندارند که نرم افزار آزاد، همان چیزی است که fsf می‌گوید! تفکرات مختلفی راجع به نرم افزارهای آزاد وجود دارد.&lt;/p&gt;

&lt;p&gt;در سال ۲۰۱۵، گیت‌هاب یک گزارش از مجوزهای مختلف منتشر کرد. طبق این گزارش مجوزهایی مانند MIT و Apache و BSD و بقیه روی هم بیش از ۷۵٪ از مجوزهای آزاد را تشکیل داده بودند. در حالی که سهم GPL2 دوازده درصد و سهم GPL3 تنها ۸ درصد بوده است. یعنی خیلی از افرادی که نرم افزار آزاد تولید می‌کنند، مشخصا با دیدگاه گنو هم نظر نیستند و ترجیح داده‌اند کدهای‌شان را با مجوزهای دیگری منتشر کنند. حتی توروالدز بارها اعلام کرده که لینوکس یا هیچ نرم افزار دیگری که بسازد را با مجوز GPL3 منتشر نخواهد کرد (برای نمونه، گیت).&lt;/p&gt;

&lt;p&gt;چیزی که باید مشخصا در این نوشته به آن اشاره کنم، این است که من شخصا از طرفداران پر و پا قرص نرم افزارهای آزاد هستم. همچنین احترام بسیار زیادی برای بنیاد FSF قائل هستم. لباسی که الآن بر تن من است، هزینه‌ی آن به کمک نرم افزارهای آزاد  بدست آمده! مشکل من، طرفداران این جنبش است که به تندروی کشیده شده اند. کل این قضایا، من را یاد دیکتاتوری‌های کمونیستی می‌اندازد. اینکه عده‌ای یک ایدئولوژی داشته باشند، و بخواهد به زور همه را مجبور به موافقت با آن کنند. اینکه بخواهند همه را یکسان و یکپارچه نمایند؛ و هر کسی که مخالفت کرد، یا احمق است یا خائن است یا دزد&amp;hellip;&lt;/p&gt;

&lt;p&gt;اینکه شرکت‌های بزرگ کامپیوتری را دزد خطاب کنیم. شرکت‌هایی که کاری بیشتر از دریافت سود در قبال خدمات شان انجام نمی‌دهند. شرکت هایی که به جرات می‌توان گفت جزو سالم ترین بیزنس‌ها در تاریخ جوامع انسانی هستند! تنها کافیست مقایسه‌شان کنید با شرکت‌های بزرگ نفتی، داروسازی، خودروسازی، ورزش و شرط‌بندی، صنایع غذایی&amp;hellip; تا پی ببرید که شرکت‌های کامپیوتری تا چه حد سالم هستند. واقعا کوته فکرانه است که فقط به صرف اینکه درآمد خوبی دارند، آن‌ها را دزد خطاب کنیم.&lt;/p&gt;

&lt;p&gt;واقعیتی را باید قبول کرد؛ همه انسان ‌ها یک شکل فکر نمی‌کنند. همه‌ی برنامه‌نویس‌ها هم ایده‌های یکسانی ندارند. تفاوت ایده‌ها، به خاطر حماقت یا خیانت نیست. دوست ندارید از محصولات اپل استفاده کنید؟ ایرادی ندارد، انتخاب‌تان مورد احترام است. ولی کسانی که آن‌ها را می‌خرند را دزد و احمق خطاب نکنید&amp;hellip; دوست ندارید در اینستاگرام عضو شوید، ایرادی ندارد&amp;hellip; ولی کسانی که عضو هستند را خائن آزادی خطاب نکنید. اینقدر زور نزنید که ایده‌ی خود را تحمیل کنید. همه قرار نیست با شما موافق باشند.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;in-red&#34;&gt;
در نهایت نتیجه‌ای که به آن رسیدم این است که تندروهای این جنبش، آنقدرها که خودشان فکر می‌کنند نرم افزارهای آزاد برای‌شان مهم نیست. مهم تر از آن، «حس»ای است که به آن‌ها دست می‌دهد! این حس که در یک جایگاه اجتماعی خاصی هستند! اینکه از بقیه بیشتر می‌فهمند! اینکه عضو یک اقیلیت خاص هستند! و هر کس هم با آن‌ها مخالفت کند دلیلش این نیست که شاید نظرش متفاوت باشد&amp;hellip; نه&amp;hellip; آنهایی که مخالفت می‌کنند قطعا احمق و کوته فکر هستند&amp;hellip; و ما از آن‌ها بالاتریم! از آن‌ها بهتریم!
&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&#34;سخن-آخر&#34;&gt;سخن آخر&lt;/h2&gt;

&lt;p&gt;هیچ ایده‌ای را تا بینهایت دنبال نکنید. هیچ رهبر، یا کلا هیچ شخصی را آنقدر برای خود بالا نبرید. بدانید که آرمان‌گرایی در این دنیای پیچیده جایی ندارد و باید آماده‌ی تنوع افکار و عقاید باشید.&lt;/p&gt;

&lt;p&gt;با شکم برآمده، روحیه ای پر از استرس و تنها، تا ۳ صبح پشت یک صندلی نشسته ایم و کد می‌زنیم و فکر می‌کنیم که شق القمر کرده‌ایم. حرفه‌ی ما تنها یکی از هزاران حرفه‌ایست که روزانه در دنیا پیگیری می‌شود. خود بزرگ بین نباشید. نقش شما در این کره‌ی خاکی بسیار کوچک‌تر از آنی است که فکر می‌کنید. اینقدر حرس و جوش نزنید!&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;پی نوشت:&lt;/p&gt;

&lt;p&gt;قبل از نوشتن این مطلب، میدانستم که برخورد تندی با آن خواهد شد. چه در قالب کامنت، و چه در شبکه‌های اجتماعی. از دوستان عزیز خواهش میکنم قبل از ارسال بازخورد، به مباحث زیر توجه کنن:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;اینکه آقا استالمن درست بعد از مرگ استیو جابز چنین حرفی زده، تقصیر من نیست. ایشون واقعا گفته این هارو.&lt;/li&gt;
&lt;li&gt;اینکه توروالدز نظرش راجع به واژه گنو/لینوکس چی هست تقصیر من نیست.&lt;/li&gt;
&lt;li&gt;اینکه من میگم بقیه نرم افزارها هم به اندازه گنو در یک توزیع لینوکس سهیم هستن، از روی هوا نیست. فقط اندازه کد بیس کروم و فایرفاکس رو شما در نظر بگیر&amp;hellip;&lt;/li&gt;
&lt;li&gt;اینکه توروالدز میگوید که نمی خواهد هیچ برنامه ای رو با مجوز GPL3 منتشر کند بازهم تقصیر من نیست.&lt;/li&gt;
&lt;li&gt;اینکه گیت هاب، به عنوان بزرگ ترین مرکز نرم افزارهای آزاد میاد میگه سهم مجوزهای گنو نسبت به بقیه خیلی پایین تره به من ربطی نداره.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;این حرف ها همه واقعا گفته شده. این نظرات اعلام شده. این آمار و ارقام به شکل عمومی در دسترس هست. هیچکدام اون ها رو بدون فکت یا مدرک بیان نکردم. اینکه  ممکنه این مدارک موافق نظر شما نباشه، اون بحث دیگری دارد. اما خواهشا قبل از نوشتن بازخورد، به این مباحث هم توجه کنید.&lt;/p&gt;

&lt;p&gt;من هم مثل شما طرفدار نرم افزارهای آزاد هستم، فقط ممکن است نقطه نظراتم در اینباره با شما متفاوت باشد. من وقتی به نرم افزار آزاد فکر میکنم، در ذهنم چیزهایی مثل MIT یا BSD تداعی میشود که آزادی های بیشتری به نسبت مجوزهای گنو در اختیار افراد میگذارند. گنو برای حفظ و پایداری آزادی، مجبور است محدودیت هایی اعمال کند. من فکر میکنم اعمال این مدل محدودیت ها &amp;ndash; هر چند با هدف مثبت &amp;ndash; خودش نوعی سلب آزادی و انتخاب از افراد است.&lt;/p&gt;

&lt;p&gt;این‌ها زاویه دیدهای متفاوت نسبت به یک موضوع واحد هستند. هیچ اشکالی ندارد که افراد نظرات مختلف داشته باشند. همچنین من در نوشته‌ی بالا از هیچ شرکت یا کمپانی بخصوصی نه طرفداری کردم و نه بر ضد شون صحبت کردم. سیاست های هر کمپانی به خودش مربوط هست. من مثل بقیه با یک سری از سیاست هاشون مخالف هستم و یک سری دیگر موافق. من فقط یک مشتری هستم، در جایگاهی نیستم که برای کمپانی های بزرگ تعیین و تکلیف کنم. اگر از محصولاتشان خوشم نیاید، آن ها را نمیخرم. به همین راحتی.&lt;/p&gt;

&lt;p&gt;بنابراین قبل از نوشتن چیزی، از روی پشت صندلی بلند بشید، یک لیوان آب بنوشید، یک مقداری هوا بخورید، و بعد که کمی عصبانیت تان (!) فروکش کرد بازخورد خود را بنویسید.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>نبود قابلیت‌های مختلف در گولنگ: جنریک</title>
      <link>https://amirrezaghaderi.com/fa/blog/golang-generics/</link>
      <pubDate>July 12, 2017</pubDate>
      <author>Amirreza Ghaderi</author>
      <guid>https://amirrezaghaderi.com/fa/blog/golang-generics/</guid>
      <description>

&lt;p&gt;&lt;a name=&#34;toc&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;فهرست-مطالب&#34;&gt;فهرست مطالب&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#prereq&#34;&gt;مطالب پیش‌نیاز&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#intro&#34;&gt;مقدمه&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#q-go-nogen&#34;&gt;گولنگ جنریک ندارد؟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#golang-philosophy&#34;&gt;فلسفه‌ی گولنگ چیست؟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#golang-generics&#34;&gt;دست یابی به جنریک در گولنگ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#q-golang-lessgen&#34;&gt;چرا در گولنگ نیاز به جنریک کمتر حس می‌شود؟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#golang-generic-box&#34;&gt;پیاده‌سازی جنریک‌ها در گولنگ: بسته‌بندی و بسته‌گُشایی&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#golang-generation&#34;&gt;پیاده‌سازی جنریک‌ها در گولنگ: تولید کد&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#end&#34;&gt;سخن آخر&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;prereq&#34;&gt;&lt;/a&gt;
&lt;strong&gt;مطالب پیش نیاز&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;قبل از خواندن این نوشته، بهتر است با جنریک و شیوه‌های مختلفی که دیگر زبان‌ها آن را پیاده‌سازی کرده اند آشنا باشید. می‌توانید برای مطالعه‌ در اینباره به زبان فارسی وارد لینک‌ زیر شوید:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://amirrezaghaderi.ir/post/generics&#34;&gt;شیوه‌های مختلف پیاده سازی جنریک در زبان‌ها&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;intro&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;مقدمه&#34;&gt;مقدمه&lt;/h2&gt;

&lt;p&gt;بعضی اوقات ما به شکل خواسته یا ناخواسته، برای خودمان یک سری «چارچوب فکری» طراحی می کنیم و بی‌دلیل روی این چارچوب‌ها اصرار می‌ورزیم. این طور فکر می‌کنیم که «راه درست» فقط همانی است که در چارچوب فکری ما وجود دارد. اما واقعا نمی دانیم این ادعا را بر چه مبنایی مطرح می‌کنیم! چرا این راه، تنها راه درست است؟ چه کسی این را گفته؟ این موضوع از کجا ثابت شده؟&lt;/p&gt;

&lt;p&gt;در آخر متوجه می‌شویم تنها چیزی که ذهن ما را به روی آلترناتیو‌های دیگر بسته، فقط خودمان هستیم و آن چارچوب‌های کذایی!&lt;/p&gt;

&lt;p&gt;موضوع ساده است:&lt;/p&gt;

&lt;p&gt;یک سری مشکل یا  مساله وجود دارد؛ و برای هر کدام هم یک سری راه حل. ممکن است یک راه حل آسان‌تر باشد، و آن یکی سخت‌تر. یکی ساده تر باشد، و آن یکی پیچیده‌تر. خیلی هم کم پیش می‌آید که راه حل‌ها بدون نقص باشند؛ ما هم به تبع با بکار گرفتن یک راه حل، باید با نقاط ضعف آن نیز کنار بیاییم.&lt;/p&gt;

&lt;p&gt;زبان‌های برنامه‌نویسی و ابزارهای پیرامون آن هیچ کدام بدون نقص و کاستی نیستند؛ این «ما» هستیم که باید با خود بیاندیشیم آیا می‌توانیم با این کاستی‌ها کنار بیاییم یا خیر. به عبارتی،
&lt;span class=&#34;in-red&#34;&gt;
زبان برنامه‌نویسی محبوب یک فرد، در واقع زبانی است که آن فرد توانسته با نقص‌هایش کنار بیاید!
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;در این میان باید توجه کنیم که بسته به تفکرات مختلف، یک «نقص» ممکن است به عنوان یک «مزیت» مطرح شود، و یک مزیت به عنوان یک نقص!&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;q-go-nogen&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;گولنگ-جنریک-ندارد&#34;&gt;گولنگ جنریک ندارد؟&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;«چجوری با گولنگ که جنریک نداره برنامه نویسی میکنید؟ میشه مگه؟»&lt;/li&gt;
&lt;li&gt;«تا زمانی که گولنگ جنریک رو اضافه نکنه من حتی بهش فکر هم نمیکنم&amp;hellip; اینم شد زبان آخه؟»&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;هر بار که این حرف ها را می‌شنوم (که دفعات اش کم هم نیست!)، فورا افکار زیر از ذهنم عبور می‌کند:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;یا طرف اصلا نمی‌داند جنریک چیست! یعنی اگر از او سوال کنی، نمی‌تواند جنریک را بدرستی شرح دهد.&lt;/li&gt;
&lt;li&gt;یا طرف نمی‌داند جنریک در پشت صحنه چگونه پیاده سازی می‌شود، و قیمتی که زبان‌ها برای این پیاده سازی باید پرداخت کنند در چه حدی است.&lt;/li&gt;
&lt;li&gt;یا طرف وقتی می‌گوید جنریک لازم دارد، منظورش این نیست که خودش قرار است چیزی با آن بسازد. در حقیقت فقط با کتابخانه‌هایی که بقیه با جنریک ساخته‌اند کار میکند. یعنی تولید کننده نیست، فقط مصرف کننده است.&lt;/li&gt;
&lt;li&gt;یا طرف کلا با گولنگ آشنا نیست و همینطور حرفی را از جایی شنیده و تکرار می‌کند.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;در این نوشته برای‌تان شرح می دهم که چرا در مقابل آن سخن‌ها، چنین افکاری به ذهنم خطور می‌کند. همچنین برای‌تان توضیح میدهم چرا گولنگ جنریک ندارد، و چرا با اینکه جنریک ندارد هر روز محبوب تر از دیروز می‌شود و این همه آدم  براحتی در حال کدنویسی با آن هستند.&lt;/p&gt;

&lt;p&gt;برای اینکه درباره قابلیت‌های یک زبان بحث کنیم، اول باید به دو نکته توجه کنیم:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;چرا فلان قابلیت، در فلان زبان حضور دارد.&lt;/li&gt;
&lt;li&gt;چرا فلان قابلیت، در فلان زبان حضور ندارد!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;طراحان زبان وقتی قابلیت ای را به زبان اضافه می‌کنند، اصولا به این خاطر است که با «یک سری مشکلات» مواجه شده‌اند، و  آن قابلیت احتمالا راه گشای این مشکلات است.&lt;/p&gt;

&lt;p&gt;وقتی هم تصمیم میگیرند قابلیت ای را به زبان اضافه نکنن، اصولا به این خاطر است که میخواسته‌اند از به وجود اومدن «یک سری مشکلات» جلوگیری کنند! گاهی قابلیت‌های مختلف یک زبان، خودشان باعث بروز مشکلات جدیدی در دراز مدت خواهند شد که طراحان مجبورند برای حل این مشکلات جدید، باز یک سری قابلیت‌های جدید به زبان اضافه کنند! و این قضیه ممکن است به صورت زنجیره وار ادامه پیدا کند!&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;in-red&#34;&gt;
در جامعه‌ی گولنگ، همه می‌دانند که «مهم‌ترین قابلیت گولنگ این است، که خیلی از قابلیت‌ها را ندارد!».
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;بعد از مدتی کار با گولنگ، به خاطر این قضیه شکرگذار خواهید بود! گولنگ همانند C، یک زبان خاتمه یافته است! (دقت کنید گولنگ را همان افرادی ساخته‌اند که C را سال‌ها پیش ساخته بودند!) یعنی مثل زبان‌های دیگر نیست که در هر نسخه‌ی جدیدشان چندین قابلیت جدید را به زبان اضافه می‌کنند. دلیلش این بوده که برنامه نویسان بتوانند یکبار زبان را یاد بگیرند و بعدش بچسبند به کار؛ نه اینکه هر چند ماه یکبار مجبور باشد کلی قابلیت جدید را یاد بگیرند!&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;in-red&#34;&gt;
گولنگ بر خلاف زبان‌های هم دوره‌اش، یک زبان «مدرن» &lt;strong&gt;نیست&lt;/strong&gt;! اکثر ایده‌های موجود در زبان بیش از سی سال از عمرشان می‌گذرد. گولنگ یک زبان «باحال» &lt;strong&gt;نیست&lt;/strong&gt;! گولنگ برای افرادی است که دیگر «زرق و برق» زبان‌های مختلف چشم‌شان را نمی‌گیرد و فقط دوست دارند یک کد ساده، پایدار، و بهینه بنویسند و بروند خانه! گولنگ آن کُنده ایست که از آن دود بلند می‌شود. گولنگ، برای برنامه‌نویسان «دل سوخته» است!
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;اگر زبانی مانند جاوا یک قابلیت بخصوص را نداشته باشد، ممکن است بگوییم به دلیل حساسیت بالایی که این زبان به مساله Backward compatibility دارد این حالت اتفاق افتاده است. یعنی شاید وارد کردن آن قابلیت برای کدهای پیشین مشکل زا شود. اگر زبانی مانند جاوااسکریپت قابلتی را نداشته باشد، ممکن است بگوییم که این زبان از ابتدا برای کارهای کوچک (در حد کدهای ۵۰-۶۰ خطی) ساخته شده بود و طراحی آن از پایه به گونه ای بود که اضافه کردن قابلیت‌ها به آن سخت‌تر باشد. در مورد گولنگ وضع چگونه است؟ فرضا آیا  نبود قابلیت‌ها در آن به خاطر Backward compatibility است یا طراحی نامناسب آن؟&lt;/p&gt;

&lt;p&gt;گولنگ را این افراد طراحی کرده‌اند: Robert Griesemer, Rob Pike, Ken Thompson. اگر این افراد را نمی‌شناسید، مانند این است که فوتبالیست باشید ولی مسی و رونالدو را نشناسید! اگر هم این افراد را می‌شناسید، احتمالا می‌دانید که این اسامی در چه حد «سنگین» هستند! بنابراین این گزینه که نبود قابلیت‌ها در گولنگ ممکن است به دلیل سازندگان ناشایست و کارنابلد اش باشد خط خواهد خورد&amp;hellip;&lt;/p&gt;

&lt;p&gt;این افراد گولنگ را با این هدف طراحی کرده‌اند: زبانی ساده و بهینه، مناسب برای پروژه‌ها و تیم‌های بسیار بزرگ (در ابعاد گوگل)، و دارای فرآیند کامپایل سریع. پس این گزینه که نبود قابلیت‌ها در گولنگ ممکن است به این دلیل باشد که هدف زبان، کارهای کوچک و پیش پا افتاده بوده نیز برقرار نیست&amp;hellip;&lt;/p&gt;

&lt;p&gt;اولین نسخه‌ی پایدار گولنگ در سال ۲۰۱۲ منتشر شد. یعنی گولنگ یک زبان جوان است. طراحان، این زبان را از صفر طراحی کرده اند و اصلا نیاز نداشتند که نگران قضیه Backward compatibility باشند. پس این قضیه نیز نمی‌تواند دلیل نبودن یک سری از قابلیت‌ها در گولنگ باشد&amp;hellip;&lt;/p&gt;

&lt;p&gt;پس براستی دلیل اینکه گولنگ یک سری قابلیت‌ها را در زبان قرار نداده چیست؟&lt;/p&gt;

&lt;p&gt;جواب در دو کلمه خلاصه می‌شود: «فلسفه‌ی گولنگ»!&lt;/p&gt;

&lt;p&gt;هر زبانی، برای خودش فلسفه‌ای دارد. مثلا فلسفه‌ی ارلنگ این است که روی پیشگیری از به وجود آمدن خطاها حساس نشوید، بگذارید برنامه کرش کند! اگر کسی این را بشنود، ممکن است در اول کار این زبان را مسخره کند. ولی اگر بیشتر زبان را مطالعه کند و بیشتر آن را در کار واقعی استفاده نماید، قطعا متوجه خواهد شد که چقدر اشتباه فکر می‌کرده است.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;golang-philosophy&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;فلسفه-ی-گولنگ-چیست&#34;&gt;فلسفه‌ی گولنگ چیست؟&lt;/h3&gt;

&lt;p&gt;«سادگی تا سرحد امکان!».&lt;/p&gt;

&lt;p&gt;این فلسفه مختص گولنگ نیست؛ کن تامپسون و همکاران قدیمی‌اش در آزمایشگاه‌های Bell ، از سال‌های دور به اصرار روی این فلسفه شهرت دارند. در این فلسفه، سادگی بالاترین هدف است. حتی اگر این سادگی باعث شود کارها کمی سخت‌تر یا کمی کندتر پیش برود. این فلسفه به «مدل توسعه‌ی نیوجرسی» شهرت دارد. (شهری که پایگاه Bell است).&lt;/p&gt;

&lt;p&gt;درباره این نوع نگاه به توسعه‌ی نرم‌‌افزار، کتاب‌ها و مقالات و مصاحبه‌های زیادی وجود دارد. می‌توانید عبارت Worse is better را در گوگل جستجو نمایید و لینک ها را از بالا به پایین مطالعه کنید.&lt;/p&gt;

&lt;p&gt;گولنگ به جای اینکه یک سری از قابلیت‌ها را اضافه کند تا چاره‌ی یک سری از مشکلات شوند، کلا خیلی از قابلیت‌ها را ارائه نمی کند تا از به وجود آمدن خیل عظیمی از مشکلات پیشگری نمایید! یعنی دقیقا برعکس رویه‌ای که اکثر زبان‌های برنامه‌نویسی پیش گرفته‌اند.&lt;/p&gt;

&lt;p&gt;خیلی از زبان‌ها هستند که ادعا میکنند ساده‌اند. تمام آن‌ها در مقابل گولنگ مانند مقایسه یک برج صد طبقه با خانه‌ای یک خوابه هستند! وقتی گولنگ از سادگی حرف می‌زند، واقعا منظورش فراتر از چیزیست که بقیه زبان‌ها فکر می‌کنند.&lt;/p&gt;

&lt;p&gt;«&amp;hellip; پارسال به کنفرانسی رفتم&amp;hellip; سخنرانی‌های زیادی در آنجا دیدم&amp;hellip; خیلی از سخنرانی ها از طرف رهبران زبان‌های دیگر بود&amp;hellip;جاوا اسکریپت، پی‌اچ‌چی، سی شارپ&amp;hellip; درباره نسخه‌ی جدید زبان‌هایشان حرف می‌زدند&amp;hellip; چیزی که بیشتر از همه توجه من را جلب کرد این بود که بخش بزرگی از سخرانی‌شان درباره قابلیت‌هایی بود که از دیگر زبان‌ها برداشته بودند و در این نسخه‌ی جدید به زبان خودشان اضافه کرده بودند&amp;hellip;به این فکر کردم که این زبان‌ها اینقدر شبیه هم شده‌اند که می توان آن‌ها را در قالب یک زبان تصور کرد&amp;hellip;» &amp;ndash; &lt;em&gt;راب پایک&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;از نظر من حرف بالا واقعا درست است. زبان‌های دیگر آنقدر در اضافه کردن قابلیت‌های جدید عطش دارند که در هر نسخه‌ی جدیدشان کلی قابلیت‌های تازه ارائه می کنند. و با این حال باز هم از زبانی مانند C که ۴۵ سال است قابلیت خاصی به آن اضافه نشده عقب تر هستند! وقتی همه‌ی زبان‌ها، همه‌ی قابلیت‌ها را به خود اضافه کنند، دیگر فرق زیادی با یکدیگر نخواهند داشت. همه‌شان یک شکل شده‌اند!&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;in-red&#34;&gt;
نبود یک سری از قابلیت‌ها در گولنگ، کاملا از روی عمد و با قصد قبلی طراحان زبان اتفاق افتاده است. به همین سرعت، نبود این قابلیت‌ها را مبنی بر ضعف زبان نگذارید! شاید منفعت‌هایی در میان است که شما از آن بی‌خبرید!
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;golang-generics&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;دست-یابی-به-جنریک-در-گولنگ&#34;&gt;دست یابی به جنریک در گولنگ&lt;/h3&gt;

&lt;p&gt;حالا که می دانیم جنریک‌ها چگونه در زبان‌های مختلف پیاده‌سازی می‌شوند، سوال پیش می‌آید که گولنگ از کدام یکی از این روش ها پشتیبانی می‌کند؟  بسته‌سازی یا تولید کد؟ جواب: «هر دوی آن‌ها».&lt;/p&gt;

&lt;p&gt;درست است، گولنگ از هر دو روش مرسوم پیاده‌سازی جنریک پشتبانی می کند! این قضیه را در ادامه‌ی نوشته توضیح  خواهیم داد.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;q-golang-lessgen&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;چرا-در-گولنگ-نیاز-به-جنریک-کمتر-حس-می-شود&#34;&gt;چرا در گولنگ نیاز به جنریک کمتر حس می‌شود؟&lt;/h3&gt;

&lt;p&gt;قبل از اینکه به جنریک‌ها در گولنگ بپردازیم، بهتر است ابتدا بررسی کنیم چرا جنریک‌ها در گولنگ نقش کمرنگ‌تری به نسبت بقیه زبان‌های استاتیک دارند:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;گولنگ از &lt;a href=&#34;http://amirrezaghaderi.ir/post/types/#structural-type-system&#34;&gt;تایپ سیستم مبتنی بر ساختار (Structural type system)&lt;/a&gt; بهره می‌برد. در زبان‌هایی مثل ++C یا Java یا #C یا غیره، تمرکز اصلی روی سلسله مراتب کلاس است؛ در صورتی که در گولنگ تمرکز اصلی روی &lt;a href=&#34;http://amirrezaghaderi.ir/post/types/#composition&#34;&gt;کامپوزیشن&lt;/a&gt; است. کل طراحی زبان گولنگ حول محور «کامپوزیشن» بنا گشته است. از همین رو «اینترفیس» ها و نحوه‌ی پیاده‌سازی آن‌ها در گولنگ از اهمیت بالایی برخوردار است. پیاده‌سازی منحصربه‌فرد گولنگ از مکانیزم اینترفیس، باعث شده است که این زبان قادر به استفاده از &lt;a href=&#34;http://amirrezaghaderi.ir/post/types/#duck-typing&#34;&gt;داک تایپینگ (Duck typing)&lt;/a&gt; باشد. یعنی با اینکه گولنگ یک زبان استاتیک است، اما براحتی قادر است برای قسمتی از کدها حالت داینامیک به خود بگیرد. این قضیه بخش بزرگی از نیاز به جنریک‌ها را در گولنگ کاهش داده است.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;مهم‌ترین کاربرد جنریک در زبان‌های استاتیک، پیاده‌سازی کالکشن‌ها است (ساختارهای داده‌ای ترکیبی). گولنگ به طور پیشفرض یک سری کالکشن پایه ارائه می‌کند که تمام آن‌ها به صورت داخلی حالت جنریک دارند! تایپ‌هایی مانند array و slice و map و توابعی مانند ()new و ()make و ()chan و ()append و غیره نیز همگی حالت جنریک دارند. پایتون‌ کاران را در نظر بگیرید، اگر از آن‌ها بپرسید پر استفاده ترین ساختاری که با کار می‌کنید چیست؟ خواهند گفت List و Dict&amp;hellip; اگر از یک پی‌اچ‌پی کار همین سوال را بپرسید، خواهد گفت: array&amp;hellip; در واقع، هر دوی آن‌ها اعتراف خواهند کرد که تقریبا تمام کدنویسی خود را بر مبنای این ‌ها انجام می دهند و به ندرت از ساختار ترکیبی دیگری استفاده می‌کنند! گولنگ نیز با slice و map و توابع حول و حوش آن‌ها، عملا درصد بسیار بالایی از نیازمندی به جنریک را از بین برده است.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span class=&#34;in-red&#34;&gt;
«شاخص‌ترین و قدرتمند‌ترین قابلیت گولنگ، اینترفیس‌های آن است&amp;hellip; مردم از امکانات همروندی گولنگ بیشتر سخن می‌گویند، ولی این امکانات به اندازه‌ی اینترفیس‌ها در کدهای روزانه شما دخیل نیستند&amp;hellip;» &amp;ndash; &lt;em&gt;راب پایک&lt;/em&gt;
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;این دو دلیل، مهم ترین عواملی هستند که شما در گولنگ بسیار کمتر از زبان‌های دیگر نیاز به جنریک را حس خواهید کرد. اما در صورت نیاز به جنریک، چاره چیست&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;کپی-و-پست&#34;&gt;کپی و پست&lt;/h3&gt;

&lt;p&gt;در چند جای برنامه نیاز به جنریک دارید؟ چند تایپ را قرار است به جنریک وارد کنید؟&lt;/p&gt;

&lt;p&gt;اگر در حد ۲-۳ مورد بود، از کپی و پست استفاده کنید! فرضا برای هر تایپ، یک گروه جدید از توابع مخصوص آن تایپ ایجاد کنید. جدی، کاملا جدی!&lt;/p&gt;

&lt;p&gt;آیا تا به حال چیزی را به صورت جنریک طراحی کرده اید؟ منظورم این نیست که از جنریک استفاده برده باشید، آیا خودتان مشخصا کتابخانه‌ای حول محور جنریک‌ها طراحی کرده‌اید؟ طراحی کدها بر مبنای جنریک‌ها کار حساسی است و نیاز به دقت بسیار بالایی دارد. حساسیت و دقتی که در خیلی از پروژه‌های روزمره‌مان وقت اش را نداریم!&lt;/p&gt;

&lt;p&gt;فرقی هم ندارد در کدام زبان هستید؛ حتی اگر هم زبان شما از جنریک پشتیبانی بکند، بهتر است در چنین شرایطی که استفاده از جنریک‌ها خیلی محدود است، قیدشان را بزنید و از کپی و پست استفاده نمایید! . هم کار خودتان سریع‌تر راه میفتد، و هم کدهای‌تان از پیچیدگی کمتری برخوردار خواهند شد. از همه مهم‌تر، کدهای‌تان بالاترین سرعت را خواهند داشت چرا که به صورت کاملا دستی ساخته شده‌اند!&lt;/p&gt;

&lt;p&gt;اینکه در ۲-۳ خط از برنامه نیازمند جنریک شویم، و فقط ۲-۳ تایپ را به آن‌ها وارد کنیم، بخش عمده‌ای از نیاز ما به جنریک در پروژه‌های مختلف را تشکیل می‌دهد!&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;golang-generic-box&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;پیاده-سازی-جنریک-ها-در-گولنگ-بسته-بندی-و-بسته-گ-شایی&#34;&gt;پیاده‌سازی جنریک‌ها در گولنگ: بسته‌بندی و بسته‌گُشایی&lt;/h3&gt;

&lt;p&gt;در زبان‌های استاتیک، تایپی وجود دارد که اصطلاحا آن را Any صدا می‌زنند. تایپ Any، تایپی ایست خنثی که هر تایپ دیگری می‌تواند به جایش بنشیند. در زبان C، این تایپ در قالب *void حضور دارد. در گولنگ نیز چنین تایپی با عبارت {}interface احضار می‌شود.&lt;/p&gt;

&lt;p&gt;{}interface در واقع به معنی یک اینترفیس خالی است. تمام تایپ‌ها در گولنگ به طور اتوماتیک از اینترفیس خالی تبعیت می‌کنند، و به همین دلیل می‌توانند به جای {}interface بنشینند. ما از {}interface برای بسته‌بندی سایر تایپ‌ها استفاده می‌کنیم.&lt;/p&gt;

&lt;p&gt;فرضا بیاید در گولنگ یک ساختار داده‌ای ترکیبی و جنریک شبیه List ها در پایتون را ایجاد کنیم. ابتدا در مسیر GOPATH/src$ یک پروژه جدید با اسم generic1 ایجاد کنید و فایل‌ها و دایرکتوری‌های آن را با شمایل زیر بچینید:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;generic1/
├── genericlist/
│   └── genericlist.go
└── main.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;پروژه بالا بسیار ساده است. فایل main.go که در ریشه‌ی پروژه قرار دارد فایلی است که تابع اصلی ()main در آن حضور دارد. یک پکیج به اسم genericlist هم ساخته‌ایم که کدهایش در فایل genericlist.go قرار خواهد گرفت (نیاز نیست نام فایل حتما با نام دایرکتوری یکی باشد)&lt;/p&gt;

&lt;p&gt;حالا کدهای زیر را در فایل genericlist.go کپی نمایید:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package genericlist


type Element interface{}


type List struct {
  list []Element
}


func NewList() *List {
  return &amp;amp;List { list: []Element{} }
}


func (L *List) Insert(el interface{}) {
  L.list = append(L.list, el)
}


func (L *List) Retrieve(i int) interface{} {
  return L.list[i]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;کد بالا ساده و کوتاه است. دقت کنید که چگونه عناصری که در لیست قرار خواهند گرفت را توسط Element بسته بندی کرده ایم. همچنین پارامتر توابع همگی از تایپ {}interface هستند. به این معنی که این تابع می‌تواند هر تایپی را به عنوان ورودی قبول کند.&lt;/p&gt;

&lt;p&gt;تایپی که لیست را در آن نگه داری می‌کنیم یک استراکت است با نام List. درون این استراکت هم یک slice از نوع Element تعریف کرده ایم با نام list (حرف اول کوچک است) که عناصر لیست را در آن خواهیم ریخت. برای این استراکت دو متد تعریف کرده ایم:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;متد Insert که عناصر را به لیست اضافه می‌کند&lt;/li&gt;
&lt;li&gt;متد Retrieve که با قبول یک ایندکس، عنصری که در آن ایندکس هست را برمی‌گرداند.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;برای استفاده از این پکیج، کدهای زیر را در فایل main.go کپی کنید:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

import &amp;quot;generic1/genericlist&amp;quot;


func main() {

  // a list with int items.
  L := genericlist.NewList()

  L.Insert(6)
  L.Insert(8)

  eleven := L.Retrieve(0).(int) + 5
  twelve := L.Retrieve(1).(int) + 4


  // a list with string items.
  L2 := genericlist.NewList()

  L2.Insert(&amp;quot;H&amp;quot;)
  L2.Insert(&amp;quot;J&amp;quot;)

  hello := L2.Retrieve(0).(string) + &amp;quot;ello&amp;quot;
  john  := L2.Retrieve(1).(string) + &amp;quot;ohn&amp;quot;

  // a list with float items.
  L3 := genericlist.NewList()
  L3.Insert(3)
  L3.Insert(3.14)
  L3.Insert(&amp;quot;Pi&amp;quot;)


  fmt.Println(L)
  fmt.Println(eleven)
  fmt.Println(twelve)

  fmt.Println(&amp;quot;------------&amp;quot;)

  fmt.Println(L2)
  fmt.Println(hello)
  fmt.Println(john)

  fmt.Println(&amp;quot;------------&amp;quot;)
  
  fmt.Println(L3)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;در کد بالا، ما از پکیج genericlist استفاده کردیم و متغیرهایی به نام‌های L و L2 ساختیم که هر کدام به ترتیب شامل لیست int و string هستند. در آخر هم متغیری به اسم L3 داریم که شامل یک لیست با عناصر ترکیبی است (مشابه چیزی که در زبان‌های داینامیک دارید). ما L3 را با سه تایپ مختلف int و string و float پر کردیم.&lt;/p&gt;

&lt;p&gt;دقت کنید در پکیج genericlist آرگومان‌های مربوط به توابع لیست را را با کمک {}interface بست بندی کرده بودیم. از همین رو اگر بخواهیم مقداری را از لیست بیرون بکشیم، باید آن را بسته گشایی کنیم. فرضا برای بسته گشایی مقادیر int از لیست اول، به این شیوه عمل کردیم:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eleven := L.Retrieve(0).(int) + 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;حواس‌تان به آن (int). که بعد از تابع Retrieve آمده باشد. تابع Retrieve تایپِ بسته بندی شده‌ی {}interface را بر‌می‌گرداند که در داخل خود مقدار اصلی int را نگه داشته است. برای دسترسی به آن مقدار int ، ما از (int). استفاده کردیم. این عمل را باید برای هر تایپ دیگری که مقدارش درون {}interface ها بسته‌بندی شده است نیز انجام دهیم.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;دستور بالا پروژه را کامپایل می‌کند و فایل اجرایی تولید شده را در مسیر GOPATH/bin$ قرار می‌دهد. اگر بدرستی شاخه‌ی GOPATH/bin$ را به مسیر اجرایی سیستم اضافه کرده باشید (PATH)، می‌توانید با فراخوانی نام فایل اجرایی، برنامه را اجرا نمایید. در صورت اجرای موفق، خروجی زیر را خواهید داشت:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ generic1

&amp;amp;{[6 8]}
11
12
------------
&amp;amp;{[H J]}
Hello
John
------------
&amp;amp;{[3 3.14 Pi]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;اکثر افراد دیگر لازم نیست بیشتر از این برای دستیابی به جنریک‌ها تلاش کنند. تکنیک بسته‌بندی و بسته‌گُشایی در گولنگ انتظار بیشتر افراد را برطرف می‌کند. اما ممکن است عده‌ای معتقد باشند بسته‌بندی و بسته‌گُشایی حالت داینامیک دارد و کامپایلر نمی تواند خطاهای احتمالی را قبل از اجرای برنامه شناسایی کند. برای این افراد، استفاده از بخش بعدی را توصیه می‌کنیم&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;golang-generation&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;پیاده-سازی-جنریک-ها-در-گولنگ-تولید-کد&#34;&gt;پیاده‌سازی جنریک‌ها در گولنگ: تولید کد&lt;/h3&gt;

&lt;p&gt;در جامعه‌ی کاربری گولنگ، توسعه‌ی برنامه‌ها با توسل به تکنیک‌های مختلف «تولیدِ کد»  تبدیل به یک ایده‌آل شده است. از نسخه‌ی ۱.۴ گولنگ، ابزاری به نام go generate نیز به جعبه ابزار زبان اضافه شده که عملیات تولید کد را راحت‌تر می‌کند.&lt;/p&gt;

&lt;p&gt;همانطور که گفتیم یکی از راه‌های پیاده‌سازی جنریک در زبان‌های مختلف، استفاده از تکنیکِ تولیدِ کد است؛ و گولنگ هم که در تکنیک‌های تولید کد، دستِ توانایی دارد!&lt;/p&gt;

&lt;p&gt;شما می‌توانید تکنیک Monomorphization که در زبان‌هایی مانند ++C یا Rust برای پیاده‌سازی جنریک استفاده شده است را در گولنگ نیز پیاده‌سازی کنید. تنها فرق این است که در آن زبان‌ها Monomorphization به طور خودکار و به دور از چشم برنامه‌نویسان اتفاق می‌افتد، ولی در گولنگ به کمک ابزارهای جانبی اینکار انجام می‌شود و برنامه‌نویس باید به طور مستقیم آن ابزار را فراخانی کند. (اختلاف تنها در «یک خط» دستور اضافه‌تر است!)&lt;/p&gt;

&lt;p&gt;خوشبختانه برای جنریک‌ها، لازم نیست خودتان ابزار خاصی بسازید. به اندازه‌ی کافی ابزارهای مختلف برای این منظور ساخته شده است:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://github.com/clipperhouse/gen
https://github.com/cheekybits/genny
https://github.com/joeshaw/gengen
https://github.com/droundy/gotgo
https://github.com/taylorchu/generic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;تمام ابزارهای بالا می‌توانند شما را برای داشتن جنریک با روش تولیدِکد یاری کنند. من در این نوشته به کمک یکی از این ابزارها با نام genny ، کدهای جنریک خود را در گولنگ می‌نویسم و از آن‌ها استفاده می‌کنم. ابتدا باید ابزار genny را نصب کنید. ترمینال را باز کنید و خط زیر را در آن اجرا کنید:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/cheekybits/genny
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;دستور بالا ابزار genny را از اینترنت دریافت می‌کند و آن را در GOPATH$ نصب خواهد کرد. (ممکن است به وی/پی/ان نیاز پیدا کنید).&lt;/p&gt;

&lt;p&gt;حالا می‌خواهیم همان پکیج genericlist که در قسمت قبلی تعریف کرده بودیم را به شیوه‌ی جدید بسازیم. ابتدا در مسیر GOPATH/src$ یک پروژه جدید به اسم generic2 ایجاد کنید و فایل‌ها و دایرکتوری‌های آن را با شمایل زیر بچینید:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;genric2/
├── genericlist/
│   └── genericlist.go
└── main.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;حالا کدهای زیر را در فایل genericlist.go کپی نمایید:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate genny -in=$GOFILE -out=genny-$GOFILE gen &amp;quot;Element=int&amp;quot;

package genericlist


import &amp;quot;github.com/cheekybits/genny/generic&amp;quot;


type Element generic.Type


type ElementList struct {
  list []Element
}


func NewListElement() *ElementList {
  return &amp;amp;ElementList { list: []Element{} }
}


func (L *ElementList) Insert(el Element) {
  L.list = append(L.list, el)
}


func (L *ElementList) Retrieve(index int) Element {
  return L.list[index]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;اگر خوب کدها رو بررسی کنید، متوجه می‌شوید که ما تغییرات زیادی به نسبت پکیج قدیمی genericlist اعمال نکرده‌ایم. الگوریتم‌ها همه یکسان است و فقط نام یک سری از عناصر تغییر کرده. اول از همه، پکیج مربوط به ابزار genny را به برنامه وارد کردیم. سپس به جای اینکه Element را از تایپ {}interface تعریف کنیم، آن را با یک تایپ مخصوص به نام generic.Type تعریف کرده ایم که از پکیج مربوط به genny در دسترس خواهد بود.&lt;/p&gt;

&lt;p&gt;وقتی Element را از این تایپ تعریف می‌کنیم، یعنی به ابزار genny اعلام کرده‌ایم که این عنصر در واقع یک «متغیرِ تایپ» است و تایپ‌های اصلی در آینده قرار است به جای این عنصر بنشینند.&lt;/p&gt;

&lt;p&gt;کاری که genny می کند چیست؟&lt;/p&gt;

&lt;p&gt;کد بالا به فرم جنریک نوشته شده است. و اعلام کرده‌ایم که Element همان «متغیرِ تایپ» این کد است و در آینده باید با تایپ‌های اصلی جایگزین شود. ابزار genny این کد را آنالیز می کند، و هر جا که با Element مواجه شد، آن را با تایپ نهایی و مورد نظر ما تعویض می کند. با اینکار، کدهای جنریک ما را تبدیل به کدهای غیر جنریک خواهد کرد.&lt;/p&gt;

&lt;p&gt;ما می‌توانیم genny را به شکل مستقل در ترمینال صدا بزنیم. اما فرمان go generate از جعبه ابزار گولنگ، این کار را برای ما راحت تر کرده است. به خط اول از کد بالا دقت کنید. آن خط یک کامنتِ معمولی نیست، یک کامنتِ مخصوص است!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate genny -in=$GOFILE -out=genny-$GOFILE gen &amp;quot;Element=int&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;تکه‌ی اول که شامل go:generate// است، به کامپایلر گولنگ می‌گوید که در این خط قرار است فرمان مخصوصی را اجرایی کند. این فرمان در مثال بالا همان ابزار genny است. ادامه‌ی خط، مانند صدا کردن genny در ترمینال است.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;آرگومان in- تعیین می‌کند کدام فایل آنالیز شود (در مثال بالا فایل فعلی پردازش می‌شود).&lt;/li&gt;
&lt;li&gt;آرگومان out- تعیین می‌کند که حاصل عملیات genny در چه فایلی ریخته شود.&lt;/li&gt;
&lt;li&gt;زیر فرمانِ gen نیز تایپ‌های مقصد را مشخص می‌کند. مثلا در بالا به genny اعلام کرده‌ایم  Element ها را با int جایگزین کند. هر تعداد تایپ دیگر که دوست داریم می توانیم در این قسمت لحاظ کنیم (با , آن‌ها را از هم جدا کنید)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;اگر در دایرکتوری پروژه هستید، تنها کافیست به دایرکتوری پکیج genericlist وارد شوید و فرمان زیر را در ترمینال اجرا کنید:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd genericlist
$ go generate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;با اینکار genny پردازش ‌اش را انجام می دهد و خروجی کارش را در فایل جدیدی به اسم genny-genericlist.go قرار خواهد داد. اگر این فایل را باز کنید، با کدهای زیر مواجه خواهید شد:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package genericlist

type IntList struct {
	list []int
}

func NewListInt() *IntList {
	return &amp;amp;IntList{list: []int{}}
}

func (L *IntList) Insert(el int) {
	L.list = append(L.list, el)
}

func (L *IntList) Retrieve(index int) int {
	return L.list[index]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;همانطور که می‌بینید، کدهای اضافی پاک شده‌اند و تمام Element ها با int که تایپ مد نظر ما بوده تعویض شده‌اند.&lt;/p&gt;

&lt;p&gt;برای استفاده از پکیج‌ای که ساختیم، کدهای زیر را در main.go کپی کنید:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

import &amp;quot;generic2/genericlist&amp;quot;


func main() {
  L := genericlist.NewListInt()

  L.Insert(6)
  L.Insert(8)

  eleven := L.Retrieve(0) + 5
  twelve := L.Retrieve(1) + 4

  fmt.Println(L)
  fmt.Println(eleven)
  fmt.Println(twelve)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;حالا به دایرکتوری ریشه‌ی پروژه برگردید و پروژه را کامپایل و اجرا نمایید:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go install

$ generic2

&amp;amp;{[6 8]}
11
12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;این روش کاملا استاتیک است و در زمان کامپایل اتفاق می‌افتد؛ همچنین نیازی به هیچ گونه عملیات زمان اجرا ندارد و از نظر امنیتِ مربوط به تایپ سیستم و سرعت در بالاترین سطح ممکن است. تنهای کاری که باید می کردید این بود که یکبار کدهای‌تان را به شکل جنریک بنویسید، و تنها با یک فرمان go generate آن‌ کد را پردازش نمایید. زیاد سخت نبود، بود؟&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;end&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;سخن-آخر&#34;&gt;سخن آخر&lt;/h2&gt;

&lt;p&gt;اگر کسی از شما پرسید چگونه در گولنگ که فاقد جنریک است برنامه‌نویسی می‌کنید، می‌توانید جواب زیر را به او بدهید.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;با توجه به اینکه گولنگ دارای &lt;a href=&#34;http://amirrezaghaderi.ir/post/types/#structural-type-system&#34;&gt;تایپ سیستم مبتنی بر ساختار (Structural type system)&lt;/a&gt; است و تعدادی کالکشن استاندارد و جنریک را هم به طور پیشفرض در خودش دارد، نیاز ما به جنریک در گولنگ بسیار پایین‌تر از بقیه زبان‌های استاتیک است.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;در موارد معدودی اگر نیاز به جنریک حس شد، می‌توانیم با تکنیک‌های بسته‌بندی و بسته‌گُشایی در زمان اجرا و همچنین تولید کد، جنریک‌ها را در زبان پیاده‌سازی کنیم.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;پ.ن: قصد این نوشته ابدا این نبوده که قابلیت جنریک را بی اهمیت جلوه دهد. جنریک یکی از مفیدترین مکانیزم‌های موجود در زبان‌های استاتیک تایپ است. در مورد گولنگ، شخصا فکر می‌کنم بسیار خوب خواهد شد اگر جنریک به زبان اضافه شود؛ در واقع هدف اصلی این نوشته این بوده که برنامه‌نویسان در هر زبانی که برنامه نویسی می‌کنند، سعی کنند بیشتر از اینکه با قابلیت‌هایش آشنا شوند، با «کم و کاستی» هایش آشنا شوند؛ روی این کم و کاستی‌ها فکر کنند؛ و راه حل‌های جایگزین آن را بررسی نمایند؛ چرا که اگر بخواهند به جای کار مفید و مثبت، مدام در حال بهانه‌جویی باشند، فقط خودشان را خسته کرده‌اند. در دنیای برنامه نویسی، هیچ زبانی بی ایراد نیست!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>شیوه‌های مختلف پیاده سازی جنریک در زبان‌ها</title>
      <link>https://amirrezaghaderi.com/fa/blog/generics/</link>
      <pubDate>July 11, 2017</pubDate>
      <author>Amirreza Ghaderi</author>
      <guid>https://amirrezaghaderi.com/fa/blog/generics/</guid>
      <description>

&lt;p&gt;&lt;a name=&#34;toc&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;فهرست-مطالب&#34;&gt;فهرست مطالب&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#prereq&#34;&gt;مطالب پیش‌نیاز&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#generic-howto&#34;&gt;شیوه‌های مختلف پیاده سازی جنریک در زبان‌ها&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#boxing-unboxing&#34;&gt;بسته‌بندی و بسته‌گُشایی در زمان اجرا (Boxing and Unboxing)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#code-generation&#34;&gt;تولید کد (Code generation)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#monomorphization&#34;&gt;یک ریخت سازی ( Monomorphization )&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#type-erasure&#34;&gt;پاک‌سازیِ تایپ (Type Erasure)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;prereq&#34;&gt;&lt;/a&gt;
&lt;strong&gt;مطالب پیش نیاز&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;در این نوشته قصد داریم شیوه‌هایی که زبان‌های مختلف برنامه‌نویسی به کمک آن جنریک‌ها را  در خود پیاده سازی کرده‌اند بررسی کنیم. قبل از خواندن این نوشته، نیازمند آشنایی با یک سری مفاهیم پیش نیاز هستید. مثلا، این «جنریک» که قرار است درباره پیاده سازی آن صحبت کنیم اصلا چه چیزیست؟ اگر با چنین مباحثی آشنا نیستید، می‌توانید برای مطالعه‌ی آن‌ها به زبان فارسی وارد لینک‌های زیر شوید:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://amirrezaghaderi.ir/post/types/#polymorphism&#34;&gt;پُلی مورفیسم - چندریختی (Polymorphism)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://amirrezaghaderi.ir/post/types/#composition&#34;&gt;کامپوزیشن چیست؟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://amirrezaghaderi.ir/post/types/#interface&#34;&gt;اینترفیس (Interface)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://amirrezaghaderi.ir/post/types/#structural-type-system&#34;&gt;تایپ سیستم مبتنی بر ساختار (Structural type system)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://amirrezaghaderi.ir/post/types/#duck-typing&#34;&gt;داک تایپینگ (Duck typing)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://amirrezaghaderi.ir/post/types/#generic&#34;&gt;جنریک (Generic)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;generic-howto&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;شیوه-های-مختلف-پیاده-سازی-جنریک-در-زبان-ها&#34;&gt;شیوه‌های مختلف پیاده سازی جنریک در زبان‌ها&lt;/h2&gt;

&lt;p&gt;برای پیاده‌سازی جنریک در زبان‌های برنامه‌نویسی، شیوه‌های گوناگونی ابداع شده است؛ اما می‌توان تمام آن‌ها را به شکل مستقیم یا غیر مستقیم در دو گروه زیر طبقه بندی کرد:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;بسته‌بندی و بسته‌گُشایی در زمان اجرا (Boxing and Unboxing)&lt;/li&gt;
&lt;li&gt;تولید کد (Code generation)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;بیایید کمی این دو را توضیح دهیم&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;boxing-unboxing&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;بسته-بندی-و-بسته-گ-شایی-در-زمان-اجرا-boxing-and-unboxing&#34;&gt;بسته‌بندی و بسته‌گُشایی در زمان اجرا (Boxing and Unboxing)&lt;/h3&gt;

&lt;p&gt;یک انبار لوازم خانگی را تصور کنید: کولر، یخچال، تلویزیون، سینما خانگی، چرخ گوشت، آب میوه گیری،&amp;hellip;&lt;/p&gt;

&lt;p&gt;وقتی وارد این انبار شوید چه می‌بینید؟ کولر و یخچال و تلویزیون و ..؟ خیر، شما در این انبار فقط «جعبه» می‌بینید! جعبه‌های بزرگ و کوچک که در کنار هم چیده شده اند. تمام آن لوازم، در این جعبه‌ها قرار دارند. به عبارتی «جعبه»، یک موجودیت استاندارد است که می‌توانیم هر نوع وسیله‌ای که بخواهیم درآن قرار دهیم. مهم نیست جنس وسیله چه باشد، تمام آن‌ها می‌توانند در جعبه‌ها «بسته‌بندی» شوند! با بسته‌بندی کردن وسایل در جعبه‌ها، ما شکل و شمایل همه‌ی آن‌ها را «یکسان» کرده‌ایم.&lt;/p&gt;

&lt;p&gt;اگر می‌خواستیم مثال بالا را در برنامه‌نویسی عنوان کنیم چنین می‌شد:&lt;/p&gt;

&lt;p&gt;چند تایپ داریم: تایپِ کولر، تایپِ یخچال، تایپِ تلویزیون،&amp;hellip; این تایپ‌ها با یکدیگر متفاوت هستند، اما می‌توانیم آن‌ها در «تایپِ جعبه» بسته‌بندی کنیم؛ با اینکار تایپ تمام آن‌ها از نمای بیرون، یکسان خواهد بود. حالا می توانیم از این یکسان شدن تایپ‌ها برای پلی مورفیسم استفاده نماییم.&lt;/p&gt;

&lt;p&gt;تایپِ جعبه در زبان‌های برنامه‌نویسی معمولا توسط یک اشاره‌گر پیاده‌سازی می‌شود. یعنی به جای اینکه مستقیم با تایپِ مد نظرمان طرف شویم، با یک تایپ ثانویه که شامل اشاره‌گری به تایپ مورد نظرمان است طرف خواهیم شد.&lt;/p&gt;

&lt;p&gt;برگردیم به مثال انبار لوازم خانگی؛ فرض کنید می‌خواهید از یکی از تلویزیون‌های داخل انبار استفاده کنید. اما تلویزیون درون جعبه است، آیا می‌توانید جعبه‌ی تلویزیون را مستقیم به برق وسط کنید؟ خیر&amp;hellip; باید ابتدا جعبه را «بسته‌گشایی» نمایید تا بدین ترتیب به محتوای درون آن که همان تلویزیون باشد دسترسی پیدا کنید.&lt;/p&gt;

&lt;p&gt;در برنامه‌نویسی هم همینطور است. اگر تایپی را توسط «تایپِ جعبه» بسته‌بندی کرده باشید، دیگر نمی‌توانید مستقیما با آن تایپ کار کنید. باید ابتدا «تایپِ جعبه» را بسته‌گشایی کنید تا بتوانید به چیزی که درون آن است دسترسی پیدا کنید. همانطور که گفتیم «تایپ جعبه» شامل اشاره‌گریست به تایپ اصلی؛ ما برای دسترسی به تایپ اصلی باید به شکل غیر مستقیم و از طریق این اشاره‌گر، به مکان آن تایپ در حافظه رجوع کنیم. (dereference)&lt;/p&gt;

&lt;p&gt;مثلا وقتی در پایتون می‌گویید a = 10 ، عدد صحیح 10 در متغیر a ریخته &lt;strong&gt;نمی‌شود&lt;/strong&gt;.  a در واقع یک اشاره‌گر است که به مکان دیگری از حافظه که عدد صحیح 10 در آن حضور دارد اشاره می کند. در این حالت می‌گوییم آن مقدار را به کمک a بسته‌بندی کرده‌ایم.&lt;/p&gt;

&lt;p&gt;چون مقدار 10 توسط a بسته‌بندی شده است، نمی‌توانیم مستقیم به آن دسترسی داشته باشیم. در صورتی که بخواهیم از مقدار درون متغیر a استفاده کنیم، باید به طور غیر مستقیم و به کمک ارجاعی که a در اختیار ما گذاشته است به آن برسیم. در این حالت می‌گوییم دسترسی به مقدار 10 از طریق بسته‌گشایی از متغیر a رخ داده است.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+-------+                     +--------+
|   a   | -----------------&amp;gt;  |   int  |
+-------+                     +--------+
                              |   10   |
                              +--------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;قریب به اتفاق زبان‌های داینامیک‌تایپ از این تکنیک استفاده می‌کنند؛ مانند پایتون، روبی، پی‌اچ‌پی، جاوااسکریپت و غیره&amp;hellip; تمام اعمال مربوط به بسته‌بندی‌ها و بسته‌گشایی ها در پشت صحنه و به دور از چشمان شما انجام می‌گیرد و شما به حالت معمول لازم نیست کاری انجام دهید؛ برای همین است که شما در این زبان‌ها نیاز به جنریک ندارید، چرا که این زبان‌ها به طور خودکار دارای جنریک در زمان اجرا هستند.&lt;/p&gt;

&lt;p&gt;زبان‌های استاتیک هم می‌توانند از تکنیک «بسته‌بندی و بسته‌گُشایی» استفاده نمایند تا جنریک‌ها را در زمان اجرا پیاده‌سازی کنند.&lt;/p&gt;

&lt;p&gt;مزیت‌های این تکنیک:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;سادگی در پیاده سازی&lt;/li&gt;
&lt;li&gt;انعطاف پذیری بسیار بالا (در حدی که کدهای‌تان عملا تبدیل به کدهای داینامیک می‌شوند!)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;معایب این تکنیک:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;مصرف حافظه بالاتر (به دلیل بسته بندی تایپ‌ها با یک لایه‌ی ثانویه)&lt;/li&gt;
&lt;li&gt;سرعت اجرای پایین‌تر (به دلیل اعمال مربوط به بسته‌بندی و بسته‌گُشایی)&lt;/li&gt;
&lt;li&gt;امنیت پایین‌تر به دلیل اتفاق افتادن این مکانیزم در زمان ران‌تایم (کامپایلر نمی‌تواند تایپ‌ها را قبل از اجرای برنامه چک کند، چرا که تمام تایپ‌ها از نظر او از یک جنس هستند: تایپِ جعبه)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;code-generation&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;تولید-کد-code-generation&#34;&gt;تولید کد (Code generation)&lt;/h3&gt;

&lt;p&gt;تولید کد یا ویرایش آ‌ن‌ها قبل از مرحله‌ی نهایی کامپایل، از وظایف بدیهی هر کامپایلر است. کامپایلرها یا ابزارهایی که مولد کد هستند، می‌توانند کدهایی که برنامه‌نویس به شکل جنریک نگارش کرده است را به گونه‌ای بازسازی کنند که تبدیل به کدهایی بدون جنریک و معمولی شوند. سپس این کدهای معمولی به خورد کامپایلر داده خواهند شد. این روند به چندین روش قابل پیاده سازی است که در این نوشته ما دو مورد از آن ها را توضیح خواهیم داد:&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;monomorphization&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;یک-ریخت-سازی-monomorphization&#34;&gt;یک ریخت سازی ( Monomorphization )&lt;/h3&gt;

&lt;p&gt;عجب کلمه‌ی عجیب و بزرگی! گول ظاهر آن را نخورید، چرا که «یک ریخت سازی» از ساده ‌ترین روش‌های پیاده‌سازی جنریک است. «یک ریخت سازی» یعنی کامپایلر به ازای هر تایپی که قرار است در جنریک شرکت داده شود، یک پیاده سازی مجزا از آن جنریک را ارائه کند که مخصوص همان تایپ باشد.&lt;/p&gt;

&lt;p&gt;مثلا تابع جنریک زیر را در نظر داشته باشید. کار این تابع این است که هر آرگومانی به آن ارسال کردیم، عینا آن را برگشت دهد (شبه کد):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function echo&amp;lt;T&amp;gt;( T arg)  ⟹ T {
    return arg;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;اگر ما در کدهایمان به این شکل از تابع بالا استفاده کنیم:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo&amp;lt;int&amp;gt;(12);    ---&amp;gt; 12
echo&amp;lt;float&amp;gt;(3.14);    ---&amp;gt; 3.14
echo&amp;lt;string&amp;gt;(&amp;quot;hi&amp;quot;);    ---&amp;gt; &amp;quot;hi&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;کامپایلر در پشت صحنه قبل از اینکه برنامه را کامپایل کند، سه گروه از تابع echo را تولید خواهد کرد (به تناسب تایپ‌هایی که به آن وارد شده‌اند):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function echoInt( int arg ) ⟹ int{
    return arg;
}

function echoFloat( float arg ) ⟹ float {
    return arg;
}

function echoString( string arg ) ⟹ string {
    return arg;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;به این روش می‌گوییم «یک ریخت سازی». در اینجا کدهای جنریک قبل از اینکه به مرحله‌ی کامپایل برسند، به کدهای معمولی و بدون جنریک تبدیل شدند. زبان‌هایی مانند ++C و ‌Rust از این روش برای پیاده‌سازی جنریک استفاده می‌کنند. عمل تولید کد کاملا در پشت صحنه و به دور از چشم برنامه‌نویسان اتفاق می‌افتد.&lt;/p&gt;

&lt;p&gt;مزیت‌های این تکنیک:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;بالاترین حد از نظر سادگی در پیاده سازی&lt;/li&gt;
&lt;li&gt;بالاترین حد از نظر سرعت اجرا&lt;/li&gt;
&lt;li&gt;بالاترین حد از نظر امنیتِ تایپ سیستم&lt;/li&gt;
&lt;li&gt;کمترین حد از نظر مصرف حافظه و منابع دیگر (تقریبا صفر)&lt;/li&gt;
&lt;li&gt;بدون نیاز به عملیات زمان اجرا (zero-cost abstraction)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;معایب این تکنیک:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;زیاد شدن کدهایی که نیاز به تولید و کامپایل دارند (به ازای هر تایپ، یک گروه جدید از کدها تولید می‌شود)&lt;/li&gt;
&lt;li&gt;پایین آمدن سرعتِ کامپایل برنامه‌ها (با زیاد شدن تایپ‌ها، این افت سرعت شدیدتر خواهد شد)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;type-erasure&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;پاک-سازی-تایپ-type-erasure&#34;&gt;پاک‌سازیِ تایپ (Type Erasure)&lt;/h3&gt;

&lt;p&gt;پاک‌سازیِ تایپ شیوه‌ای از تکنیک تولید کد است که در آن اتفاقات زیر به وقوع می‌پیوندد:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;کامپایلر کدهای جنریک را آنالیز می‌کند. با این آنالیز اطلاعاتی که درباره کدهای جنریک نیاز دارد را بدست می‌آورد. (مثلا اینکه چه تایپ‌هایی در جنریک وارد شده‌اند)&lt;/li&gt;
&lt;li&gt;پس از کسب اطلاعات بالا، کامپایلر تمام نشانه‌های جنریک را از کدها حذف می‌کند و آن‌ها را به حالت معمولی تبدیل می نماید.&lt;/li&gt;
&lt;li&gt;به جای اینکه مثل تکنیک «یک ریخت سازی» چندین گروه از کدها را برای هر تایپ ایجاد کند، فقط یک نسخه‌ی غیر جنریک از کد را برای تمام تایپ‌ها تولید خواهد کرد&amp;hellip;&lt;/li&gt;
&lt;li&gt;اما در این نسخه‌ی غیر جنریک، کامپایلر در قسمت‌های خاصی که لازم است (با توجه به اطلاعاتی که کسب کرده)، کدهایی برای «تبدیل تایپ» (Type Casting) ها قرار خواهد داد.&lt;/li&gt;
&lt;li&gt;در این روش تمام عملیات در زمان کامپایل اتفاق می‌افتد، و فقط «تبدیل تایپ» در زمان اجرا صورت خواهد گرفت. با اینحال کامپایلر به ما اطمینان می‌دهد که این تبدیل تایپ در زمان اجرا با موفقیت انجام خواهد شد.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;زبانی مانند Java از این تکنیک استفاده می کند. مثلا در زیر یک کد جنریک جاوا را می‌بینید:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
list.add(&amp;quot;Hi&amp;quot;);
String x = list.get(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;قبل از کامپایل نهایی، جاوا کد بالا را به شکل زیر تولید مجدد خواهد کرد:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List list = new ArrayList();
list.add(&amp;quot;Hi&amp;quot;);
String x = (String) list.get(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;دقت کنید که چگونه کامپایلر تبدیل تایپ string را در نقطه‌ی دقیق قرار داده است تا برای برنامه مشکلی پیش نیاید.&lt;/p&gt;

&lt;p&gt;مزیت‌ها و معایب این تکنیک:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;سادگیِ متوسط در پیاده سازی&lt;/li&gt;
&lt;li&gt;سرعت تقریبا مناسب اجرا&lt;/li&gt;
&lt;li&gt;امنیتِ مناسب از نظر تایپ سیستم&lt;/li&gt;
&lt;li&gt;کمی حافظه‌ی سربار (بسیار قلیل)&lt;/li&gt;
&lt;li&gt;نیازمند به عملیات زمان اجرا، ولی به شکل بسیار محدود و کنترل شده&lt;/li&gt;
&lt;li&gt;سرعت کامپایل متوسط (در نهایت افت سرعت به نسب کامپایل معمولی وجود خواهد داشت، اگر چه کمتر)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>مفاهیم بنیادین تایپ سیستم ها</title>
      <link>https://amirrezaghaderi.com/fa/blog/types/</link>
      <pubDate>July 6, 2017</pubDate>
      <author>Amirreza Ghaderi</author>
      <guid>https://amirrezaghaderi.com/fa/blog/types/</guid>
      <description>

&lt;p&gt;&lt;a name=&#34;toc&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;فهرست-مطالب&#34;&gt;فهرست مطالب&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#intro&#34;&gt;مقدمه&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#def&#34;&gt;تعاریف&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#type&#34;&gt;تایپ (Type)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#type-system&#34;&gt;تایپ سیستم (Type System)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#typechecking&#34;&gt;تایپ چکینگ (Typechecking)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#type-checker&#34;&gt;تایپ چِکِر (Type checker)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#static-type&#34;&gt;استاتیک تایپ (Static Type)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dynamic-type&#34;&gt;داینامیک تایپ (Dynamic Type)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#optional-static-typing&#34;&gt;استاتیک تایپینگ داوطلبانه (Optional Static Typing)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#q-compile-static&#34;&gt;آیا تمام زبان‌های کامپایلری، استاتیک تایپ هستند؟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#type-inference&#34;&gt;کاوشگرِ تایپ (Type inference)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#explicitly-typed&#34;&gt;تایپ نگاریِ صریح (Explicitly Typed)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#implicitly-typed&#34;&gt;تایپ نگاریِ ضمنی (Implicitly Typed)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#q-static-var&#34;&gt;آیا استاتیک بودن یک زبان، به معنی نوشتن تایپ در کنار متغیر است؟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#strong-type&#34;&gt;زبان با تایپ مستحکم (Strong Type)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#weak-type&#34;&gt;زبان با تایپ سُست (Weak Type)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sound-type-system&#34;&gt;تایپ سیستم دقیق (Sound type system)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nominal-type-system&#34;&gt;تایپ سیستم مبتنی بر نام (Nominal type system)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#static-vs-dynamic&#34;&gt;مقایسه اجمالی بین زبان‌های استاتیک و داینامیک&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#polymorphism&#34;&gt;پُلی مورفیسم - چندریختی (Polymorphism)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adhoc-polymorphism&#34;&gt;پلی مورفیسم تک منظوره (Ad hoc polymorphism)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#overloading&#34;&gt;سربارگذاری تابع چیست؟ (Function overloading)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#subtyping-polymorphism&#34;&gt;پلی مورفیسم مبتنی بر رابطه‌ی تایپ‌ها (Subtyping)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#inheritance&#34;&gt;وراثت (Inheritance)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#overriding&#34;&gt;سایه اندازی (Overriding) چیست؟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bad-inheritance&#34;&gt;چرا وراثت مورد انتقاد است؟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#good-inheritance&#34;&gt;وراثت در چه زمانی سودمند و بی‌خطر است؟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#composition&#34;&gt;کامپوزیشن چیست؟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#impl-composition&#34;&gt;اجرایی نمودن کامپوزیشن&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#interface&#34;&gt;اینترفیس (Interface)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#structural-type-system&#34;&gt;تایپ سیستم مبتنی بر ساختار (Structural type system)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#duck-typing&#34;&gt;داک تایپینگ (Duck typing)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#parametric-polymorphism&#34;&gt;پلی مورفیسم مبتنی بر پارامتر (Parametric polymorphism)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#generic&#34;&gt;جنریک (Generic)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#generic-universal&#34;&gt;قابل پیش‌بینی نبودن تایپ‌های جایگزین در جنریک&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#generic-interface&#34;&gt;محدود کردن دامنه‌ی تایپ‌های جاگزین در جنریک&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#end&#34;&gt;سخن آخر&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;intro&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;مقدمه&#34;&gt;مقدمه&lt;/h2&gt;

&lt;p&gt;هر برنامه‌نویسی، اسم «تایپ» ها به گوشش خورده است و مسلما در طور دوران کاری‌اش به کررات با آن‌ها مواجه شده است. این نوشته به سه دلیل نگارش شده است:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;من هیچ مرجع فارسی دیگری که این تعداد مفهموم را به شکل یکجا، و با زبانی ساده و قابل درک توضیح داده باشد پیدا نکردم.&lt;/li&gt;
&lt;li&gt;با گذشت زمان متوجه شده‌ام که حتی خیلی از برنامه‌نویسان حرفه‌ای نیز درک درستی از مباحث مربوط به تایپ‌ها ندارند (حتی با اینکه ممکن است فکر کنند تایپ‌ها موضوعی کاملا بدیهی هستند.)&lt;/li&gt;
&lt;li&gt;در نظر داشتم مرجعی بسازم که اگر سوالی از همکارانم درباره تایپ ها پرسیده شد، آن‌ها بتواند برای راهنمایی طرف سوال کننده، مطلب زیر را به او معرفی نمایند.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;صحبت درباره تایپ سیستم‌ها نیازمند آشنایی با «تئوری تایپ» است. تئوری تایپ بیشتر  از اینکه یک مبحث کامپیوتری باشد، شاخه‌ای از علوم ریاضیات و منطق است و دنیای گسترده‌ای برای خودش دارد؛ و به طبع برای مطالعه و آشنایی عمیق با آن نیاز دارید که به همان اندازه در ریاضیات و منتطق هم متخصص باشید. اکثر برنامه‌نویسان، علم بالایی نسبت به مباحث تئوری تایپ ندارند؛ در واقع لازم نیست که داشته باشن. مباحث مربوط به تئوری تایپ نه در حیطه‌ی کاری عموم برنامه نویسان است، و نه حتی در حیطه‌ی کاری سازندگان زبان‌های برنامه‌نویسی. تئوری تایپ در زمره‌ی چیزهایی هست که «محققین زبان‌های برنامه‌نویسی» با آن سر و کار دارند. اما بد نیست که در حد یک مطالعه‌ی سطح بالا با این مباحث آشنا باشید&amp;hellip;&lt;/p&gt;

&lt;p&gt;محتوایی که در زیر آمده، مانند خراشِ ناخن است روی یک کوه عظیم یخی؛ که همان تئوری تایپ‌ها باشد! برگردان این مفاهیم به زبان فارسی کاری حقیقتا دشوار است. مخصوصا اینکه تصمیم‌ام بر این بود که سطح نوشته را در حالتی نگه دارم که برای برنامه‌نویسان متوسط نیز قابل درک باشد.&lt;/p&gt;

&lt;p&gt;همچنین دقت کنید که مفاهیم موجود در این نوشته، هر کدام می‌توانند به چندین روش و از چندین زاویه مختلف توضیح داده شوند. توضیحاتی که شما در این نوشته درباره این مفاهیم می خوانید، فقط زاویه دید «من» را منعکس می‌کنند؛ و بر این باور هستم که این مطالب به نسبت خیلی از منابع دیگر شفاف تر است.&lt;/p&gt;

&lt;p&gt;کدهایی که در این نوشته خواهید دید همگی «شِبهِ کد» هستند.&lt;/p&gt;

&lt;p&gt;متن زیر معادل چیزی بیشتر از ۲۵ صفحه‌ی چاپی است و نگارش آن یک هفته به طول انجامید؛ از آن مهم‌تر یادگیری و هضم این مفاهیم، به گونه‌ای که بتوانم آن را به دیگران  نیز آموزش دهم سال‌ها زمان برده است! درخواست من از خوانندگان این است که اگر جایی از مطالب این نوشته استفاده کردند، حداقل لینک منبع را نیز لحالظ نمایند.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;def&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;تعاریف&#34;&gt;تعاریف&lt;/h2&gt;

&lt;p&gt;&lt;a name=&#34;type&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;تایپ-type&#34;&gt;تایپ (Type)&lt;/h3&gt;

&lt;p&gt;خصوصیتی است که تعیین می‌کند یک «داده»، می‌تواند شامل چه «محتوا» ای باشد و چه کارهایی می‌توان با آن انجام داد.&lt;/p&gt;

&lt;p&gt;فرضا اگر می‌گوییم متغیر A از تایپ int است، یعنی پاسخ این دو سوال را در دست داریم:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;متغیر A شامل چه محتوایی خواهد بود؟ فقط اعداد صحیح.&lt;/li&gt;
&lt;li&gt;چه کارهایی می‌توان با متغیر A انجام داد؟ مثلا می‌توان آن را با یک عدد صحیح دیگر جمع بست. یا مثلا نمی‌توان آن را با یک مقدار رشته‌ای ضرب کرد!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;زبان‌های برنامه نویسی برای راحتی کار برنامه نویسان، غالبا تعدادی تایپ پیشفرض به همراه خود دارند. مانند تایپ int برای اعداد صحیح، یا تایپ string برای رشته‌ها؛ اما زبان‌ها امکانات مختلفی را فراهم کرده‌اند تا برنامه‌نویسان بتوانند خودشان نیز تایپ‌های جدیدی ایجاد کنند. فرضا وقتی در کدهای‌تان یک struct یا class جدید طراحی می‌کنید، در واقع یک تایپ جدید را به زبان معرفی کرده‌اید.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;type-system&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;تایپ-سیستم-type-system&#34;&gt;تایپ سیستم (Type System)&lt;/h3&gt;

&lt;p&gt;نظام ایست که با اتکا به «تایپ»ها، قوانین حاکم بر یک زبان برنامه‌نویسی را رقم می‌زند.&lt;/p&gt;

&lt;p&gt;از آنجایی که تایپ‌ها تعیین کننده‌ی خصوصیات داده‌ها هستند، تایپ سیستم می‌تواند به کمک آن بقیه اجزای زبان مانند شرط‌ها، حلقه‌ها، توابع، کلاس‌ها، ماژول‌ها و &amp;hellip; را تحت پوشش قرار دهد؛ چرا که تمام اجزای زبان با داده‌ها در ارتباط هستند. اگر زبان برنامه‌نویسی را مانند یک «کشور» تصور کنیم، تایپ سیستم حکم «قانون اساسی» را دارد. تایپ سیستم توسط سازندگان یک زبان برنامه‌نویسی و با توجه به اهداف آن زبان طراحی می‌گردد.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;typechecking&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;تایپ-چکینگ-typechecking&#34;&gt;تایپ چکینگ (Typechecking)&lt;/h3&gt;

&lt;p&gt;کدهایی که مینویسید باید از «تایپ سیستم» تبعیت کنند (یعنی قوانین زبان را رعایت کنند). تایپ چکینگ، فرآیندی است که در آن کدهای شما آنالیز می‌گردد تا اطمینان حاصل شود که رفتاری خارج از موازین تایپ سیستم نداشته باشند.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;type-checker&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;تایپ-چ-ک-ر-type-checker&#34;&gt;تایپ چِکِر (Type checker)&lt;/h3&gt;

&lt;p&gt;یک ابزار نرم‌افزاری، که مسئولیت اجرای فرآیند تایپ چکینگ را بر عهده دارد. ابزار تایپ چکر به شکل‌های مختلفی در روند توسعه‌ی نرم‌افزار شرکت می‌کند. در خیلی از زبان‌های برنامه‌نویسی، تایپ چکر قسمتی از کامپایلر است؛ و در خیلی از زبان‌های دیگر، تایپ چکر جزئی از مفسر زبان است. حتی در تعدادی از زبان‌ها، تایپ چکر یک برنامه‌ی کاملا مستقل است که می‌توانید آن را به تنهایی در ترمینال یا IDE فراخانی کنید.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;static-type&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;استاتیک-تایپ-static-type&#34;&gt;استاتیک تایپ (Static Type)&lt;/h3&gt;

&lt;p&gt;به زبانی «استاتیک تایپ» می‌گوییم که در آن فرآیند تایپ چکینگ «قبل از اجرای برنامه» اتفاق بیفتد.&lt;/p&gt;

&lt;p&gt;زبان‌های استاتیک تایپ، غالبا کامپایلری هستند و فرآیند تایپ چکینگ را در هنگام عملیات کامپایل و قبل از شروع برنامه اعمال می‌کنند؛ سی و سی‌پلاس‌پلاس، سی‌شارپ، جاوا، گولنگ، اسکالا، راست، سوییفت، کاتلین و &amp;hellip; جزو زبان‌های استاتیک تایپ هستند.&lt;/p&gt;

&lt;p&gt;در یک زبان استاتیک، وقتی تایپ‌ای را به یک متغیر نسبت می‌دهید، دیگر نمی‌توانید تایپ آن متغیر را عوض نمایید.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;dynamic-type&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;داینامیک-تایپ-dynamic-type&#34;&gt;داینامیک تایپ (Dynamic Type)&lt;/h3&gt;

&lt;p&gt;به زبانی «داینامیک تایپ» می‌گوییم که در آن فرآیند تایپ چکینگ «در زمان اجرای برنامه» اتفاق بیفتد.&lt;/p&gt;

&lt;p&gt;زبان‌های داینامیک تایپ، غالبا تفسیری هستند و فرآیند تایپ چکینگ را در هنگام تفسیر و اجرای کدها اعمال خواهند کرد؛ پایتون، روبی، پی‌اچ‌پی، جاوا اسکریپت، لوآ،  ارلنگ و الیکسیر، کلوژور و خانواده‌ لیسپ، و &amp;hellip; جزو زبان‌های داینامیک تایپ هستند.&lt;/p&gt;

&lt;p&gt;در یک زبان داینامیک، تایپ متغیرها می تواند در زمان اجرای برنامه تغییر کند.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;optional-static-typing&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;استاتیک-تایپینگ-داوطلبانه-optional-static-typing&#34;&gt;استاتیک تایپینگ داوطلبانه (Optional Static Typing)&lt;/h3&gt;

&lt;p&gt;بعضی از زبان‌های داینامیک، امکاناتی را فراهم کرده‌اند که برنامه‌نویسان را قادر می‌سازند در صورت تمایل، کدهایشان را به حالت استاتیک تایپ هم توسعه دهند. نمونه‌ی بارز این زبان‌ها ارلنگ، الیکسیر، پایتون، و جاوا اسکریپت می‌باشند.&lt;/p&gt;

&lt;p&gt;در این زبان‌ها اصولا تایپ چکر به صورت یک برنامه‌ی مستقل حضور پیدا میکند و می‌تواند کدها را به صورت استاتیک آنالیز نماید تا کدها قبل از اجرای برنامه چک شوند. برای ارلنگ و الیکسیر ابزار Dialyzer، برای پایتون ابزار mypy، و برای جاوا اسکریپت هم یک زبان جانبی مانند TypeScript در دسترس است.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;q-compile-static&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;آیا-تمام-زبان-های-کامپایلری-استاتیک-تایپ-هستند&#34;&gt;آیا تمام زبان‌های کامپایلری، استاتیک تایپ هستند؟&lt;/h3&gt;

&lt;p&gt;خیر. مثلا ارلنگ، الیکسیر، یا کلوژور همگی زبان‌های کامپایلری هستند، ولی تمام آن‌ها داینامیک تایپ می‌باشند. کامپایلری بودن یا نبودن زبان، ربطی به استاتیک یا داینامیک بودنش ندارد.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;type-inference&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;کاوشگر-تایپ-type-inference&#34;&gt;کاوشگرِ تایپ (Type inference)&lt;/h3&gt;

&lt;p&gt;فرآیندی که در آن تایپ یک داده مشخص می‌گردد.&lt;/p&gt;

&lt;p&gt;هرچند که از عبارت «تایپ اینفِرِنس» معمولا موقعی استفاده می‌گردد که مکانیزم شناسایی تایپ، به طور اتوماتیک و بدون نیاز به نوشتن نام تایپ‌ها در کدها انجام پذیرد. مثلا در زبانی مانند جاوا وقتی قرار باشد یک متغیر از تایپ عددی تعریف کنید باید چنین کدی بنویسید:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int a = 10;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;اما اگر مکانیزم تایپ اینفرنس در جاوا وجود داشت (که در برخی شرایط حضور دارد)، می‌توانستید کد بالا را اینگونه بنویسید:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = 10;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;مکانیزم تایپ اینفرنس از روی مقداری که به a نسبت داده اید، می‌توانست به طور خودکار متوجه شود که این متغیر از تایپ int است.&lt;/p&gt;

&lt;p&gt;زبان‌هایی مانند گولنگ، سوییفت، راست، و کاتلین از جمله زبان‌هایی هستند که در حد معقولی دارای تایپ اینفرنس می‌باشند؛ زبان‌هایی مانند هسکل یا اسکالا دارای تایپ اینفرنس پیشرفته تری هستند و تایپ چکر قادر است در نقاط بیشتری تایپ ها را حدس بزند.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;explicitly-typed&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;تایپ-نگاری-صریح-explicitly-typed&#34;&gt;تایپ نگاریِ صریح (Explicitly Typed)&lt;/h3&gt;

&lt;p&gt;هنگامی که به طور صریح، نام تایپ‌ها را در کدهایمان ذکر می‌کنیم؛ هنگامی که نام تایپ‌ها، جزیی از سینتکس زبان است.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;implicitly-typed&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;تایپ-نگاری-ضمنی-implicitly-typed&#34;&gt;تایپ نگاریِ ضمنی (Implicitly Typed)&lt;/h3&gt;

&lt;p&gt;هنگامی که لازم نیست نام تایپ‌ها را در کدهایمان ذکر کنیم (با توسل به تایپ اینفرنس)&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;q-static-var&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;آیا-استاتیک-بودن-یک-زبان-به-معنی-نوشتن-تایپ-در-کنار-متغیر-است&#34;&gt;آیا استاتیک بودن یک زبان، به معنی نوشتن تایپ در کنار متغیر است؟&lt;/h3&gt;

&lt;p&gt;خیر. استاتیک بودن یک زبان هیچ ربطی به نوشتن یا ننوشتن نام تایپ ها در کد ندارد. همانطور که در قسمت بالا اشاره کردیم، زبان‌هایی هستند که در آن‌ها لازم نیست نام تایپ‌ها را به شکل صریح در کدهایمان ذکر کنیم.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;strong-type&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;زبان-با-تایپ-مستحکم-strong-type&#34;&gt;زبان با تایپ مستحکم (Strong Type)&lt;/h3&gt;

&lt;p&gt;جدای از این قضیه که زبان استاتیک تایپ باشد یا داینامیک تایپ، اگر زبانی سیستم تایپ را با جدیت کامل اعمال کند، می‌گوییم که آن زبان دارای تایپ مستحکم یا استرانگ تایپ است. مثلا زبان نباید اجازه دهد داده‌ی عددی 12 با داده‌ی رشته‌ای &amp;ldquo;hi&amp;rdquo; جمع و تفریق شود؛ چرا که چنین چیزی از نظر منطقی بی معناست و مشخص نیست که نتیجه اش چه خواهد شد. زبان‌هایی مانند جاوا و سی شارپ و پایتون و روبی و &amp;hellip; همگی استرانگ تایپ هستند.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;weak-type&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;زبان-با-تایپ-س-ست-weak-type&#34;&gt;زبان با تایپ سُست (Weak Type)&lt;/h3&gt;

&lt;p&gt;جدای از این قضیه که زبان استاتیک تایپ باشد یا داینامیک تایپ، اگر زبانی سیستم تایپ را با جدیت کامل اعمال نکند، می‌گوییم که آن زبان دارای تایپ سُست یا ویک تایپ است. از نمونه‌های بارز چنین زبان‌هایی جاوا اسکریپت و پی‌اچ‌پی هستند. تمام برنامه‌نویسان تجربه‌ی مواجه شدن با رفتارهای غیر مترقبه را در این زبان‌ها داشته اند. برنامه‌نویسی در زبان‌های ویک تایپ همیشه با دردسرهای مربوط به تایپ‌ها همراه است و باید با احتیاط بالا انجام گیرد.&lt;/p&gt;

&lt;p&gt;یک نمونه‌ی معروف دیگر از زبان‌های ویک‌تایپ، زبان سی می‌باشد. در سی تقریبا همه‌ی تایپ‌های پایه عددی هستند و خود زبان هم به میزان زیادی شامل رفتار‌های تعریف نشده است. البته زبان سی به دلیل شرایط خاصی که در آن مورد استفاده قرار می‌گیرد اینگونه طراحی شده است. سی در واقع اسمبلی قابل حمل است و تافته‌ی جدا بافته از بقیه زبان هاست.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;sound-type-system&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;تایپ-سیستم-دقیق-sound-type-system&#34;&gt;تایپ سیستم دقیق (Sound type system)&lt;/h3&gt;

&lt;p&gt;بله، واژه Sound در انگلیسی که همگی آن را با معنی «صدا» می‌شناسیم، دارای معانی دیگری مانند دقیق، راسخ، استوار، یا سالم هم هست!&lt;/p&gt;

&lt;p&gt;هدف اصلی یک تایپ سیستم استاتیک، جلوگیری از رخ دادن خطاهای زمان اجراست. تایپ سیستم‌ای که بتواند آنقدر قدرتمند و جامع باشد که با توسل به آن  اطمینان حاصل کنیم که هیچ خطایی در زمان اجرا رخ نخواهد داد، با عبارت «ساند تایپ سیستم» شناخته می‌شود.&lt;/p&gt;

&lt;p&gt;البته ثابت شده است که وجود چنین تایپ سیستم ای امکان پذیر نیست؛ فرضا وقتی در زمان اجرای برنامه برق رفت، تایپ سیستم (هرچقدر هم که قدرتمند باشد) چه کاری از دستش بر میآید؟ بنابراین وقتی می‌گوییم یک زبان دارای ساند تایپ سیستم است، در واقع منظورمان این است که آن زبان در یک سری از موارد مشخص، به ما گارانتی صددصد می دهد (نه در تمام موارد؛ چون امکان پذیر نیست). اکثر زبان‌های استاتیک تاپ امروزی، دارای ساند تایپ سیستم هستند.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;nominal-type-system&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;تایپ-سیستم-مبتنی-بر-نام-nominal-type-system&#34;&gt;تایپ سیستم مبتنی بر نام (Nominal type system)&lt;/h3&gt;

&lt;p&gt;گروهی از تایپ سیستم‌ها هستند که هماهنگی و برابر بودن تایپ‌ها را بر حسب اعلان‌های تایپ اعتبار سنجی می‌کنند.&lt;/p&gt;

&lt;p&gt;این تایپ سیستم‌ها از روی اعلانات (اسمِ) تایپ‌ها، می‌توانند تشخیص دهند که آیا تایپ ها با یکدیگر هماهنگی دارند یا خیر؛ و یا اینکه رابطه‌ی تایپ‌ها با یکدیگر چگونه است (مثلا رابطه‌ی وراثت). سی‌پلاس‌پلاس، جاوا، سی‌شارپ، سوییفت، راست، و &amp;hellip;. دارای همچین تایپ سیستمی هستند.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;static-vs-dynamic&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;مقایسه-اجمالی-بین-زبان-های-استاتیک-و-داینامیک&#34;&gt;مقایسه اجمالی بین زبان‌های استاتیک و داینامیک&lt;/h3&gt;

&lt;p&gt;سرعت:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;استاتیک: کامپایلر قبل از اجرای برنامه و به کمک تایپ سیستم، می‌تواند اطلاعات زیادی راجع به کدها بدست آورد. غالبا کامپایلر ها از این اطلاعات استفاده می‌کنند و تا جایی که برای شان امکان دارد کدها را قبل از اجرا بهینه سازی می نمایند. به همین دلیل در اکثر اوقات (نه در همه‌ی اوقات)، زبان‌های استاتیک سرعت بالاتری به نسب زبان‌های داینامیک دارند.&lt;/li&gt;
&lt;li&gt;داینامیک: زبان‌های داینامیک معتقداند سرعت «توسعه»ی برنامه بیشتر اوقات مهم‌تر از سرعت «اجرا»ی برنامه هاست. در این زبان‌ها کمتر با تایپ‌ها سر و کله می‌زنید و بیشتر به «الگوریتم» توجه می‌کنید. همچنین چرخه‌ی کامپایل در بیشتر این زبان‌ها وجود ندارد و برنامه‌نویس سریعتر کدش را به مرحله‌ی اجرا می‌رساند.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;مستندات:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;استاتیک: نگارش اعلان‌های تایپ در کدهایمان، خودش یک نوع مستندسازی محسوب می‌شود. فرضا از تایپ‌های یک تابع می‌توان متوجه شد که آن تابع دقیقا چه داده را به عنوان ورودی می پذیرد و چه خروجی‌ای بر‌میگرداند.&lt;/li&gt;
&lt;li&gt;داینامیک: تقریبا در تمام زبان‌های داینامیک، کدهایی ایده‌آل تلقی می‌شوند که تایپ‌ها را به نحوی اعلام کرده باشند؛ مثلا در بلاکْ کامنت‌هایی که قبل از تعریف توابع می‌نویسند. اما این قضیه کاملا به منظم و با حوصله بودن برنامه‌نویس مربوط است و هیچ اجباری در آن نیست. یعنی یک برنامه‌نویس بی حوصله می‌تواند این مستندات رو ننویسد و باعث سردرگمی شود.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;اطمینان از صحت کدها:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;استاتیک: تایپ چکر قبل از اجرای برنامه، کدها را از نظر وجود ناهماهنگی ها ارزیابی می‌کند و می تواند تعداد بسیاری از مشکلات را قبل از اجرای برنامه شناسایی نماید. تایپ چکر حکم «دستیار» برنامه‌نویس را دارد!&lt;/li&gt;
&lt;li&gt;داینامیک: این زبان‌ها معتقداند که هیچ تایپ سیستم‌ای نمی تواند ۱۰۰٪ گارانتی کند که کدهای‌مان بدون مشکل اجرا خواهند شد؛ و تنها راه حل موجود «تست» کردن کدهاست. پس با تاکید بر نگارش تست‌ها، این زبان‌ها عنوان می کنند که وجود تایپ چکر برای آن‌ها یک الزام نیست.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ابزارهای جانبی:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;استاتیک: ابزارهای جانبی می‌توانند کدهای استاتیک را آنالیز نمایند و اطلاعات زیادی بدست آورند؛ آن‌ها به کمک این اطلاعات قادر خواهند بود خدمات زیادی به برنامه‌نویسان ارائه کنند. مثلا IDE ها با آنالیز کدها، هنگامی که برنامه‌نویس مشغول نگارش است مدام او را در امر نوشتن راهنمایی می کنند و گزینه‌های مختلف را به او نشان می‌دهند. وجود چنین ابزارهایی زبان را برای استفاده در تیم‌های بزرگ آماده می‌کند.&lt;/li&gt;
&lt;li&gt;داینامیک: این یکی از این مواردی است که زبان‌های داینامیک جواب مناسبی برایش ندارند. اما نگرش توسعه در زبان‌های داینامیک به شکلی است که شاید وجود این ابزارها را کمتر حس کنند. زبان‌های داینامیک بر این باور هستند که یک نرم افزار بهتر است توسط تیم‌های کوچکِ چند نفری و در ارتباطی نزدیک با یکدیگر ساخته شود. یعنی از اساس با اینکه نرم افزار توسط تیم‌های بزرگ ساخته شود موافق نیستند. می توان هر نرم افزار بزرگ را جوری تقسیم کرد که قسمت‌های مختلف آن توسط تیم‌های کوچک ساخته شود.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;polymorphism&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;پ-لی-مورفیسم-چندریختی-polymorphism&#34;&gt;پُلی مورفیسم - چندریختی (Polymorphism)&lt;/h3&gt;

&lt;p&gt;این عبارت طولانی و کمی ترسناک است! و در اغلب متون فارسی (و حتی انگلیسی) موقع توضیح دادن آن بسیار شلوغ کاری شده است؛ در حالی که مفهوم پلی مورفیسم بسیار ساده است:&lt;/p&gt;

&lt;p&gt;«بکارگیری تایپ‌های مختلف، با روشی یکسان»&lt;/p&gt;

&lt;p&gt;مثال: عملگر جمع  +  را در نظر بگیرید. این عملگر می‌تواند دو متغیر از نوع int را باهم جمع کند. دو متغیر از نوع float را با هم جمع کند. و حتی در بعضی زبان ها می‌تواند دو متغیر string را نیز با هم جمع کند (به هم بچسباند).&lt;/p&gt;

&lt;p&gt;نکته اینجاست، تایپ‌های int، float، و string اساسا با یکدیگر متفاوت هستند. پس عملگر جمع چگونه به شکلی کاملا یکسان روی آن‌ها اجرا شده است؟ در اینجا پلی مورفیسم اتفاق افتاده است! عملگر جمع و تایپ‌های گفته شده، به گونه‌ای طراحی شده‌اند که قابلیت پلی مورفیسم داشته باشند.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;in-red&#34;&gt;
یک باور نادرست درباره پلی مورفیسم وجود دارد و آن این است که پلی مورفیسم فقط مختص زبان‌های شی‌گراست؛ این باور غلط مخصوصا در منابعی که زبان جاوا را آموزش می دهند بسیار شایع است؛ حتی کتب بسیار معتبر! دلیل‌اش این است که آن‌ها در حیطه‌ی خاصی سخن می‌گویند، اما خواننده ممکن است اشتباها برداشتی که می کند را برای تمامی زبان‌ها بسط دهد. در حالی که این باور ابدا درست نیست و مثلا حتی زبان‌های فانکشنال نیز پلی مورفیسم را ارايه می کنند. کلا پلی مورفیسم به شی‌گرا بودن یا نبود زبان ربطی ندارد!
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;شما نیز به عنوان برنامه‌نویس می‌توانید پلی مورفیسم را به کدهای خود اضافه کنید. برای این منظور، زبان‌های مختلف راه حل‌های گوناگونی را ارائه کرده اند:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;تک منظوره (Ad hoc polymorphism) : که همان سربارگذاری توابع (Function overloading) می‌باشد.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;مبتنی بر رابطه‌ی تایپ‌ها (Subtyping): ایجاد رابطه بین تایپ‌ها به اشکال گوناگونی صورت می‌گیرد. دو روش آشناتر، وراثت (Inheritance) و اینترفیس (Interface) ها هستند.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;مبتنی بر پارامتر (Parametric polymorphism) : که همان «جِنِریک‌»ها (Generics) می‌باشند.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;در ادامه یکی یکی این مفاهیم را شرح خواهیم داد&amp;hellip;&lt;/p&gt;

&lt;p&gt;اما ابتدا این نکته‌ی را به خاطر بسپارید : اینکه چه کاری می‌توان با یک تایپ انجام داد، در قالب توابعی که وابسته به آن تایپ هستند بیان می‌گردد:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;یا یک تایپ خودش دارای توابع داخلی است (متدها).&lt;/li&gt;
&lt;li&gt;یا توابعی خارج از تایپ وجود دارند که مخصوص کار با آن تایپ ساخته شده اند. (مثل تابع len در بعضی زبان‌ها که مخصوص تایپ آرایه است)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;adhoc-polymorphism&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;پلی-مورفیسم-تک-منظوره-ad-hoc-polymorphism&#34;&gt;پلی مورفیسم تک منظوره (Ad hoc polymorphism)&lt;/h3&gt;

&lt;p&gt;راه حلی برای ارائه پلی مورفیسم است که بر مفهوم «سربارگذاری توابع» بنا شده است.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;overloading&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;سربارگذاری-تابع-چیست-function-overloading&#34;&gt;سربارگذاری تابع چیست؟ (Function overloading)&lt;/h3&gt;

&lt;p&gt;یعنی یک تابع با نام مشخص داشته باشیم، که رفتار متفاوتی را با توجه نوع یا تعداد آرگومان‌های ورودی اش از خود بروز دهد.&lt;/p&gt;

&lt;p&gt;مثلا تابع ای داشته باشیم به اسم add که دو ورودی می‌گیرد. اگر این دو ورودی عدد صحیح بودند، آن‌ها را باهم جمع کند و حاصل جمع را برگرداند. ولی اگر ورودی‌ها رشته باشند، آن را به بهم بچسباند و حاصل را بگرداند:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function add(int a, int b) ⟹ int {
    return a + b;
}

function add(string a, string b) ⟹ string {
    return join(a, b);
}

add(10, 20);     ---&amp;gt; 30
add(&amp;quot;h&amp;quot;, &amp;quot;i&amp;quot;);    ---&amp;gt; &amp;quot;hi&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;یعنی با اینکه ما چند تایپ مختلف داریم، ولی توانستیم تمام آن ها را به شکل یکسانی بکار بگیریم (فقط تابع add). این یعنی پلی مورفیسم!&lt;/p&gt;

&lt;p&gt;دلیل استفاده از لفظ سربارگذاری نیز از مثال بالا مشخص است. یعنی ما چندین بار پشت سر هم تابعی به اسم add را تعریف کردیم و هر بار از روش متفاوتی در کدهای بدنه‌اش استفاده نمودیم.&lt;/p&gt;

&lt;p&gt;بعضی از زبان‌ها اعتقاد دارند که سربارگذاری توابع باعث پیچیده شدن کدها می‌شود، چرا که یک تابع ممکن است با توجه به ورودی هایش رفتار متفاوتی از خود نشان دهد و این قضیه باعث سردرگمی گردد. از همین رو بعضی از زبان‌ها قابلیت سربارگذاری را ارائه نمی‌کنند.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;subtyping-polymorphism&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;پلی-مورفیسم-مبتنی-بر-رابطه-ی-تایپ-ها-subtyping&#34;&gt;پلی مورفیسم مبتنی بر رابطه‌ی تایپ‌ها (Subtyping)&lt;/h3&gt;

&lt;p&gt;زبان‌ها هر کدام راه حل‌های مختلفی برای ایجاد رابطه‌های گوناگون در بین تایپ‌ها ارائه می کنند. دو شیوه‌ای که بیشتر اسم‌شان شنیده می‌شود «وراثت» و «اینترفیس»ها می‌باشند. در ادامه هر کدام را توضیح خواهیم داد؛ همچنین مزایا و معایب و فرق‌ها و تشابهات آن را نیز خواهیم گفت.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;inheritance&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;وراثت-inheritance&#34;&gt;وراثت (Inheritance)&lt;/h3&gt;

&lt;p&gt;راه حلی است برای ارائه پلی مورفیسم و «استفاده مجدد از کدها».&lt;/p&gt;

&lt;p&gt;در خیلی از متون (مخصوصا متون فارسی)، برای توضیح دادن وراثت در برنامه نویسی، آن را با وراثت در دنیای واقعی مقایسه می‌کنند؛ مثلا می‌گویند وراثت مانند این است که یک فرزند، چشم و ابرو و اخلاق والدین اش را به ارث ببرد! یعنی کلاسی به عنوان «کلاس فرزند» داریم که می تواند خصوصیاتی از «کلاس والد» را به ارث ببرد.&lt;/p&gt;

&lt;p&gt;توضیح دادن وراثت به روش بالا بسیار شبهه برانگیز است. وراثت در برنامه‌نویسی شکل دهنده‌ی یک رابطه‌ی منطقی بین تایپ‌ها است، در حالی که آن وراثتی که آن‌ها از آن سخن می‌گویند یک رابطه‌ی ژنیتیکی در عالم طبیعت است؛ این مدل حرف زدن درباره وراثت باعث ایجاد یک پیش زمینه‌ی فکری بسیار نامناسب در خواننده خواهد شد. از همین رو من به شکل دیگری وراثت را توضیح خواهم داد که به مفهوم آن در برنامه‌نویسی نزدیک‌تر است. حتی از الفاظی مانند کلاس فرزند یا والد نیز استفاده نخواهم کرد.&lt;/p&gt;

&lt;p&gt;وراثت در اغلب اوقات در زبان‌هایی حضور دارد که دارای ساختار «کلاس» هستند. سناریوی زیر را در نظر بگیرید:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;فرض کنید کلاسی داریم به اسم A، که مانند هر کلاس دیگری دارای یک سری فیلد و متد است.&lt;/li&gt;
&lt;li&gt;حالا قرار است کلاس دیگری بسازیم به نام B که قابلیت‌های موجود در کلاس A را «بسط» می دهد. این کلاس قرار است همان فیلدها و متدهای کلاس A را داشته باشد (چون قسمتی از خدماتش با A مشترک است)، به علاوه‌ی یک سری فیلد و متد جدید که مختص خودش است.&lt;/li&gt;
&lt;li&gt;در این حالت می‌توانیم تعیین کنیم کلاس B از A ارث ببرد. یعنی فیلد‌ها و متدهای «عمومیِ» کلاس A در کلاس B نیز حضور داشته باشند. اگر این کار را نکنیم، باید فیلدها و متدهای A را به صورت دستی در کلاس B کپی و پست کنیم!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;با استفاده از مکانیزم وراثت در سناریو بالا، چه مزیتی برای ما حاصل شده است؟&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;از کپی و پست کردن کدها دوری کردیم و به جایش کدهایی که از قبل در A وجود داشت را مورد «استفاده مجدد» قرار دادیم.&lt;/li&gt;
&lt;li&gt;همچنین بین کلاس B و A یک رابطه برقرار کردیم: یعنی می توانیم بگوییم B از جنسِ A است، چون حالا دیگر تمام امکانات A در B نیز وجود دارد.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;وقتی به کمک وراثت میان دو کلاس رابطه برقرار می‌کنیم، هر  تابعی که بتواند سوپر‌کلاس را به عنوان آرگومان بپذیرد، خواهد توانست که ساب‌کلاس هایش را نیز به عنوان آرگومان قبول کند. (چون هر دو از یک جنس تلقی می‌شوند).&lt;/p&gt;

&lt;p&gt;یعنی توابع می‌توانند یک سوپرکلاس و تمام ساب‌کلاس هایش را به شکل یکسانی به کار بگیرند. این یعنی وجود پلی مورفیسم!&lt;/p&gt;

&lt;p&gt;برای مثال یک کلاس برای موجودیت «خودرو» تعریف می‌کنیم به نام Car. این کلاس قابلیت‌های اولیه و بنیادی هر ماشینی را در خودش خواهد داشت: حرکت به جلو، حرکت به عقب، و توقف:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Superclass - Base class.

class Car {
    var wheels = 4;

    public function moveForward() ⟹ string {
        &amp;quot;Car is moving forward...&amp;quot;
    }

    public function moveBackward() ⟹ string {
        &amp;quot;Car is moving backward...&amp;quot;
    }

    public function stop () ⟹ string {
        &amp;quot;Car is stopping!&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;حالا می‌خواهیم یک کلاس دیگر برای ماشین فورد طراحی کنیم. از آنجایی که فورد هم یک ماشین است، پس به تمام قابلیت‌های بنادی مانند حرکت به جلو و عقب نیاز خواهد داشت. به جای اینکه ما دوباره این‌ها را از اول در فورد تایپ کنیم، کافیست اعلام نماییم که کلاس Ford از Car ارث می‌برد:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Subclass
class Ford extends Car {
    public function cooler() ⟹ string {
        &amp;quot;Ford&#39;s cooler is started!&amp;quot;
    }
}

f = new Ford();

f.moveForward();    ---&amp;gt; &amp;quot;Car is moving forward...&amp;quot;
f.cooler();    ---&amp;gt; &amp;quot;Ford&#39;s cooler is started!&amp;quot;
f.stop();    ---&amp;gt; &amp;quot;Car is stopping!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;کلاس Ford البته خودش یک تابع مجزا به نام cooler تعریف کرده است که در Car موجود نیست. ایرادی ندارد، ساب‌کلاس‌ها می‌توانند توابع خاص خودشان را داشته باشند و به این ترتیب امکانات سوپرکلاس را بسط دهند. اگر تابع cooler از کلاس Ford را صدا بزنیم، این تابع از داخل همین کلاس اجرا خواهد شد. اما اگر تابع moveForward را روی کلاس Ford صدا کنیم، چون Ford خودش فاقد این تابع است، moveForward به کمک سوپرکلاس Car اجرا می شود.&lt;/p&gt;

&lt;p&gt;حالا فرض کنید که می‌خواهیم یک کلاس دیگر برای ماشین تویوتا طراحی کنیم. کلاس تویوتا هم می تواند مثل فورد از Car ارث ببرد:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Subclass
class Toyota extends Car {
    public function radio() ⟹ string {
        &amp;quot;Toyota&#39;s radio is turned on!&amp;quot;
    }
    public function break () ⟹ string {
        &amp;quot;Toyota is stopping!&amp;quot;
    }
}

t = new Toyota();

t.moveForward();    ---&amp;gt; &amp;quot;Car is moving forward...&amp;quot;
t.radio();    ---&amp;gt; &amp;quot;Toyota&#39;s radio is turned on!&amp;quot;
t.stop();    ---&amp;gt; &amp;quot;Toyota is stopping!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;کلاس Toyota نیز از Car ارث برده است و همانند Ford برای خودش یک تابع اضافه به نام radio نیز دارد. اما این کلاس یک فرق کوچک با کلاس فورد دارد و آن این است که کلاس تویوتا تابع stop که در Car موجود بوده را به روش متفاوتی مجددا تعریف کرده است. حالا اگر ما تابع stop را روی Toyota صدا کنیم، به جای اینکه مثل Ford این تابع از Car فراخانی شود، تابع stop  مستقیما از خود Toyota اجرا می گردد.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;overriding&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;سایه-اندازی-overriding-چیست&#34;&gt;سایه اندازی (Overriding) چیست؟&lt;/h3&gt;

&lt;p&gt;یعنی ساب‌کلاس، تابعی از سوپرکلاس‌اش را مجددا تعریف کند؛ با این هدف که در آن تابع پیاده‌سازی خاص خودش را ارائه نماید. بدین ترتیب تابع موجود در ساب‌کلاس، روی تابع موجود در سوپرکلاس اش «سایه افکنده است»! از همین رو تعریف موجود در ساب‌کلاس از ارجحیت بالاتری برخوردار خواهند شد.&lt;/p&gt;

&lt;p&gt;تا اینجا یک جمع بندی از مکانیزم وراثت داشته باشیم:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;با وراثت، یک ساب‌کلاس می‌تواند قابلیت‌های سوپرکلاس را بسط دهد.&lt;/li&gt;
&lt;li&gt;با وراثت، بین سوپرکلاس و ساب‌کلاس یک رابطه‌ی سلسله مرتبه‌ای ایجاد می‌شود. از همین رو ساب‌کلاس هم‌جنسِ سوپرکلاس شناخته خواهد شد.&lt;/li&gt;
&lt;li&gt;تمام عناصر «عمومی» که در سوپرکلاس تعریف شده باشد، در ساب‌کلاس نیز در دسترس قرار خواهند گرفت.&lt;/li&gt;
&lt;li&gt;ساب‌کلاس می‌تواند با توجه به نیازهایش، روی تعاریف مختلف سوپرکلاس «سایه اندازی» کند.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;تا اینجا همه‌چیز خوب بود&amp;hellip; حالا برسیم به روی تاریک وراثت!&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;bad-inheritance&#34;&gt;&lt;/a&gt;
وراثت، یکی از بحث برانگیزترین مفاهیم برنامه‌نویسی است؛ این مکانیزم باید با دقت بسیار بالا مورد استفاده قرار گیرد چرا که می‌تواند به سرعت کدهایتان را پیچیده کند. از همین رو وراثت مخالفان زیادی دارد و تقریبا همه بر این باور هستند که باید تا جایی که امکان دارد از «کامپوزیشن به جای وراثت» استفاده کرد. (کامپوزیشن را در ادامه‌ی مطلب توضیح خواهیم داد.)&lt;/p&gt;

&lt;h3 id=&#34;چرا-وراثت-مورد-انتقاد-است&#34;&gt;چرا وراثت مورد انتقاد است؟&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;وراثت یک سیستم درختی، سلسله مرتبه‌ای، و از بالا به پایین را بین تایپ‌ها ایجاد می کند. مثلا: ماشین &amp;gt; تویوتا &amp;gt; پرادو &amp;gt; &amp;hellip;. دیزاین کدها به این صورت انعطاف پذیر نخواهد بود. فرض کنید کلاسی داشته باشیم به نام «دنده»، که کلاس ماشین به قابلیت‌های آن نیاز دارد. آیا درست است که ماشین از دنده ارث ببرد؟ آیا ماشین زیر شاخه‌ی دنده است؟ آیا دنده زیر شاخه‌ی ماشین است؟ (دنده جزیی از ماشین است، اما زیرگونه‌ی ماشین نیست!)&lt;/li&gt;
&lt;li&gt;همیشه عناصر سوپرکلاس ارجحیت دارند مگر اینکه در ساب‌کلاس صریحا روی آن‌ها سایه اندازی شود.&lt;/li&gt;
&lt;li&gt;تمام عناصر عمومی از سوپرکلاس وارد ساب‌کلاس می‌شوند. این در حالیست که ساب‌کلاس ممکن است به همه‌ی آن‌ها نیاز نداشته باشد. ولی این عناصر در هر صورت جزو API های عمومی ساب‌کلاس نیز قلمداد خواهند شد. این قضیه یک مشکل اساسی در طراحی کدهاست و «کپسوله سازی» را خدشه دار می کند.&lt;/li&gt;
&lt;li&gt;با وجود مکانیزم سایه اندازی، درک اینکه توابع دقیقا از کدام یکی از کلاس‌ها (سوپرکلاس یا ساب‌کلاس) اجرا میشوند سخت تر خواهد شد.&lt;/li&gt;
&lt;li&gt;وقتی  مکانیزم سایه‌گذاری با مکانیزم سربارگذاری همراه شود، دیگر یک آش شله قلمکار پدید می‌آید! حالا نه تنها باید دنبال این باشیم که تابع از کدام کلاس اجرا شده، باید به این هم دقت کنیم که کدام «نسخه» از تابع قرار است اجرا شود (به دلیل سربارگذاری)&lt;/li&gt;
&lt;li&gt;وراثت، تفکیک بین تایپ‌ها را مشکل تر می کند.&lt;/li&gt;
&lt;li&gt;همه‌ی این‌ها به کنار، قضیه وقتی جالب می‌شود که بدانید زبان‌هایی مانند سی‌پلاس‌پلاس از وراثت چندگانه پشتیبانی می‌کنند! یعنی هر کلاس می تواند از چندین کلاس دیگر ارث ببرد. به عبارتی تمام مشکلاتی که در بالا گفتیم، چند برابر خواهند شد.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;زبان‌هایی مانند جاوا و سی‌شارپ، برای محدود کردن تاثیرات منفی وراثت، قابلیت وراثت چندگانه را در زبان نگنجانده‌اند. زبان‌هایی مانند گولنگ یا راست نیز به طور کل وراثت را در زبان قرار نداده اند و عطایش را به لقایش بخشیده اند!&lt;/p&gt;

&lt;p&gt;متاسفانه وراثت سال‌هاست که در زبان‌های شی‌گرا مانند سی‌پلاس‌پلاس و جاوا و پایتون و پی‌اچ‌پی‌ و غیره پخش شده و نمی‌شود به این راحتی از آن دور ماند. اما اگر به ذهن‌تان رسید قسمتی از «کدهای جدیدتان» را با اتکا به مکانیزم وراثت بنویسید، همیشه سه مورد زیر را در نظر داشته باشد:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;تا جایی که امکان دارد از وراثت استفاده نکنید.&lt;/li&gt;
&lt;li&gt;تا جایی که امکان دارد از وراثت استفاده نکنید.&lt;/li&gt;
&lt;li&gt;تا جایی که امکان دارد از وراثت استفاده نکنید.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;good-inheritance&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;وراثت-در-چه-زمانی-سودمند-و-بی-خطر-است&#34;&gt;وراثت در چه زمانی سودمند و بی‌خطر است؟&lt;/h3&gt;

&lt;p&gt;در زمانی که شرایط زیر دقیقا برقرار باشد:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;رابطه‌ی is-a بین کلاس‌ها برقرار باشد. یعنی از خود سوال کنید که آیا ساب‌کلاس، «از جنس» یا «از گونه‌ی» سوپر‌کلاس هست یا خیر. مثلا آیا تویوتا یک ماشین است؟ بله؛ آیا مرغابی یک پرنده است؟ بله؛ آیا قهوه یک نوشیدنی است؟ بله؛ آیا کیبورد یک لپ‌تاپ است؟ خیر؛ آیا آهن یک میخ است؟ خیر؛ اگر چنین رابطه‌ای برقرار نبود بهتر است به جای از وراثت از اینترفیس‌ها استفاده کنید (که در ادامه آن‌ها را توضیح خواهیم داد.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ساب‌کلاس واقعا به «تمام» API های عمومی سوپرکلاس نیازمند باشد. اگر حتی یکی از عناصر سوپرکلاس برای ساب‌کلاس بی‌مصرف بود، بهتر است به جای وراثت از اینترفیس‌ها استفاده نمایید.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;اگر ساب‌کلاس فقط یکی دو مورد از عناصر سوپرکلاس را سایه اندازی کند ایرادی ندارد؛ اما اگر بیشتر از این تعداد سایه اندازی کند، یعنی در حقیقت به پیاده‌سازی‌های موجود در سوپرکلاس نیاز ندارد و بیشتر امضای متدها برایش مهم بوده است. در این شرایط بهتر است به جای وراثت از اینترفیس‌ها استفاده کنید.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;همانطور که می‌بینید، وراثت مانند آتش سودمند است، اما به همان اندازه نیز خطرناک است. از همین رو توصیه رایج در دنیای برنامه‌نویسی این است که تا حد امکان، راه حل دیگری را انتخاب کنید:
&lt;span class=&#34;in-red&#34;&gt;
استفاده از کامپوزیشن (Composition) به جای وراثت!
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;composition&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;کامپوزیشن-چیست&#34;&gt;کامپوزیشن چیست؟&lt;/h3&gt;

&lt;p&gt;معنی انگلیسی این واژه این است: ترکیب یک سری از عناصر که باعث ایجاد موجودیت جدیدی می‌شود. فرضا اگر بگوییم «کامپوزیشن این غذا چیست؟»، در حقیقت منظورمان این است که «این غذا از چه ترکیباتی ساخته شده؟»؛ برنج، روغن، نمک&amp;hellip;&lt;/p&gt;

&lt;p&gt;کامپوزیشن در مباحث مربوط به پلی مورفیسم، در حقیقت یک نوع «ایده یا نگرش» است. ایده یا نگرشی که می تواند به شیوه‌های مختلفی اجرایی شود. یعنی کامپوزیشن مانند وراثت یک مکانیزم مشخص نیست. یک نوع «نگاه» و طرز فکر است که می توان با مکانیزم‌های مختلفی به آن رسید:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;دیدگاه وراثت به پلی مورفیسم، جوابِ این سوال است: این تایپ «از چه جنس» ای است.&lt;/li&gt;
&lt;li&gt;دیدگاه کامپوزیشن به پلی مورفیسم، جوابِ این سوال است: این تایپ قادر به انجام «چه کارهایی» است.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;کامپوزیشن یعنی ما به رفتارهای تایپ توجه کنیم، نه خصوصیات آن. از همین رو در کامپوزیشن لازم نیست مانند وراثت تایپ‌ها از نظر منطقی به یکدیگر ربط داشته باشند؛ تا زمانی که تایپ‌ها دارای رفتار مورد نظر ما باشند، ما می توانیم پلی مورفیسم را ایجاد کنیم.&lt;/p&gt;

&lt;p&gt;فرضا «حرکت رو به جلو»، یک «عمل» است:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;انسان می تواند رو به جلو حرکت کند.&lt;/li&gt;
&lt;li&gt;دانشجو می تواند رو به جلو حرکت کند.&lt;/li&gt;
&lt;li&gt;موتور می تواند رو به جلو حرکت کند.&lt;/li&gt;
&lt;li&gt;دوچرخه می تواند رو به جلو حرکت کند.&lt;/li&gt;
&lt;li&gt;ماشین می تواند رو به جلو حرکت کند.&lt;/li&gt;
&lt;li&gt;گربه می تواند رو به جلو حرکت کند.&lt;/li&gt;
&lt;li&gt;کبوتر می تواند رو به جلو حرکت کند.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;همانطور که می‌بینید تمام این‌ها قادر هستند «عمل» ای که از آن‌ها انتظار داریم را اجرایی کنند؛ یعنی «رابطه‌ی» بین این تایپ‌ها بر مبنای اشتراک در اعمالی که می‌توانند انجام دهند استوار است؛ حتی با اینکه ممکن است هیچ ربطی به هم نداشته باشند: آیا موتور از جنس انسان است؟ آیا گربه از جنس پرنده است؟ چگونه می‌خواستید چنین رابطه‌ی را با وراثت داشته باشید؟&lt;/p&gt;

&lt;p&gt;اما با کامپوزیشن می توانیم بین این تایپ‌ها ارتباط ایجاد کنیم. وقتی این ارتباط را ایجاد کردیم، درهای پلی مورفیسم به روی ما باز می‌گردد! فرضا می‌توانیم یک تابع داشته باشیم که برای آرگومان اش چنین چیزی را تعریف کرده ایم: «تایپ این آرگومان، برابر باشد با تمام تایپ‌هایی که از قابلیتِ حرکت رو جلو برخوردار هستند». از این به بعد این تابع می‌تواند پذیرای تمام تایپ‌هایی باشد که دارای قابلیتِ حرکت رو به جلو هستند؛ انسان، موتور، ماشین، گربه، &amp;hellip;&lt;/p&gt;

&lt;p&gt;یعنی توابع می‌توانند به کمک ارتباطی که کامپوزیشن در بین تایپ‌ها پدید آورده، تمام آن تایپ‌ها را به شکل یکسانی به کار بگیرند. این یعنی وجود پلی مورفیسم!&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;impl-composition&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;اجرایی-نمودن-کامپوزیشن&#34;&gt;اجرایی نمودن کامپوزیشن&lt;/h3&gt;

&lt;p&gt;همانطور که گفتیم کامپوزیشن یک نوع نگرش است، و ممکن است به شیوه‌های گوناگونی اجرایی گردد. ما دو روش که محبوبیت بیشتری دارند را توضیح می دهیم:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;اگر کلاس B به قابلیت‌های موجود در کلاس A نیاز داشت، لازم نیست از آن ارث بگیرد. می‌تواند یک ارجاع از کلاس A را در یکی از فیلدهای «خصوصی» اش قرار دهد و هر موقع به خدمات A نیاز داشت، به آن فیلد رجوع کند.&lt;/li&gt;
&lt;li&gt;طراحی کدها حولِ محور اینترفیس‌ها&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;در این قسمت، مورد اول را با یک مثال توضیح خواهیم، و در قسمت بعد به اینترفیس‌ها خواهیم پرداخت.&lt;/p&gt;

&lt;p&gt;برای مثال، بیایید همان کلاس‌های Car و Ford را به شکل دیگری به هم ربط دهیم:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Car {
    var wheels = 4;

    public function moveForward() ⟹ string {
        &amp;quot;Car is moving forward...&amp;quot;
    }

    public function moveBackward() ⟹ string {
        &amp;quot;Car is moving backward...&amp;quot;
    }

    public function stop () ⟹ string {
        &amp;quot;Car is stopping!&amp;quot;
    }
}

class Ford {
    private var car = new Car();                           ---&amp;gt;   a private reference to Car.

    public function cooler() ⟹ string {
        &amp;quot;Ford&#39;s cooler is started!&amp;quot;
    }
    public function moveForward() ⟹ string {
        this.car.moveForward();
    }
    public function moveBackward() ⟹ string {
        this.car.moveBackward();
    }
    public function stop () ⟹ string {
        this.car.stop();
    }
}


f = new Ford();

f.moveForward();    ---&amp;gt; &amp;quot;Car is moving forward...&amp;quot;
f.cooler();    ---&amp;gt; &amp;quot;Ford&#39;s cooler is started!&amp;quot;
f.stop();    ---&amp;gt; &amp;quot;Car is stopping!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;به همین سادگی! با توکارسازی، خیلی از مشکلات وراثت حل خواهد شد:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;با اینکه باز هم یک ساختار شبه درختی وجود دارد، اما عمق شاخه‌های درخت کم خواهد شد. همچنین سلسله مراتب از پایین به بالا است؛ یعنی کلاس فرزند در اینجا در اولویت قرار دارد.&lt;/li&gt;
&lt;li&gt;کاملا مشخص است تابعی که صدا میزنیم مال کدام کلاس است.&lt;/li&gt;
&lt;li&gt;API عمومی سوپرکلاس در ساب‌کلاس در دسترس نیست و کپسوله سازی کاملا حفظ شده است.&lt;/li&gt;
&lt;li&gt;تایپ‌ها کاملا از هم تفکیک شده‌اند.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;این راه ساده است؛ قابل درک است؛ و در خیلی اوقات کار راه انداز است! اما یک مشکل اساسی دارد: درست است که در روش بالا «استفاده‌ی مجدد از کدها» صورت پذیرفته ، اما از پلی مورفیسم خبری نیست! از نظر تایپ سیستم، Car و Ford به هم ربط داده نشده‌اند. بنابراین اگر یک تابع آرگومانی از جنس Car را بپذیرد، نمی‌تواند آرگومانی از جنس Ford را پذیرا باشد.&lt;/p&gt;

&lt;p&gt;اینجاست که اینترفیس‌ها وارد می‌شوند!&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;interface&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;اینترفیس-interface&#34;&gt;اینترفیس (Interface)&lt;/h3&gt;

&lt;p&gt;اینترفیس یکی از روش‌های ارائه‌ی پلی مورفیسم است که بر ایده‌ی کامپوزیشن بنا شده. به زبان ساده، اینترفیس مشابه یک «عهدنامه» است.&lt;/p&gt;

&lt;p&gt;وقتی یک اینترفیس تعریف می‌کنیم، یعنی یک عهدنامه برای تایپ‌ها تعریف کرده‌ایم. در این عهدنامه، رفتارهایی که از تایپ‌ها انتظار داریم را لیست خواهیم کرد. هر تایپی که خودش را مشمول این عهدنامه نماید، باید تمام انتظارات آن را پیاده‌سازی کند. درست همانند عهدنامه‌های سازمان ملل، که کشورهای مختلف در صورت موافقت با آن، باید تمام شرایط آن را اجرایی نمایند!&lt;/p&gt;

&lt;p&gt;«شرایط مورد انتظار» را به کمک توابع عنوان می‌کنیم، که به این شکل در یک اینترفیس لحاظ می‌شوند:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;interface Sporter {
    function start() ⟹ string;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;در مثال بالا یک اینترفیس با عنوان «ورزشکار» (Sporter) ساخته‌ایم. درون این اینترفیس یک تابع قرار داده ایم؛ یعنی تمام تایپ‌هایی که می‌خواهد این اینترفیس را قبول کنند باید تابعی به اسم start داشته باشند. اگر دقت کنید، فقط نام تابع را نوشته‌ایم و آن را پیاده‌سازی نکردیم ؛ چون هر تایپی ممکن است به شکل متفاوتی تابع start را پیاده سازی نماید. برای ما فقط مهم این است که تایپ ها حتما این تابع را تعریف کرده باشند، حالا اینکه چگونه آن را پیاده سازی کنند ربطی به اینترفیس ندارد.&lt;/p&gt;

&lt;p&gt;خب حالا که چی؟ اینترفیس را تعریف کردیم که چه شود؟ تایپ‌ها اصلا برای چه باید خود را ملزم به یک اینترفیس نمایند؟ چه سودی برای ما حاصل می‌شود؟ بگذارید این موضوع را با یک مثال توضیح دهیم&amp;hellip;&lt;/p&gt;

&lt;p&gt;فرض کنید سه ورزشکار داریم: بوکسور، دونده، شناگر&lt;/p&gt;

&lt;p&gt;اگر داور داد بزند «شروع»، چه اتفاقی میفتد؟&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;بوکسور، مبارزه را شروع می‌کند.&lt;/li&gt;
&lt;li&gt;دونده، دویدن را شروع می‌کند.&lt;/li&gt;
&lt;li&gt;شناگر، شیرجه می‌زند!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;حالا قصد داریم هر کدام از این‌ها را در قالب یک تایپ تعریف کنیم (مثلا به کمک کلاس‌ها). چیزی شبیه زیر را خواهیم داشت:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Boxer {
    function fight() ⟹ string {
        &amp;quot;Lets fight!&amp;quot;;
    }
}

class Runner {
    function run() ⟹ string {
        &amp;quot;Lets run!&amp;quot;;
    }
}

class Swimmer {
    function dive() ⟹ string {
        &amp;quot;Lets dive!&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;حالا می‌خواهیم تابعی داشته باشیم که اگر تایپ‌های مربوط به ورزشکاران مختلف را به آن ارسال کردیم، آن تابع عمل شروع را روی آن‌ها اعمال کند. اما ما می‌دانیم که در یک زبان استاتیک، باید تایپ آرگومان‌های یک تابع را مشخص نماییم؛ پس اگر این تابع آرگومانی از تایپ Boxer را بگیرد، دیگر نمی‌تواند آرگومانی از تایپ Runner را بپذیرد. حالا باید چکار کنیم؟ مجبور هستیم برای تک تک این تایپ‌ها، توابع جداگانه تعریف کنیم:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function start_boxing(Boxer) ⟹ string {
    Boxer.fight();
}

function start_running(Runner) ⟹ string {
    Runner.run();
}

function start_swimming(Swimmer) ⟹ string {
    Swimmer.dive();
}

b = new Boxer();
r = new Runner();
s = new Swimmer();

start_boxing(b);
start_running(r);
start_swimming(s);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;عملیات شروع برای تمام تایپ‌های ورزشکاران لازم است. حالا اگر ما به جای سه تا ورزشکار، ۲۰ تا ورزشکار داشتیم باید چکار می‌کردیم؟ یعنی باید ۲۰ تابع مختلف برای تک تک تایپ‌ها می‌ساختیم؟ مسلما راه بهتری وجود دارد: اینترفیس‌ها.&lt;/p&gt;

&lt;p&gt;پس یک اینترفیس تعریف می‌کنیم (مانند Sporter که در بالاتر تعریف کردیم)، و در آن اینترفیس مشخص می کنیم که تمام تایپ‌ها باید تابعی به نام start داشته باشند. حالا تمام تایپ‌های مربوط به ورزشکاران مختلف را ملزم به رعایت این اینترفیس می نماییم:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Boxer implements Sporter {
    function start() ⟹ string {
        this.fight();
    }
    function fight() ⟹ string {
        &amp;quot;Lets fight!&amp;quot;;
    }
}

class Runner implements Sporter {
    function start() ⟹ string {
        this.run();
    }
    function run() ⟹ string {
        &amp;quot;Lets run!&amp;quot;;
    }
}

class Swimmer implements Sporter {
    function start() ⟹ string {
        this.dive();
    }
    function dive() ⟹ string {
        &amp;quot;Lets dive!&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;حالا دیگر لازم نیست برای تک تک تایپ‌های مربوط به ورزشکاران یک تابع شروع جداگانه داشته باشیم، فقط کافیست یک تابع بسازیم؛ با این تفاوت که آرگومان آن تابع را برابر با تایپ اینترفیس قرار می‌دهیم! هر تایپی که از این اینترفیس تبعیت کرده باشد، می تواند به جای آن اینترفیس به تابع فرستاده شود:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function start_match(Sporter) ⟹ string {
    Sporter.start();
}

b = new Boxer();
r = new Runner();
s = new Swimmer();

start_match(b);
start_match(r);
start_match(s);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;یعنی با اینکه ما چند تایپ مختلف داریم، ولی توانستیم تمام آن ها را به شکل یکسانی بکار بگیریم (فقط تابع start_match). این یعنی پلی مورفیسم!&lt;/p&gt;

&lt;p&gt;حالا اگر ما ۱۰۰ تایپ مختلف دیگر نیز برای ورزشکاران داشته باشیم، تا زمانی که آن‌ها از اینترفیس Sporter تبعیت کنند، می‌توانند توسط همین یک تابع مورد استفاده قرار بگیرند. لازم نیست ۱۰۰ تابع جدا برای هر کدام تعریف کنیم. این از زیبایی اینترفیس هاست!&lt;/p&gt;

&lt;p&gt;اینترفیس از مفاهیم بسیار حیاتی در زبان‌های برنامه‌نویسی است؛ و در اکثر زبان‌های برنامه‌نویسی، پلی مورفیسم با محوریت اینترفیس ارائه شده است. از همین رو مطالعه و تمرینِ اینترفیس ‌ها شدیدا توصیه می‌گردد.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;structural-type-system&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;تایپ-سیستم-مبتنی-بر-ساختار-structural-type-system&#34;&gt;تایپ سیستم مبتنی بر ساختار (Structural type system)&lt;/h3&gt;

&lt;p&gt;گروهی از تایپ سیستم‌ها هستند که برای سنجش هماهنگی و برابریِ تایپ‌ها، ساختار و بدنه‌ی تایپ‌ها را پالایش می‌نمایند. زبان‌هایی مانند پایتون و گولنگ از بارزترین نمونه‌های بکارگیری چنین تایپ سیستم‌ای هستند.&lt;/p&gt;

&lt;p&gt;وقتی می‌گوییم تایپ سیستم ساختار و بدنه‌ی تایپ‌ها را پالایش می کند منظورمان چیست؟&lt;/p&gt;

&lt;p&gt;یعنی تایپ سیستم، تایپ ها را از نظر اینکه چه رفتارهایی را پیاده‌سازی کرده‌اند مورد سنجش قرار می دهد.&lt;/p&gt;

&lt;p&gt;مثال:&lt;/p&gt;

&lt;p&gt;تایپی داریم که ۵ عمل مختلف را توسط ۵ تابع پیاده سازی کرده است. اگر تایپ دیگری وجود داشته باشد که عینا دارای این ۵ پنج تابع باشد (از نظر اسم و امضا)، اینطور قلمداد می‌شود که دو تایپ با هم هماهنگ هستند. (حتی اگر این دو تایپ هم اسم نباشند)&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;duck-typing&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;داک-تایپینگ-duck-typing&#34;&gt;داک تایپینگ (Duck typing)&lt;/h3&gt;

&lt;p&gt;اگر یک زبان داینامیک باشد، می‌تواند تایپ سیستمِ مبتنی بر ساختار را در «زمان اجرا» اعمال نماید. معروف ترین زبانی که این عمل را انجام می‌دهد پایتون است. واژه‌ی «داک تایپ» نیز از جامعه‌ی کاربری پایتون به بیرون درز کرده است.&lt;/p&gt;

&lt;p&gt;واژه‌ی داک تایپینگ از کجا آمده؟&lt;/p&gt;

&lt;p&gt;Duck به معنی اردک است! این قضیه به جواب این سوال برمی‌گردد که «اردک چیست؟».&lt;/p&gt;

&lt;p&gt;می‌توانیم پاسخ خود را با این استدلال عنوان کنیم: اگر یک پرنده مثل اردک راه رفت، مثل اردک بال زد، مثل اردک غذا خورد، مثل اردک کواک کواک کرد، &amp;hellip; پس می‌توانیم اینطور فرض کنیم که این پرنده یک اردک است!&lt;/p&gt;

&lt;p&gt;واضح است که «اردک» فقط یک تشبیه بوده است؛ پیام اصلی این است که شناسایی و هماهنگی تایپ‌ها از روی رفتار و اعمالی که قادر به انجامش هستند انجام شود. (به پیروی از قضیه کامپوزیشن و اینترفیس‌ها و &amp;hellip;)&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;parametric-polymorphism&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;پلی-مورفیسم-مبتنی-بر-پارامتر-parametric-polymorphism&#34;&gt;پلی مورفیسم مبتنی بر پارامتر (Parametric polymorphism)&lt;/h3&gt;

&lt;p&gt;راه حلی برای ارائه پلی مورفیسم است که بر مفهوم «جنریک»‌ها بنا شده است. این آخرین شیوه‌ی ارائه پلی مورفیسم است که ما آن را در این نوشته مورد بحث قرار خواهیم داد.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;generic&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;جنریک-generic&#34;&gt;جنریک (Generic)&lt;/h3&gt;

&lt;p&gt;جنریک، قابلیت ایست که یک زبان استاتیک را قادر می‌سازد پلی مورفیسم و امکان ساخت کامپوننت‌های چند منظوره را با توسل به مکانیزم «جای‌گذاری تایپ» ارائه کند. بهترین کار این است که جنریک را با مثال توضیح دهیم.&lt;/p&gt;

&lt;p&gt;مثال: ساخت تابع echo&lt;/p&gt;

&lt;p&gt;در ترمینال‌های یونیکس دستوری وجود دارد به نام echo که آرگومانی که به آن ارسال کنیم را عینا برگشت می‌دهد. مثلا اگر بنویسیم echo &amp;ldquo;hi&amp;rdquo; ، مقدار &amp;ldquo;hi&amp;rdquo; برگشت داده خواهد. ما می‌خواهیم در این مثال تابعی شبیه این را پیاده سازی کنیم.&lt;/p&gt;

&lt;p&gt;این اولین راه حلی است که ممکن است برای پیاده سازی این تابع به ذهن ما برسد:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function echo( int arg ) ⟹ int{
    return arg;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;این تابع یک مقدار int می‌گیرد و عینا همان مقدار int را برگشت می‌دهد. حالا چه اتفاقی میفتد اگر ما بخواهیم آرگومان‌هایی از تایپ float یا string را به تابع echo ارسال کنیم؟ مسلما تایپ چکر به ما ایراد خواهد گرفت و اجازه همچین کاری را به ما نخواهد داد. یک راه حل این است که برای هر تایپ، یک تابع echo مخصوص بسازیم:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function echoInt( int arg ) ⟹ int{
    return arg;
}

function echoFloat( float arg ) ⟹ float {
    return arg;
}

function echoString( string arg ) ⟹ string {
    return arg;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;به فرض که این کار را هم کردیم؛ بقیه تایپ‌ها چه می‌شوند؟ آیا باید برای هر تایپ‌ای یک تابع echo مجزا بسازیم؟ این کار نه عملی است، و نه عاقلانه. به جایش می‌توانیم تابع echo را به کمک جنریک‌ها بازنویسی کنیم:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function echo&amp;lt;T&amp;gt;( T arg)  ⟹ T {
    return arg;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ممکن است در نگاه اول این تابع کمی عجیب به نظر برسد؛ عبارت &amp;lt; T &amp;gt; که درکد بالا نوشته ایم چه کاره است؟ (حواستان باشد این‌ها شبه کد هستند و شاید در زبان مورد علاقه شما جنریک‌ها به شکل دیگری ظاهر شوند):&lt;/p&gt;

&lt;p&gt;عبارت &amp;lt; &amp;gt; یک «جا نگه دار» است؛ این علامت‌ها عنوان می‌دارند که قرار است در موقع کامپایل، در این نقطه از کد، تایپ دیگری جایگزین شود (جای‌گذاری تایپ)&lt;/p&gt;

&lt;p&gt;حرف T که میان «جا نگه دار» آمده است را «متغیرِ تایپ» خطاب می‌کنیم. همانطور که یک متغیر معمولی می تواند یک «مقدار» را در خود نگه دارد، متغیرهای تایپ نیز گونه‌ی خاصی از متغیرها هستند که می‌توانند یک «تایپ» را در خود نگه دارند.&lt;/p&gt;

&lt;p&gt;البته T فقط یک اسم دلخواه است که برای متغیرِ تایپ تعیین کرده‌ایم. می‌توانستیم هر حرف دیگری هم بجایش بنویسیم. هنگام استفاده از تابعی مانند تابع بالا، تایپ‌هایی که قرار است در هنگام کامپایل جایگزین شوند در «متغیرهای تایپ» نگه داری خواهند شد.&lt;/p&gt;

&lt;p&gt;حالا که با «جا نگه دار» و «متغیرِ تایپ» آشنا شدید، می توانیم طرز استفاده از تابع بالا را شرح دهیم:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo&amp;lt;int&amp;gt;(12);    ---&amp;gt; 12
echo&amp;lt;float&amp;gt;(3.14);    ---&amp;gt; 3.14
echo&amp;lt;string&amp;gt;(&amp;quot;hi&amp;quot;);    ---&amp;gt; &amp;quot;hi&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;در کد بالا، ما به کمک جنریک توانستیم تابع echo را برای چندین تایپ مختلف استفاده کنیم. به شیوه‌ای که تابع را فراخانی کردیم توجه کنید؛ دقت کنید که چگونه برای تابع توضیح دادیم که آرگومانی که قرار است برایش بفرستیم از چه تایپی خواهد بود.&lt;/p&gt;

&lt;p&gt;چون موقع تعریف تابع echo، هم تایپ آرگومان ورودی و هم تایپ نتیجه‌ی خروجی را همنام انتخاب کرده بودیم (به کمک متغیرِ تایپِ T)، یعنی ورودی و خروجی تابع را از یک تایپ اعلام کرده ایم. (اگر تابع int بگیرد، int تحویل خواهد داد).&lt;/p&gt;

&lt;p&gt;آیا برای نام‌گذاری متغیرهای تایپ قوانین خاصی وجود دارد؟&lt;/p&gt;

&lt;p&gt;خیر. قانون خاصی وجود ندارد. اما عُرف این است که اسامی زیر را برای اهدف متناظرشان انتخاب کنیم:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;اگر هدف یک تایپ مستقل و معمولی بود، از T استفاده کنید.&lt;/li&gt;
&lt;li&gt;اگر هدف تایپِ یک عنصر بود (مثلا عناصر یک آرایه)، از E استفاده کنید.&lt;/li&gt;
&lt;li&gt;اگر هدف تایپِ یک کلید بود (کلید مربوط به ساختاری مثل هَش‌مَپ‌ها)، از K استفاده کنید.&lt;/li&gt;
&lt;li&gt;اگر هدف تایپِ یک مقدار بود (مقدار متناظر کلیدهای یک هَش‌مَپ‌ )، از V استفاده کنید.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;generic-universal&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;قابل-پیش-بینی-نبودن-تایپ-های-جایگزین-در-جنریک&#34;&gt;قابل پیش‌بینی نبودن تایپ‌های جایگزین در جنریک&lt;/h3&gt;

&lt;p&gt;تا زمانی که یک تابع جنریک را صدا نزنیم، نمی دانیم تایپ‌هایی که قرار است جایگزین شوند ممکن است چه باشند. یعنی هنگام تعریف تابع، نمی توانیم فرض را بر این بگذاریم که این تابع قرار است فقط تایپ‌های int و float را جای‌گذاری کند؛ باید در نظر داشته باشیم که هر تایپ دیگری هم ممکن است به تابع وارد شود. بنابراین در بدنه‌ی تابع، نباید «متغیرهای تایپ» را به گونه به کار ببریم که رفتار مربوط به تایپ خاصی را انتظار داشته باشند.&lt;/p&gt;

&lt;p&gt;مثلا نمی توانیم بگوییم &lt;code&gt;T.toString()&lt;/code&gt;، چرا که ممکن است تایپی به تابع ارسال شود که فاقد متد toString باشد. پس همیشه هنگام نوشتن توابع جنریک، خود را برای ورود هر تایپی آماده کنید.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;generic-interface&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;محدود-کردن-دامنه-ی-تایپ-های-جاگزین-در-جنریک&#34;&gt;محدود کردن دامنه‌ی تایپ‌های جاگزین در جنریک&lt;/h3&gt;

&lt;p&gt;مسلما با این قضیه که نمی‌شود «متغیرهای تایپ» را پیش بنی کرد، توابع ما بسیار عمومی خواهند شد و نمی‌توانیم خیلی از کارهایی که دوست داریم را با  «متغیرهای تایپ» انجام دهیم. خوب می‌شد اگر می‌توانستیم تعیین کنیم که فقط تایپ‌هایی که دارای یک سری خصوصیات مد نظر ما هستند در  «متغیرهای تایپ» وارد شوند؛ اینجاست که اینترفیس‌ها به کمک ما می‌آیند.&lt;/p&gt;

&lt;p&gt;در قسمت مربوط به &lt;a href=&#34;#interface&#34;&gt;اینترفیس (Interface)&lt;/a&gt; ها، ما یک اینترفیس طراحی کردیم به نام Sporter که تایپ‌های Boxer و Runner و Swimmer از آن تبعیت می‌کردند. فرض کنید می خوایم برای تابع جنریک اینطور تعریف کنیم که فقط تایپ‌هایی را که از اینترفیس Sporter تبعیت می‌کنند به عنوان ورودی بپذیرد:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;interface Sporter &amp;lt;T&amp;gt; {
    function start( ) ⟹ string;
}


function start_match&amp;lt;T: Sporter&amp;gt;( T ) {
    Sporter.start();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;در تابع start_match تعیین کردیم که تایپ جایگزین باید حتما از اینترفیس Sporter تبعیت کند. حالا با خیال راحت می‌توانیم در بدنه‌ی تابع خود از متد start استفاده کنیم چون مطمئن هستیم تمام تایپ‌هایی که اینترفیس Sporter را پیاده‌سازی کردند حتما دارای این متد نیز می‌باشند:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;b = new Boxer();
r = new Runner();
s = new Swimmer();

start_match&amp;lt;Sporter&amp;gt;( b );
start_match&amp;lt;Sporter&amp;gt;( r );
start_match&amp;lt;Sporter&amp;gt;( s );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;جنریک‌ها قابلیت‌های گسترده تری را نیز ارائه می‌کنند که ما در این نوشته تمام آن‌ها را توضیح نخواهیم داد؛ ولی حالا دیگر می دانید که وقتی صحبت از جنریک به میان می‌آید، قرار است با چه چیزی طرف شوید.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;end&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;سخن-آخر&#34;&gt;سخن آخر&lt;/h2&gt;

&lt;p&gt;همانطور که در مقدمه‌ی این نوشته به آن اشاره شد، مطالب این نوشته فقط بخش خیلی کوچکی از مباحث مربوط به تایپ‌هاست که هر برنامه‌نویسی باید با آن آشنا باشد. اما به کمک مطالب این نوشته، یک سری اطلاعات بنیادین بدست خواهید آورد که شما را برای مطالعاتی که در آینده انجام خواهید داد آماده می‌کند. امیدوارم این نوشته مورد قبول‌تان واقع شده باشد.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>تفاوت سرعت اندروید و آیفون در چیست؟</title>
      <link>https://amirrezaghaderi.com/fa/blog/android-ios/</link>
      <pubDate>April 7, 2017</pubDate>
      <author>Amirreza Ghaderi</author>
      <guid>https://amirrezaghaderi.com/fa/blog/android-ios/</guid>
      <description>

&lt;p&gt;قبل از هر چیز باید بگم که دوست ندارم این پست تبدیل به جدالی بین طرفداران اندروید و آی اُ اس بشه؛ نه تنها قصدی برای شروع چنین جدالی ندارم، بلکه دلم به حال کسانی که وقت خودشون رو با چنین دشمنی هایی هدر میدن میسوزه! افرادی که با چشم و گوش بسته از یک برند خاص طرفداری میکنن و حاضرن به خاطرش با بقیه جر و بحث کنن؛ جر و بحث هایی که اغلب مواقع منجر به دلخوری میشه؛ از خودتون سوال کنید: گوگل یا اپل پولی برای رفتار شما به حساب تون واریز میکنن؟&lt;/p&gt;

&lt;p&gt;پس حتما نکته‌ی بالا رو در نظر داشته باشید.&lt;/p&gt;

&lt;p&gt;چند تا موضوع دیگه هم هست که باید توضیح بدم: اول اینکه من از طرفداران نرم افزارهای آزاد و اوپن سورس هستم. بنابراین میتونین مطمئن باشید که با یک «اپل زامبی» طرف نیستید؛ دوم اینکه من به حالت نرمال به اندازه کافی پشت کامپیوتر میشینم، بنابراین زیاد علاقه ندارم که تو وقت آزادم سرم توی گوشی باشه! زیاد هم برام مهم نیست گوشی خودم اندروید باشه یا آیفون. من با هردوتاشون راحت هستم.&lt;/p&gt;

&lt;p&gt;متن زیر صرفا یک تشریح تکنیکی از دلایل تاثیر گذار در تفاوتِ سرعتِ اندروید و آی اُ اس (که از این به بعد برای راحتی بیشتر فقط آیفون صداش میکنم) هست.&lt;/p&gt;

&lt;p&gt;به تناسب اینکه تعدادی از دوستان من مغازه های فروش و تعمیر اسمارت فون دارند، و من هم خیلی از مواقع مغازه‌ی این دوستان رو پاتوق میکنم :) ، با گوشی های زیادی کار کردم. احتمالا خیلی بیشتر از اکثر شماهایی در حال خواندن این نوشته هستید. یک چیزی که همیشه برام مشهود بود، تفاوت سرعت قابل ملاحظه بین گوشی های اندروید و آیفون بوده. حالا من توی این نوشته میخوام از دید یک برنامه نویس و متخصص نرم افزار (خِیرِ سَرَم مثلا!)، براتون توضیح بدم چرا اوضاع چنین است!&lt;/p&gt;

&lt;h2 id=&#34;پلتفرم-نرم-افزاری&#34;&gt;پلتفرم نرم افزاری&lt;/h2&gt;

&lt;p&gt;اندروید از جاوا استفاده میکند.
آیفون از آبجکتیو-سی و سوییفت بهره میبرد.&lt;/p&gt;

&lt;p&gt;آبجکتیو-سی و سوییفت هر دو به نسبت جاوا زبان های سطح پایین تری هستند.
هر چه یک زبان سطح پایین تر باشد، ممکن است زمان تولید و ساخت برنامه طولانی تر شود، ولی از آن طرف اجرای برنامه با سرعت بالاتری همراه خواهد بود.&lt;/p&gt;

&lt;h3 id=&#34;این-جاوا-آن-جاوا-نیست&#34;&gt;این جاوا، آن جاوا نیست!&lt;/h3&gt;

&lt;p&gt;جاوا، یک زبان سنگین است! سنگین از نظر مصرف منابع سخت افزاری؛ ولی با اینکه یک زبان سنگین است، زبان کندی نیست! برعکس، جاوا یکی از سریع ترین زبان های برنامه نویسی است. به همین دلیل است که اغلب سرویس های بزرگ آنلاین (فیسبوک، توییتر، &amp;hellip;) از جاوا روی سرورهای خودشان استفاده میکنند.&lt;/p&gt;

&lt;p&gt;موضوعی که باید به آن توجه کنیم این است که سرعت جاوا فقط زمانی جلوه میکند که برنامه‌ی شما در دراز مدت اجرا شود؛ فرضا برنامه های سرور نمونه بارز این مثال هستند که شاید ماه ها و یا حتی سال ها بدون توقف در حال اجرا باشند. اگر برنامه‌ی جاوا عمر کوتاهی داشته باشد (فرضا برنامه ای مثل نوت پد) آن برنامه بسیار کند جلوه میکند. چرا این اتفاق می افتد؟ همراه متن باشد&amp;hellip;.&lt;/p&gt;

&lt;p&gt;در این قسمت از نوشته، کافیست همین قدر بدانید که جاوا ای که شما میشناسید آن جاوایی نیست که روی اندروید وجود دارد. جاوا یک سیستم متسحکم و پایدار است که بیست سال است توسط سان و اوراکل و هزاران برنامه نویس فعال دیگر در حال توسعه است. اما جاوایی ای که در اندروید وجود دارد یک سیستم کاملا متفاوت و جوان است که گوگل آن را طراحی کرده و هیچ وجه مشترکی جز «اسم» و «سینتکس» مشترک با آن جاوایی که می شناسید ندارد.&lt;/p&gt;

&lt;p&gt;بنابراین اولین مورد این است که جاوای اندروید، آن جاوای سریع و معروف نیست!&lt;/p&gt;

&lt;h3 id=&#34;برنامه-ی-شما-هیچ-وقت-اجرا-نمی-شود&#34;&gt;برنامه ی شما هیچ وقت اجرا نمی شود!&lt;/h3&gt;

&lt;p&gt;عبارت بالا برای خیلی ها تعجب آور است. بگذارید موضوع را کمی باز کنیم:&lt;/p&gt;

&lt;p&gt;برنامه های کامپیوتری توسط پردازنده اجرا میشوند. زبان پردازنده، «زبان ماشین» است و هیچ زبان دیگری برایش معنا ندارد. بنابراین وقتی شما برنامه ای به جاوا یا سوییفت مینویسید، کدهای شما باید به نحوی به زبان ماشین تبدیل شوند تا برای پردازنده قابل فهم باشند.&lt;/p&gt;

&lt;p&gt;در سوییفت، کدهای شما مستقیما به زبان ماشین تبدیل میشود. برنامه هایی که مستقیم به کد ماشین تبدیل شده اند، برنامه‌های «نیتیو» نام دارند.&lt;/p&gt;

&lt;p&gt;در جاوا، کدهای شما به زبان ماشین تبدیل نمیشوند! به جایش، به یک زبان میانی به نام «بایت کد» تبدیل میشوند. بایت کدها به خودیِ خود قادر به اجرا روی پردازنده نیستند؛ برای همین درون یک سیستم نرم افزاری ثانویه به نام «ماشین مجازی» (VM)  اجرا میشوند. چنین برنامه هایی که باید تحت مدیریت یک سیستم ثانویه اجرا شوند، به برنامه های «مدیریت شده» شهرت دارند. (Managed)&lt;/p&gt;

&lt;p&gt;از همین رو، بر عکس آیفون، برنامه ای که شما برای اندروید میسازید به خودی خود اجرا نمی شود؛ در همه حال، این VM است که اجرا میگردد و کدهای شما در بهترین حالت، فقط در حال دستور دادن به سیستم VM میباشند. مانند وقتی که شما با دسته ی کنسول، در حال دستور دادن به بازیکنان بازی فیفا هستید! این واقعا شما نیستید که فوتبال بازی میکنید، شما فقط در حال دستور دادن به بازیکنان درون بازی هستید.&lt;/p&gt;

&lt;p&gt;ممکن است سوال کنید برنامه های نیتیو هم به خودی خود کار نمیکنند و تحت سیستم عامل اجرا میشوند؛ فرض شما درست نیست! برنامه هایی که به کد ماشین ترجمه شده اند مستقیما روی پردازنده اجرا می شوند. در زمان اجرای برنامه های نیتیو، اجرای سیستم عامل کاملا متوقف می شود و پردازنده برنامه ی شما را بدون واسطه اجرا میکند. البته سیستم عامل تحت فرآیندی به نام «زمانبندی»، اجرای کدهای نیتیو و کدهای خودش را به گونه ای برای پردازنده زمانبندی میکند که پردازنده همیشه در حال سوییچ بین آن ها باشد؛ و این سوییچ کردن آنقدر سریع اتفاق می افتد که شما فکر میکنید سیستم عامل و برنامه‌ی شما به طور هم زمان در حال اجزا هستند؛ در حالی که وقعا اینطور نیست.&lt;/p&gt;

&lt;p&gt;توضیحی که در بالا دادیم، دقیقا به همین شکل برای نسخه های جدیدتر اندروید صدق نمیکند. با متن همراه باشید تا ذره ذره موضوع رو تشریح کنم.&lt;/p&gt;

&lt;h3 id=&#34;سیستم-vm-و-مشتقات-آن&#34;&gt;سیستم VM و مشتقات آن&lt;/h3&gt;

&lt;p&gt;سیستم VM در اندروید، کارهای اساسی زیر را به عهده دارد:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;تفسیر بایت کدها و اجرای آن ها (درست شنیدید، «تفسیر»)&lt;/li&gt;
&lt;li&gt;سیستم کمکی زمان اجرا، ملقب به سیستم ران‌تایم&lt;/li&gt;
&lt;li&gt;سیستم مدیریت حافظه، ملقب به جی سی (GC)&lt;/li&gt;
&lt;li&gt;سیستم بهینه ساز زمان اجرا، ملقب به جیت (JIT)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;دوباره تاکید میکنم، روند اجرای برنامه های اندروید در نسخه های جدیدتر دقیقا به این حالت نیست، اما برای روشن شدن موضوع لازم است مرحله به مرحله این مباحث را توضیح دهیم؛ پس کمی صبور باشید!&lt;/p&gt;

&lt;p&gt;تفسیر:&lt;/p&gt;

&lt;p&gt;اولین فرق را در همین گزینه‌ی اول حس میکنید. با اینکه برنامه های سوییفت و جاوا هردو کامپایل میشوند، ولی جاوا برای اجرای برنامه ها بایت کدها را به شکل تفسیری اجرا میکند. عمل تفسیر در زمان اجرای برنامه صورت میگیرد بنابراین قسمتی از کند بودن برنامه به خاطر همین مرحله است که در آیفون وجود ندارد.&lt;/p&gt;

&lt;p&gt;ران تایم:&lt;/p&gt;

&lt;p&gt;سوییفت به نسبت جاوا زبان سطح پایین تری است و به همین دلیل ران تایم بسیار کوچک تر و سبک تری در مقایسه با جاوا دارد. دقت کنید که سیستم ران تایم، همگام با برنامه ی شما در حال اجراست. یعنی در بهترین حالت، موقع اجرا برنامه تان، در حقیقت دو برنامه کاملا مستقل در حال اجرا هستند. یکی برنامه شما که کدهایش را خودتان نوشتید، و یکی سیستم ران تایم که مدام در حال سرویس دهی به برنامه شماست. از آنجایی که ران تایم جاوا سنگین تر از سوییفت است، برنامه ها نیز به همین نسبت سنگین تر خواهند شد.&lt;/p&gt;

&lt;p&gt;سیستم جی سی:&lt;/p&gt;

&lt;p&gt;سیستم مدیریت حافظه، از تاثیرگذار ترین عوامل در سرعت زبان های برنامه نویسی است. سوییفت، دارای سیستم جی سی نیست! حداقل نه به آن شکلی که در جاوا وجود دارد (ARC). مدیریت حافظه در سوییفت جزو وظایف برنامه نویس است. به این معنی است که کار برنامه نویس در مدیریت حافظه سخت تر است و ممکن است با خطای بیشتری همراه باشد، اما در عوض کنترل بیشتری روی منابع حافظه و سرعت آن دارد.&lt;/p&gt;

&lt;p&gt;در عوض در جاوا، یک سیستم جی سی کامل حضور دارد که وظیفه ی مدیریت حافظه را از دوش برنامه نویس برداشته و کار برنامه نویس را بسیار راحت کرده. این راحتی قیمت ارزانی ندارد! هر کسی که اطلاعات اندکی از سیستم های جی سی داشته باشد، به شما خواهد گفت که برای کارکرد مناسب سیستم جی سی، به طور میانگین به ۳ برابر حافظه ی بیشتر نیاز خواهد بود؛ و برای کارکرد واقعا بهینه ی آن، به ۵ تا ۶ برابر حافظه ی بیشتر نیاز است.&lt;/p&gt;

&lt;p&gt;در زبان ساده، اگر یک برنامه ی نرمال در سوییفت نیاز به ۱۰۰ مگابایت رم داشته باشد، همان برنامه در اندروید برای اجرای بهینه نیاز به ۵۰۰ مگابایت رم دارد! برای همین است که آیفون با وجود رم کمتر، میتواند باز هم بهینه باشد ولی گوشی های اندرویدی برای زیاد کردن رم باهم مسابقه میدهند.&lt;/p&gt;

&lt;p&gt;در حال حاضر آیفون ۷ دارای ۲ گیگ رم میباشد و گلکسی اس ۸ دارای ۴ گیگ رم است. با اینکه روی کاغذ ممکن است فکر کنید گلکسی اس رم بیشتری دارد، ولی در واقع ۶ گیگ رم کم دارد! اگر ۱۰ گیگ رم داشت، تازه رقابت مساوی میشد.&lt;/p&gt;

&lt;p&gt;دقت کنید، توضیحاتی که دادیم دلیل بر این نیست همیشه و در همه ی اوقات این قضایا برقرار خواهد بود. فرضا ممکن است برنامه ایی در سوییفت داشته باشیم که چندین برابر بیشتر از جاوا رم نیاز داشته باشد. یا ممکن است در خیلی از موارد سیستم جی سی جاوا از فرآیند دستی کنترل حافظه در سوییف سریع تر عمل کند. چیزهایی از این دست کاملا امکان پذیر هستند ولی توضیح بیشتر درباره آن ها خارج از موضوع این نوشته است.&lt;/p&gt;

&lt;p&gt;سیستم جیت:&lt;/p&gt;

&lt;p&gt;در ابتدای نوشته گفتیم برنامه های جاوا سریع خواهند بود به شرطی که در مدت طولانی به اجرا درآیند (مثل برنامه های سرور). دلیل این موضوع به سیستم جیت برمیگردد. تا اینجا میدانید که برنامه ی شما به بایت کد تبدیل میشود، و نه کد ماشین؛ همچنین میدانید که بایت کد به شکل تفسیری اجرا میشود. این موضوع در سرعت برنامه تاثیر گذار است.&lt;/p&gt;

&lt;p&gt;چیزی که باید بدانید این است که یک فرآیند دیگر همگام با اجرای برنامه شما در حال اجراست. در زمانی که برنامه ی شما اجرا میشود، یک سیستم نرم افزاری دیگر به نام جیت، مدام در حال تجزیه و تحلیل روند اجرای برنامه ی شماست. به محض اینکه جیت متوجه شود قسمتی از کدها بیشتر مورد استفاده قرار میگیرند، سعی میکند آن قسمت پر استفاده را در زمان اجرا به کد ماشین ترجمه کند. فرضا تابعی که زیاد موقع اجرای برنامه صدا زده میشود. یا حلقه هایی که چرخش طولانی دارند.&lt;/p&gt;

&lt;p&gt;جیت با ترجمه ی این نقاط پر استفاده به کد ماشین، باعث بالا رفتن سرعت برنامه ی شما میشود. ولی نکاتی وجود دارد که باید به آن توجه کرد:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;جیت فرآیند تجزیه و تحلیل برنامه شما را طی گذر زمان انجام میدهد. اگر برنامه ی شما زیاد عمر نکند (مثلا تلگرام را یک لحظه باز کنید، یک مسیج بخوانید، و سپس آن را ببندید)، جیت به حالتی نمیرسد بتواند نقاط پر استفاده را تشخیص دهد. برای همین برنامه های سرور که اجرای طولانی مدت دارند در گذر زمان بسیار بهینه خواهند شد. این پروسه بین جاوا کارها به « گرم شدن ماشین مجازی » شهرت دارد.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;فرآیند تجزیه و تحلیل  جیت، به موازات  برنامه ی شما در حال اجراست؛ بنابراین خودش نیاز به مصرف منابع پردازنده و حافظه رم دارد و باعث سنگین شدن برنامه خواهد شد.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;اگر برنامه ی شما در دراز مدت اجرا نشود، و کدهایی نداشته باشد که مدام فراخانی شوند، جیت نه تنها سرعتی به برنامه اضافه نخواهد کرد، بلکه خودش یک بار اضافی خواهد بود.&lt;/p&gt;

&lt;p&gt;سوییفت، سیستم جیت ندارد. به همین راحتی!&lt;/p&gt;

&lt;h3 id=&#34;آرت-وارد-میشود&#34;&gt;آرت وارد میشود&lt;/h3&gt;

&lt;p&gt;از اندروید ۵ به بعد، روند اجرای برنامه ها تغییر کرد. برنامه ها حالا زیر نظر ART که سیستم ران تایم جدید اندروید است اجرا میشوند. آرت چه مزایایی دارد:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;موقع نصب برنامه، بایت کدهای شما به کد ماشین ترجمه میشوند. بنابراین دیگر از عملیات تفسیر خبری نیست. همین باعث میشود زمان استارت برنامه کاهش یابد.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;برعکس جیت که در زمان اجرای برنامه بهینه سازی انجام میداد، آرت سعی میکند تا جایی که می تواند بهینه سازی را هنگام نصب برنامه اعمال کند تا دیگر در زمان اجرای برنامه بار اضافی به برنامه تحمیل نشود. یعنی دیگر خبری از جیت نیست.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;همچنین آرت سیستم ران تایم و جی سی بهینه تری دارد.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;این موارد باعث شده اند که سرعت اندروید از نسخه ی ۵ به بالا، اصلا قابل مقایسه با نسخه های پایین تر نباشد. و این تفاوت سرعت کاملا قابل لمس است. با تمام این توضیحات، آرت باز هم آن چیزی نیست که باید باشد. ران تایم بزرگ و سنگین سر جایش است. سیستم جی سی جایی نرفته. و از همه مهم تر آرت نمی تواند به هوشمندی جیت نقاط حساس کد را بهینه کند. به همین دلیل است که از اندروید ۷ به بعد، دوباره جیت  سر و کله اش پیدا شده. روز از نو و روزی از نو!&lt;/p&gt;

&lt;h3 id=&#34;توجه-بیشتر-به-رندر-گرافیکی&#34;&gt;توجه بیشتر به رندر گرافیکی&lt;/h3&gt;

&lt;p&gt;پروسه ای که وظیفه ی رندر گرافیک را به عهده دارد، از اولویت بالایی در آیفون برخوردار است. یعنی آیفون زمان بیشتری از پردازنده را به این پروسه اختصاص میدهد. برای آیفون این قضیه که کدهای پشت صحنه کمی کندتر انجام شوند زیاد مهم نیست، مهم این است تا جایی که ممکن است کاربر این کندی را در رابط گرافیکی برنامه حس نکند. تا زمانی که کاربر کندی را «حس» نکند، برنامه از نظر او سریع قلمداد میشود.&lt;/p&gt;

&lt;p&gt;بنابراین ممکن است انجام یک کاری در اندروید ۲ ثانیه طول بکشد، اما انجام همان کار در آیفون۳ ثانیه. با این فرق که کاربر کندی  را در رابط کاربری آیفون کمتر از اندروید حس خواهد کرد. در اندروید با اینکه آن کار زودتر تمام شده، اما ممکن است در رابط گرافیکی افت فریم به وجود بیاید. در واقع اندروید سعی میکن «تمام وظایف» را با سرعت بالا به اتمام برساند، ولی آیفون فقط روی رندر گرافیکی حساس است و اگر بقیه وظایف کمی کندتر انجام شوند زیاد مهم نیست. مهم تر این است که کندی از «چشم» کاربر دور بماند!&lt;/p&gt;

&lt;h2 id=&#34;پلتفرم-سخت-افزاری&#34;&gt;پلتفرم سخت افزاری&lt;/h2&gt;

&lt;p&gt;اپل بیشتر از آنکه یک شرکت نرم افزاری باشد، یک شرکت سخت افزاری است.  علاوه بر آن، از قدیمی ترین شرکت ها در ساخت سیستم عامل است.&lt;/p&gt;

&lt;p&gt;از آن طرف گوگل به نسبت اپل، هم عمر کمتری دارد، و تجربه ی کمتری در ساخت سخت افزار و سیستم عامل. اندروید حتی جزو محصولات گوگل هم نبوده و از شرکت دیگری خریداری شد.&lt;/p&gt;

&lt;p&gt;ممکن است بگویید شرکت بزرگی مثل گوگل که «تجربه» حالیش نمی شود! پول دارد و افراد مورد نیازش را استخدام میکند. دقت کنید منظورم از تجربه این نیست که مثل شاگرد نجار کنار استادش بشیند و یاد بگیرید. خیر؛ وقتی مانند اپل محصول اصلی شما سخت افزار و سیستم عامل باشد، پول بیشتری در این حوضه خرج میکنید. پول برای استخدام افراد. پول برای تحقیق در این زمینه ها. پول برای آزمایشات فراوان. و وقتی این کار را برای چندین دهه انجام میدهید، آن وقت رقابت با شما سخت خواهد بود.&lt;/p&gt;

&lt;p&gt;همانطور که اگر اپل بخواهد وارد کار موتورهای جستجو شود باید راه درازی را طی کند تا به گوگل برسد، گوگل هم در زمینه سخت افزار و سیستم عامل نمیتواند به این راحتی با اپل رقابت کند. حتی مایکروسافت هم به این راحتی توانایی چنین کاری را ندارد. مایکروسافت یک شرکت نرم افزاریست. اپل جزو معدود شرکت هایی است که از صفر تا صد محصولاتش (سخت افزار و نرم افزار) را خودش توسعه میدهد.&lt;/p&gt;

&lt;p&gt;در بالاتر گفتیم که اندروید برای بهینه بودن، به نسبت آیفون رم بالاتری نیاز خواهد داشت. که در حال حاضر این میزان رم در حدی نیست که بتواند با آیفون رقابت کند؛ حتی با اینکه رم بیشتری از آیفون دارد!&lt;/p&gt;

&lt;p&gt;از نظر پردازنده هم اندروید نیاز دارد که به طور میانگین ۳ برابر سریع تر از آیفون باشد. متاسفانه این مورد هم پا برجا نیست. اپل همیشه سریع ترین پردازنده ها را تولید میکند. بهترین پردازنده های گوشی های اندروید همیشه یا از آیفون عقب تر هستند، و اینکه سرعت شان در حد ۱۰-۲۰ درصد بالاتر است. که خیلی با ۳ برابر بیشتر، فاصله دارد!&lt;/p&gt;

&lt;p&gt;اندروید سعی کرده با اضافه کردن تعداد هسته های پردازنده با آیفون رقابت کند. اما هر برنامه نویسی می داند که تعداد هسته های پردازنده آنقدرها هم مهم نیست، وقتی نتوانید از آن ها استفاده کنید! برنامه نویسی همروند و موازی خودش یک مبحث مفصل در علوم کامپیوتری است و  خیل عظیمی از برنامه نویسان موبایل آشنایی زیادی با آن ندارند. از طرفی، شاید نقش پردازشگر گرافیکی روی موبایل پر رنگ تر از پردازنده ی اصلی باشد. که از نظر پردازنده ی گرافیکی هم آیفون همیشه یکه تاز بوده.&lt;/p&gt;

&lt;p&gt;چون اپل سخت افزار و نرم افزار را خودش توسعه میدهد، تمام قسمت های سیستم تحت کنترل خودش است. خیلی ها فکر میکنند فقط تعداد هسته های پردازنده و میزان رم مهم است؛ آیا مادربورد و چیپ های جانبی هیچ کدام مهم نیستند؟ وضعیت این ها در دنیای اندروید چگونه است؟ در این زمینه هر گوشی اندروید برای خودش سازی میزند! در حالی که آیفون طراحی یکپارچه ای دارد و این یکپارچگی در تمام قطعات سخت افزاری اعمال شده.&lt;/p&gt;

&lt;p&gt;پردازنده بالاتر، رم بالاتر، و اندازه اسکرین بالاتر خرج دارد! از طرفی تولید کنندگان اندروید سعی میکنند کاستی هایش را با موارد جانبی مانند دوربین بهتر یا سیستم صوتی بالاتر جبران کنند. همه ی اینها خرج دارد! قیمت تمام شده ی این ها مسلما از آیفون بالاتر خواهد بود.&lt;/p&gt;

&lt;p&gt;در حال حاضر، آیفون ۷ با ۱۲۸ گیگ حافظه، ۷۴۹ دلار قیمت دارد.&lt;/p&gt;

&lt;p&gt;گلکسی اس ۸ سامسونگ، با ۶۴ گیگ حافظه، ۷۵۰ دلار است.&lt;/p&gt;

&lt;p&gt;به عبارتی شما برای اندروید پول بیشتری میدهید، اما کیفیت بالاتری دریافت نمیکنید. این قضیه که آیفون در بازار ایران قیمت هایش الکی و روی هواست، دلیل بر این نیست که واقعا از پرچمداران اندروید گران تر است.&lt;/p&gt;

&lt;p&gt;آیا من که گلکسی اس ۸ را مثال میزنم تا به حال آن را در دستم گرفته ام و با آن کار کرده ام که درباره آن ابزار نظر میکنم؟&lt;/p&gt;

&lt;p&gt;خیر. اما کار نکرده میدانم که باز هم بهینگی آیفون را نخواهد داشت. و اس ۹ هم همینطور. و اس ۱۰ هم همینطور. و گوشی هایی که بعد از آن خواهند آمد! مگر اینکه در دنیای اندروید اتفاق خاصی رخ دهد&amp;hellip; اما تا رسیدن آن روز، حداقل شما میدانید که تفاوت سرعت آیفون و اندروید به چه دلایلی است.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>حقیقتی در باب محبوبیت زبان های برنامه نویسی</title>
      <link>https://amirrezaghaderi.com/fa/blog/tier1-langs/</link>
      <pubDate>March 30, 2017</pubDate>
      <author>Amirreza Ghaderi</author>
      <guid>https://amirrezaghaderi.com/fa/blog/tier1-langs/</guid>
      <description>

&lt;p&gt;زبان های برنامه نویسی امکان ارتباط بین انسان و ماشین را فراهم کرده اند؛ و هم چون زبان های انسانی، گوناگونی زیادی در بین آن ها وجود دارد. بعضی از آن ها محبوب ترند، و بعضی ناشناخته تر؛ محبوبیت زبان های انسانی مانند انگلیسی یا چینی عموما وابسته به جمعیت، و نفوذ سیاسی و اقتصادی و فرهنگی است.&lt;/p&gt;

&lt;p&gt;اما چه عواملی باعث محبوبیت یک زبان برنامه نویسی می شود؟ کیفیت زبان؟ سرعت زبان؟ سادگی زبان؟&amp;hellip; راستش را بخواهید نتیجه ای که شخصا به آن رسیده ام این است:&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;in-red&#34;&gt;
&lt;strong&gt;واقعیت این است که فقط زبان هایی به شهرت فراگیر می رسند که یک «پلتفرم» به خصوص برای شان فراهم باشد.&lt;/strong&gt;
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;منظورم از «پلتفرم» چیست؟ یعنی زبان دارای این خصوصیات باشد:&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;in-red&#34;&gt;
الف) یک شرکت معتبر، سرمایه دار، و بزرگ با تمام قدرت از آن زبان حمایت کند.
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;in-red&#34;&gt;
ب) در یک زمینه‌ی خاص، آلترناتیو قدرت مند دیگری در مقابل آن زبان وجود نداشته باشد.
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;in-red&#34;&gt;
ج) در گذر سال های متمادی، «اثر شبکه» برای آن زبان شکل گرفته باشد.
&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;اثر-شبکه-ای-چیست&#34;&gt;اثر شبکه ای چیست؟&lt;/h3&gt;

&lt;p&gt;تاثیر «تعداد» استفاده کنندگان یک محصول، در ارزش آن.&lt;/p&gt;

&lt;p&gt;برای مثال، اپلیکیشن های زیادی مثل اینستاگرام یا تلگرام وجود دارند؛ اما شما از آن‌ها استفاده نمیکنید چون همه‌ی دوستان تان روی اینستاگرام و تلگرام هستند. به عبارت دیگر، ارزش برنامه هایی مانند تلگرام و اینستاگرام به کاربرانی است که در آن ها حضور دارند؛&lt;/p&gt;

&lt;p&gt;زبان هایی که دارای پلتفرم قدرتمند باشند:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;مناسب ترین انتخاب برای یادگیری و وقت گذاشتن هستند.&lt;/li&gt;
&lt;li&gt;برای کاربرد در پروژه های واقعی مناسب اند.&lt;/li&gt;
&lt;li&gt;ابزارها و مستندات پایداری دارند.&lt;/li&gt;
&lt;li&gt;محبوبیت شان به این راحتی ها کم نمی شود از بین نمی روند.&lt;/li&gt;
&lt;li&gt;تعداد بالای کاربران شان باعث میگردد که مدام در حال بهتر شدن باشند.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;اما چه زبان هایی دارای پلتفرم مناسب هستند؟&lt;/p&gt;

&lt;h2 id=&#34;java&#34;&gt;Java&lt;/h2&gt;

&lt;p&gt;شامل هر سه گزینه‌ی الف، ب، ج&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;اینترپرایز یا همان برنامه های سازمانی:&lt;/strong&gt;
این گروه از برنامه‌ها به شکل موثر روی جاوا به عنوان یک زبان پایدار و مولتی پلتفرم حساب باز کرده اند. بخش مهمی از آن هم به دلیل حمایت «اوراکل» از آن است.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;اندروید:&lt;/strong&gt;
مهم نیست که نیتیو اسکریپت، یا ری‌اکت نیتیو، و ابزارهایی از این دست چقدر پیشرفت کنند، درنهایت تنها جاوا به عنوان زبان اصلی اندروید شناخته میشود و برای ساخت برنامه های اندروید هیچ زبان دیگری توان رقابت با آن را ندارد.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;اکوسیستم JVM:&lt;/strong&gt;
زبان های دیگری مانند اسکالا یا کلوژور که روی JVM اجرا میشوند، خودشان به نوعی از دلایل محبوبیت بیشتر جاوا و تثبیت کننده‌ی آینده‌ی آن شده اند!&lt;/p&gt;

&lt;h2 id=&#34;c-و-c&#34;&gt;C و ++C&lt;/h2&gt;

&lt;p&gt;گزینه‌های «ب» و «ج» تاثیر گذارترین هستن.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;برنامه‌های سیستمی:&lt;/strong&gt;
سیستم عامل ها، کامپایلرها، تکست ادیتورها، ابزارهای سنگین رابط کاربر مثل آی‌دی‌ای ها یا مثلا فتوشاپ، پردازش تصویر، درایورها، سخت افزارهای توکار&amp;hellip; این‌ها بخشی از مواردی هستند که هیچ آلترناتیو دیگری به جز سی و سی‌پلاس‌پلاس برایشان وجود ندارد.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;بازی:&lt;/strong&gt;
سی و مخصوصا سی‌پلاس‌پلاس در زمینه‌ی ساخت بازی های کامپیوتری یک استاندارد به حساب می‌آیند.&lt;/p&gt;

&lt;p&gt;همه‌ی این‌ها باعث میشوند این دو زبان از نظر محبوبیت و ضریب کاربرد همیشه در یک حالت ثبات باقی بمانند.&lt;/p&gt;

&lt;h2 id=&#34;sql&#34;&gt;SQL&lt;/h2&gt;

&lt;p&gt;گزینه‌ی «ب»: زبان استاندارد و پذیرفته در سیستم های پایگاه داده. این زبان با انحصار به محبوبیت رسیده است.&lt;/p&gt;

&lt;h2 id=&#34;javascript&#34;&gt;JavaScript&lt;/h2&gt;

&lt;p&gt;گزینه‌ی «ب»: تنها زبان استاندارد و پذیرفته شده در کلاینت (مرورگر). به جرات می توان گفت اگر این انحصار وجود نداشت، جاوا اسکریپت عمرش به چند سال هم نمیکشید!&lt;/p&gt;

&lt;p&gt;گزینه‌ی «الف»: به تناسب گزینه‌ی «ب»، رقابت تنگاتنگی بین مایکروسافت، اپل، گوگل، و موزیلا در جریان است تا بهترین موتور پردازش جاوااسکریپت را ارائه کنند. این رقابت برای جاوا اسکریپت سودمند بوده.&lt;/p&gt;

&lt;p&gt;گزنه‌ی «ج»: به تناسب گزینه‌ی «ب»، جاوا اسکریپت زبانی است که امروزه تمام برنامه نویسان چه بخواهند و چه نخواهد باید آن را یاد بگیرند! به همین دلیل از محبوبیت بالایی برخوردار است.&lt;/p&gt;

&lt;h2 id=&#34;c&#34;&gt;#C&lt;/h2&gt;

&lt;p&gt;مهم ترین عامل گزینه‌ی «الف» است، هرچند که گزینه‌های «ب» و «ج» هم کم تاثیر نیستند.&lt;/p&gt;

&lt;p&gt;سی شارپ و دات نت به استاندارد توسعه‌ی نرم افزار در سکوی مایکروسافت تبدیل شده اند. اپلیکشن ویندوز، ویندوز سرور، ویندوز موبایل، ایکس باکس، &amp;hellip;. روی سکوهای مایکروسافتی، سی شارپ بهترین گزینه است.&lt;/p&gt;

&lt;h2 id=&#34;swift&#34;&gt;Swift&lt;/h2&gt;

&lt;p&gt;مهم ترین عامل گزینه‌های «الف» و «ب» است. ابراز نظر درباره گزینه‌ی «ج» هنوز برای این زبان زود است.&lt;/p&gt;

&lt;p&gt;سوییفت زبان «اپل» است. فکر میکنم همین جمله برای این زبان کافی باشد! وقتی پای اپلیکیشن‌های مک، آیفون، آیپد، و &amp;hellip; به وسط می آید، تنها گزینه (به جز آبجکتیو-سی) زبان سوییفت است. به خاطر قدرت و نفوذ اپل در جامعه‌ی نرم افزاری، این زبان چه بخواهیم و نخواهیم موفق خواهد بود.&lt;/p&gt;

&lt;h2 id=&#34;php&#34;&gt;PHP&lt;/h2&gt;

&lt;p&gt;بیشتر گزینه‌ی «ج» و تا حدی گزینه‌ی «ب»&lt;/p&gt;

&lt;p&gt;هیچ آلترناتیو قدرت مند دیگری نیست که روی هاست های اشتراکی ساپورت شود. هاست هایی که با قیمت به شدت ارزان شان، سهم بزرگی از سرویس دهی به مشتریان کوچک را به عهده دارند. پی اچ پی در گذر زمان برنامه نویسان زیادی را جذب کرده و هیچ زبان دیگری نیست که بتوان سایت های کوچک را به راحتی پی اچ پی در آن پیاده سازی کرد.&lt;/p&gt;

&lt;p&gt;از طرفی سیستم هایی مانند وردپرس و دروپال و جوملا و &amp;hellip; در زمینه‌ی سایت های محتوا محور (که بخش بزرگی از اینترنت را تشکیل میدهند) به عنوان سیستم های پذیرفته شناخته میشوند. زبان های دیگر هم زیاد میلی ندارند که سیستم هایی شبیه این ها را بسازند چون میدانند که به این راحتی به محبوبیت این سیستم ها لطمه وارد نمیشود.&lt;/p&gt;

&lt;h2 id=&#34;python-ruby&#34;&gt;Python, Ruby&lt;/h2&gt;

&lt;p&gt;بیشتر از همه گزینه‌ی «ج»&lt;/p&gt;

&lt;p&gt;سال ها پیش، در یک دورانی، در برنامه نویسی یک خلا به وجود آمده بود: نبود زبان هایی همه منظوره و آسان که از کیفیت مناسبی هم برخوردار باشند؛ پایتون و روبی توانستند آن خلا را پر کنند و خوش بدرخشند و تعداد زیادی از برنامه نویسان را به خود جذب نمایند. از ابزارهای متعدد ترمینال و دسکتاپ گرفته تا وب اپلیکشن هایی با مقیاس متوسط و نیمه بزرگ، این دو زبان هایی هستند که واقعا کار گشا می باشند.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;اگر واقع بین باشم، این لیست در همین جا تمام می شود! بقیه زبان ها در عالم واقعیت فاصله‌ی زیادی با لیست بالا دارند (حتی اگر ردیت و هکرنیوز چیز دیگری به شما تلقین کنند.)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34;&gt;گولنگ&lt;/a&gt;، در اول راه است و تازه گرم شده. شانسی که این زبان آورده این است که دوباره یک خلا در برنامه نویسی به وجود آمده: برای برنامه نویسان زبان های داینامیک (مثل پی اچ پی، پایتون، و روبی) مشخص شده که این زبان ها برای پروژه های بزرگ و سیستم هایی با همروندی بالا بهینه نیستند. گولنگ فعلا توانسته از این موقعیت شکل گرفته استفاده کند و در مدت کم محبوبیت مناسبی بدست آورد ولی هنوز برای اینکه آن را یک زبان رده اول عنوان کنیم خیلی زود است. حداقل باید پنج سال برای روشن تر شدن آینده‌ی این زبان منتظر ماند.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.rust-lang.org/en-US/&#34;&gt;راست&lt;/a&gt;، بسیار جوان است؛ همچنین بسیار سطح پایین‌تر از چیزی است که خیلی ها تصور میکنند! خیلی از برنامه نویسان که شاید درک عمیقی از مباحث حافظه نداشته باشند قادر نخواهند بود در آن احساس راحتی کنند. راست عملا یک سی‌پلاس‌پلاس مدرن است؛ به همان بزرگی و تقریبا به همان پیچیدگی! و سی‌پلاس‌پلاس هم زبانی نیست که به این راحتی کنار بکشد (مخصوصا با وجود چیزی که از آن به عنوان سی‌پلاس‌پلاس «مدرن» یاد میشود و شامل استانداردهای جدیدتر این زبان است). دوباره باید بگوییم، هنوز خیلی زود است که بخواهیم حساب جدی روی این زبان باز کنیم.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.erlang.org/&#34;&gt;ارلنگ&lt;/a&gt;، برنامه نویسان پس از سال ها تازه به یادش افتاده اند؛ ارلنگ در طراحی و ساخت سیستم های توزیع شده تقریبا بی رقیب است، ولی می توان گفت در زمینه‌های دیگر حرف زیادی برای گفتن ندارد.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://elixir-lang.org/&#34;&gt;الیکسیر&lt;/a&gt;، بیشتر در نقش یک آلترناتیو برای گولنگ ظاهر شده که ممکن است برای طرفداران زبان های داینامیک جذاب تر باشد. یعنی درصدی از طرفداران زبان های داینامیک که ممکن بود به گولنگ گرایش پیدا کنند، حالا یک گزینه‌ی ثانویه در اختیار دارند.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.scala-lang.org/&#34;&gt;اسکلا&lt;/a&gt; و &lt;a href=&#34;https://clojure.org/&#34;&gt;کلوژور&lt;/a&gt;، هیچ وقت از زیر سایه جاوا بیرون نخواهند آمد. جاوا هم این وسط بیکار نمانده و با هر نسخه‌ی جدیدی که منتشر میکند آرام آرام امکانات مدرن تری به خود اضافه می نماید. در حدی که شاید خیلی ها دیگر لازم ندانند که از آن کوچ کنند.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://fsharp.org/&#34;&gt;اف شارپ&lt;/a&gt;، مشابه اسکالا و کلوژور همیشه در سایه سی شارپ خواهد ماند. فوکوس اصلی مایکروسافت، سی شارپ است. بقیه زبان ها بیشتر برای راضی نگه داشتن سلیقه های مختلف ظاهر شده اند.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.haskell.org/&#34;&gt;هسکل&lt;/a&gt;، و دیگر زبان هایی که تمرکز  و تاکید زیادی به فانکشنال بودن دارند، به این راحتی به جایی نخواهند رسید. شیوه‌ی برنامه نویسی در زبان های «دستوری» به شیوه ی مکالمه ی انسان ها نزدیک تر است؛ در برابر زبان های فانکشنال که مکالمه در آن‌ها بیشتر شبیه فرمول های ریاضی است. مسلما به هیچ عنوان نمی توان منکر مزایای زبان های فانکشنال شد، اما از آنجایی که اکثر زبان های دستوری کم و بیش در حال اضافه کردن قابلیت های فانکشنال هستند، این سوال پیش می آید که آیا برایمان صرف میکند که کاملا به یک زبان فانکشنال کوچ کنیم یا اینکه در همین زبان آشنای دستوری بمانیم و کم کم کدهایمان را به شکل فانکشنال تری بنویسیم؟&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;
شاید اشتباه کنم، اما فکر میکنم اگر تمام کدهای نوشته شده در زبان های بخش دوم را با هم جمع کنیم، باز به اندازه‌ی حتی یکی از زبان های ذکر شده در بخش اول نمی رسند!
&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;همه‌ی موارد بالا به کنار، تجربه ثابت کرده که وقتی زبان یا ابزار جدیدی ظهور می کند، میانگین ده سال طول می کشد که به یک محصول شناخته شده و بدیهی در بین عموم برنامه نویسان تبدیل شود. شاید بعضی از زبان ها باشند که بیست سال یا بیشتر از انتشار آن‌ها گذشته باشد، ولی پروسه شناخته شدن آن ها به تازگی صورت پذیرفته باشد. همه‌ی این ها باعث میشوند که رسیدن به زبان هایی که در بخش اول این نوشته ذکر کردیم، برای زبان هایی که در بخش دوم لیست کردیم بسیار سخت و حتی غیر ممکن باشد.&lt;/p&gt;

&lt;p&gt;برنامه نویسان همیشه مشتاق یادگیری زبان های جدید هستند. اگر بخواهیم تنها به یک زبان اکتفا کنیم و هیچ چیز دیگری را مطالعه نکنیم، مغزمان به یک مرداب تبدیل خواهد شد؛ اما مطالعه و تحقیق درباره‌ی زبان‌های مختلف، فرق زیادی دارد با استفاده‌ی واقعی و گسترده از آن‌ها&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>