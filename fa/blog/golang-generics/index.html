<!DOCTYPE html>
<html lang="fa-IR">
<head>
<meta charset="utf-8">
<title>نبود قابلیت‌های مختلف در گولنگ: جنریک | وب نوشت‌ها | امیررضا قادری</title>


<meta name="description" content="نبود قابلیت‌های مختلف در گولنگ: جنریک و چگونگی پیاده‌سازی آن در گولنگ"/>



<meta name="keywords"    content="جنریک, گولنگ, تایپ, برنامه نویسی, برنامه‌نویسی"/>


<meta name="viewport"    content="width=device-width, initial-scale=1">
<meta name="author"      content="Amirreza Ghaderi">
<meta name="robots"      content="INDEX,FOLLOW">

<link rel="stylesheet"    href="https://amirrezaghaderi.com/fa/css/style.css" type="text/css"/>
<link rel="stylesheet"    href="https://amirrezaghaderi.com/fa/css/solarized-light.css" type="text/css"/>

<link rel="shortcut icon" type="image/png" href="https://amirrezaghaderi.com/fa/favicon.png">
<link rel="alternate"     href="https://amirrezaghaderi.com/fa/index.xml" type="application/rss+xml" title="Amirreza's blog"/>

<script type="text/javascript">
if("querySelector"in document&&"addEventListener"in window&&"classList"in document.documentElement){}else{window.location="https:\/\/amirrezaghaderi.com\/fa\//old-browser.html"}
</script>



</head>

<body>

<div id="page" class="site rtl">

<header id="page-header" class="h100" role="banner">
<nav id="side-menu" class="side-menu" role="navigation">
  <a id="side-menu-btn" class='side-menu-btn white bg-red bh-black p15 w100 block' href="#menu">منوی سایت</a>
  <div id="side-menu-list" class="side-menu-list">
    <ul>
      <li><a href="https://amirrezaghaderi.com/fa/">صفحه نخست</a></li>
      <li><a href="https://amirrezaghaderi.com/fa/post/">فهرست مطالب</a></li>
      <li><a href="https://amirrezaghaderi.com/fa/topic/">دسته‌بندی بر اساس موضوعات...</a></li>
      <li><a href="https://amirrezaghaderi.com/fa/contact/">تماس</a></li>
      <li><a href="https://amirrezaghaderi.com/fa/index.xml">فید</a></li>
    </ul>
  </div>
</nav>
</header>

<div id="content" class="pb120">
<div id="primary" class="">
<main id="main" class="main w850 middle" role="main">



<div class="center">
    <p class=""><a class="f5 bg-red white p5" href="https://amirrezaghaderi.com/fa/post/">بازگشت</a></p>
</div>

<!----------------------------------------------------------------------- -->

<article id="post" role="article">
<header class="center bb-bold-black">
 <h1 class="f1 mt30 mb30">
  <a class="black fh-red" rel="bookmark" href="https://amirrezaghaderi.com/fa/blog/golang-generics/">نبود قابلیت‌های مختلف در گولنگ: جنریک</a>
 </h1>

 <div class="pb10 f5 gray2">
  <time class="" datetime="July 12, 2017">۱۳۹۶/۰۴/۲۱</time>
 </div>

</header>

<div class="entry-toc">

</div>

<div class="entry-content p10">


<p><a name="toc"></a></p>

<h2 id="فهرست-مطالب">فهرست مطالب</h2>

<ul>
<li><a href="#prereq">مطالب پیش‌نیاز</a></li>
<li><a href="#intro">مقدمه</a></li>
<li><a href="#q-go-nogen">گولنگ جنریک ندارد؟</a></li>
<li><a href="#golang-philosophy">فلسفه‌ی گولنگ چیست؟</a></li>
<li><a href="#golang-generics">دست یابی به جنریک در گولنگ</a></li>
<li><a href="#q-golang-lessgen">چرا در گولنگ نیاز به جنریک کمتر حس می‌شود؟</a></li>
<li><a href="#golang-generic-box">پیاده‌سازی جنریک‌ها در گولنگ: بسته‌بندی و بسته‌گُشایی</a></li>
<li><a href="#golang-generation">پیاده‌سازی جنریک‌ها در گولنگ: تولید کد</a></li>
<li><a href="#end">سخن آخر</a></li>
</ul>

<p><a name="prereq"></a>
<strong>مطالب پیش نیاز</strong></p>

<p>قبل از خواندن این نوشته، بهتر است با جنریک و شیوه‌های مختلفی که دیگر زبان‌ها آن را پیاده‌سازی کرده اند آشنا باشید. می‌توانید برای مطالعه‌ در اینباره به زبان فارسی وارد لینک‌ زیر شوید:</p>

<ul>
<li><a href="http://amirrezaghaderi.ir/post/generics">شیوه‌های مختلف پیاده سازی جنریک در زبان‌ها</a></li>
</ul>

<p><a name="intro"></a></p>

<h2 id="مقدمه">مقدمه</h2>

<p>بعضی اوقات ما به شکل خواسته یا ناخواسته، برای خودمان یک سری «چارچوب فکری» طراحی می کنیم و بی‌دلیل روی این چارچوب‌ها اصرار می‌ورزیم. این طور فکر می‌کنیم که «راه درست» فقط همانی است که در چارچوب فکری ما وجود دارد. اما واقعا نمی دانیم این ادعا را بر چه مبنایی مطرح می‌کنیم! چرا این راه، تنها راه درست است؟ چه کسی این را گفته؟ این موضوع از کجا ثابت شده؟</p>

<p>در آخر متوجه می‌شویم تنها چیزی که ذهن ما را به روی آلترناتیو‌های دیگر بسته، فقط خودمان هستیم و آن چارچوب‌های کذایی!</p>

<p>موضوع ساده است:</p>

<p>یک سری مشکل یا  مساله وجود دارد؛ و برای هر کدام هم یک سری راه حل. ممکن است یک راه حل آسان‌تر باشد، و آن یکی سخت‌تر. یکی ساده تر باشد، و آن یکی پیچیده‌تر. خیلی هم کم پیش می‌آید که راه حل‌ها بدون نقص باشند؛ ما هم به تبع با بکار گرفتن یک راه حل، باید با نقاط ضعف آن نیز کنار بیاییم.</p>

<p>زبان‌های برنامه‌نویسی و ابزارهای پیرامون آن هیچ کدام بدون نقص و کاستی نیستند؛ این «ما» هستیم که باید با خود بیاندیشیم آیا می‌توانیم با این کاستی‌ها کنار بیاییم یا خیر. به عبارتی،
<span class="in-red">
زبان برنامه‌نویسی محبوب یک فرد، در واقع زبانی است که آن فرد توانسته با نقص‌هایش کنار بیاید!
</span></p>

<p>در این میان باید توجه کنیم که بسته به تفکرات مختلف، یک «نقص» ممکن است به عنوان یک «مزیت» مطرح شود، و یک مزیت به عنوان یک نقص!</p>

<p><a name="q-go-nogen"></a></p>

<h2 id="گولنگ-جنریک-ندارد">گولنگ جنریک ندارد؟</h2>

<ul>
<li>«چجوری با گولنگ که جنریک نداره برنامه نویسی میکنید؟ میشه مگه؟»</li>
<li>«تا زمانی که گولنگ جنریک رو اضافه نکنه من حتی بهش فکر هم نمیکنم&hellip; اینم شد زبان آخه؟»</li>
</ul>

<p>هر بار که این حرف ها را می‌شنوم (که دفعات اش کم هم نیست!)، فورا افکار زیر از ذهنم عبور می‌کند:</p>

<ul>
<li>یا طرف اصلا نمی‌داند جنریک چیست! یعنی اگر از او سوال کنی، نمی‌تواند جنریک را بدرستی شرح دهد.</li>
<li>یا طرف نمی‌داند جنریک در پشت صحنه چگونه پیاده سازی می‌شود، و قیمتی که زبان‌ها برای این پیاده سازی باید پرداخت کنند در چه حدی است.</li>
<li>یا طرف وقتی می‌گوید جنریک لازم دارد، منظورش این نیست که خودش قرار است چیزی با آن بسازد. در حقیقت فقط با کتابخانه‌هایی که بقیه با جنریک ساخته‌اند کار میکند. یعنی تولید کننده نیست، فقط مصرف کننده است.</li>
<li>یا طرف کلا با گولنگ آشنا نیست و همینطور حرفی را از جایی شنیده و تکرار می‌کند.</li>
</ul>

<p>در این نوشته برای‌تان شرح می دهم که چرا در مقابل آن سخن‌ها، چنین افکاری به ذهنم خطور می‌کند. همچنین برای‌تان توضیح میدهم چرا گولنگ جنریک ندارد، و چرا با اینکه جنریک ندارد هر روز محبوب تر از دیروز می‌شود و این همه آدم  براحتی در حال کدنویسی با آن هستند.</p>

<p>برای اینکه درباره قابلیت‌های یک زبان بحث کنیم، اول باید به دو نکته توجه کنیم:</p>

<ul>
<li>چرا فلان قابلیت، در فلان زبان حضور دارد.</li>
<li>چرا فلان قابلیت، در فلان زبان حضور ندارد!</li>
</ul>

<p>طراحان زبان وقتی قابلیت ای را به زبان اضافه می‌کنند، اصولا به این خاطر است که با «یک سری مشکلات» مواجه شده‌اند، و  آن قابلیت احتمالا راه گشای این مشکلات است.</p>

<p>وقتی هم تصمیم میگیرند قابلیت ای را به زبان اضافه نکنن، اصولا به این خاطر است که میخواسته‌اند از به وجود اومدن «یک سری مشکلات» جلوگیری کنند! گاهی قابلیت‌های مختلف یک زبان، خودشان باعث بروز مشکلات جدیدی در دراز مدت خواهند شد که طراحان مجبورند برای حل این مشکلات جدید، باز یک سری قابلیت‌های جدید به زبان اضافه کنند! و این قضیه ممکن است به صورت زنجیره وار ادامه پیدا کند!</p>

<p><span class="in-red">
در جامعه‌ی گولنگ، همه می‌دانند که «مهم‌ترین قابلیت گولنگ این است، که خیلی از قابلیت‌ها را ندارد!».
</span></p>

<p>بعد از مدتی کار با گولنگ، به خاطر این قضیه شکرگذار خواهید بود! گولنگ همانند C، یک زبان خاتمه یافته است! (دقت کنید گولنگ را همان افرادی ساخته‌اند که C را سال‌ها پیش ساخته بودند!) یعنی مثل زبان‌های دیگر نیست که در هر نسخه‌ی جدیدشان چندین قابلیت جدید را به زبان اضافه می‌کنند. دلیلش این بوده که برنامه نویسان بتوانند یکبار زبان را یاد بگیرند و بعدش بچسبند به کار؛ نه اینکه هر چند ماه یکبار مجبور باشد کلی قابلیت جدید را یاد بگیرند!</p>

<p><span class="in-red">
گولنگ بر خلاف زبان‌های هم دوره‌اش، یک زبان «مدرن» <strong>نیست</strong>! اکثر ایده‌های موجود در زبان بیش از سی سال از عمرشان می‌گذرد. گولنگ یک زبان «باحال» <strong>نیست</strong>! گولنگ برای افرادی است که دیگر «زرق و برق» زبان‌های مختلف چشم‌شان را نمی‌گیرد و فقط دوست دارند یک کد ساده، پایدار، و بهینه بنویسند و بروند خانه! گولنگ آن کُنده ایست که از آن دود بلند می‌شود. گولنگ، برای برنامه‌نویسان «دل سوخته» است!
</span></p>

<p>اگر زبانی مانند جاوا یک قابلیت بخصوص را نداشته باشد، ممکن است بگوییم به دلیل حساسیت بالایی که این زبان به مساله Backward compatibility دارد این حالت اتفاق افتاده است. یعنی شاید وارد کردن آن قابلیت برای کدهای پیشین مشکل زا شود. اگر زبانی مانند جاوااسکریپت قابلتی را نداشته باشد، ممکن است بگوییم که این زبان از ابتدا برای کارهای کوچک (در حد کدهای ۵۰-۶۰ خطی) ساخته شده بود و طراحی آن از پایه به گونه ای بود که اضافه کردن قابلیت‌ها به آن سخت‌تر باشد. در مورد گولنگ وضع چگونه است؟ فرضا آیا  نبود قابلیت‌ها در آن به خاطر Backward compatibility است یا طراحی نامناسب آن؟</p>

<p>گولنگ را این افراد طراحی کرده‌اند: Robert Griesemer, Rob Pike, Ken Thompson. اگر این افراد را نمی‌شناسید، مانند این است که فوتبالیست باشید ولی مسی و رونالدو را نشناسید! اگر هم این افراد را می‌شناسید، احتمالا می‌دانید که این اسامی در چه حد «سنگین» هستند! بنابراین این گزینه که نبود قابلیت‌ها در گولنگ ممکن است به دلیل سازندگان ناشایست و کارنابلد اش باشد خط خواهد خورد&hellip;</p>

<p>این افراد گولنگ را با این هدف طراحی کرده‌اند: زبانی ساده و بهینه، مناسب برای پروژه‌ها و تیم‌های بسیار بزرگ (در ابعاد گوگل)، و دارای فرآیند کامپایل سریع. پس این گزینه که نبود قابلیت‌ها در گولنگ ممکن است به این دلیل باشد که هدف زبان، کارهای کوچک و پیش پا افتاده بوده نیز برقرار نیست&hellip;</p>

<p>اولین نسخه‌ی پایدار گولنگ در سال ۲۰۱۲ منتشر شد. یعنی گولنگ یک زبان جوان است. طراحان، این زبان را از صفر طراحی کرده اند و اصلا نیاز نداشتند که نگران قضیه Backward compatibility باشند. پس این قضیه نیز نمی‌تواند دلیل نبودن یک سری از قابلیت‌ها در گولنگ باشد&hellip;</p>

<p>پس براستی دلیل اینکه گولنگ یک سری قابلیت‌ها را در زبان قرار نداده چیست؟</p>

<p>جواب در دو کلمه خلاصه می‌شود: «فلسفه‌ی گولنگ»!</p>

<p>هر زبانی، برای خودش فلسفه‌ای دارد. مثلا فلسفه‌ی ارلنگ این است که روی پیشگیری از به وجود آمدن خطاها حساس نشوید، بگذارید برنامه کرش کند! اگر کسی این را بشنود، ممکن است در اول کار این زبان را مسخره کند. ولی اگر بیشتر زبان را مطالعه کند و بیشتر آن را در کار واقعی استفاده نماید، قطعا متوجه خواهد شد که چقدر اشتباه فکر می‌کرده است.</p>

<p><a name="golang-philosophy"></a></p>

<h3 id="فلسفه-ی-گولنگ-چیست">فلسفه‌ی گولنگ چیست؟</h3>

<p>«سادگی تا سرحد امکان!».</p>

<p>این فلسفه مختص گولنگ نیست؛ کن تامپسون و همکاران قدیمی‌اش در آزمایشگاه‌های Bell ، از سال‌های دور به اصرار روی این فلسفه شهرت دارند. در این فلسفه، سادگی بالاترین هدف است. حتی اگر این سادگی باعث شود کارها کمی سخت‌تر یا کمی کندتر پیش برود. این فلسفه به «مدل توسعه‌ی نیوجرسی» شهرت دارد. (شهری که پایگاه Bell است).</p>

<p>درباره این نوع نگاه به توسعه‌ی نرم‌‌افزار، کتاب‌ها و مقالات و مصاحبه‌های زیادی وجود دارد. می‌توانید عبارت Worse is better را در گوگل جستجو نمایید و لینک ها را از بالا به پایین مطالعه کنید.</p>

<p>گولنگ به جای اینکه یک سری از قابلیت‌ها را اضافه کند تا چاره‌ی یک سری از مشکلات شوند، کلا خیلی از قابلیت‌ها را ارائه نمی کند تا از به وجود آمدن خیل عظیمی از مشکلات پیشگری نمایید! یعنی دقیقا برعکس رویه‌ای که اکثر زبان‌های برنامه‌نویسی پیش گرفته‌اند.</p>

<p>خیلی از زبان‌ها هستند که ادعا میکنند ساده‌اند. تمام آن‌ها در مقابل گولنگ مانند مقایسه یک برج صد طبقه با خانه‌ای یک خوابه هستند! وقتی گولنگ از سادگی حرف می‌زند، واقعا منظورش فراتر از چیزیست که بقیه زبان‌ها فکر می‌کنند.</p>

<p>«&hellip; پارسال به کنفرانسی رفتم&hellip; سخنرانی‌های زیادی در آنجا دیدم&hellip; خیلی از سخنرانی ها از طرف رهبران زبان‌های دیگر بود&hellip;جاوا اسکریپت، پی‌اچ‌چی، سی شارپ&hellip; درباره نسخه‌ی جدید زبان‌هایشان حرف می‌زدند&hellip; چیزی که بیشتر از همه توجه من را جلب کرد این بود که بخش بزرگی از سخرانی‌شان درباره قابلیت‌هایی بود که از دیگر زبان‌ها برداشته بودند و در این نسخه‌ی جدید به زبان خودشان اضافه کرده بودند&hellip;به این فکر کردم که این زبان‌ها اینقدر شبیه هم شده‌اند که می توان آن‌ها را در قالب یک زبان تصور کرد&hellip;» &ndash; <em>راب پایک</em></p>

<p>از نظر من حرف بالا واقعا درست است. زبان‌های دیگر آنقدر در اضافه کردن قابلیت‌های جدید عطش دارند که در هر نسخه‌ی جدیدشان کلی قابلیت‌های تازه ارائه می کنند. و با این حال باز هم از زبانی مانند C که ۴۵ سال است قابلیت خاصی به آن اضافه نشده عقب تر هستند! وقتی همه‌ی زبان‌ها، همه‌ی قابلیت‌ها را به خود اضافه کنند، دیگر فرق زیادی با یکدیگر نخواهند داشت. همه‌شان یک شکل شده‌اند!</p>

<p><span class="in-red">
نبود یک سری از قابلیت‌ها در گولنگ، کاملا از روی عمد و با قصد قبلی طراحان زبان اتفاق افتاده است. به همین سرعت، نبود این قابلیت‌ها را مبنی بر ضعف زبان نگذارید! شاید منفعت‌هایی در میان است که شما از آن بی‌خبرید!
</span></p>

<p><a name="golang-generics"></a></p>

<h3 id="دست-یابی-به-جنریک-در-گولنگ">دست یابی به جنریک در گولنگ</h3>

<p>حالا که می دانیم جنریک‌ها چگونه در زبان‌های مختلف پیاده‌سازی می‌شوند، سوال پیش می‌آید که گولنگ از کدام یکی از این روش ها پشتیبانی می‌کند؟  بسته‌سازی یا تولید کد؟ جواب: «هر دوی آن‌ها».</p>

<p>درست است، گولنگ از هر دو روش مرسوم پیاده‌سازی جنریک پشتبانی می کند! این قضیه را در ادامه‌ی نوشته توضیح  خواهیم داد.</p>

<p><a name="q-golang-lessgen"></a></p>

<h3 id="چرا-در-گولنگ-نیاز-به-جنریک-کمتر-حس-می-شود">چرا در گولنگ نیاز به جنریک کمتر حس می‌شود؟</h3>

<p>قبل از اینکه به جنریک‌ها در گولنگ بپردازیم، بهتر است ابتدا بررسی کنیم چرا جنریک‌ها در گولنگ نقش کمرنگ‌تری به نسبت بقیه زبان‌های استاتیک دارند:</p>

<ul>
<li><p>گولنگ از <a href="http://amirrezaghaderi.ir/post/types/#structural-type-system">تایپ سیستم مبتنی بر ساختار (Structural type system)</a> بهره می‌برد. در زبان‌هایی مثل ++C یا Java یا #C یا غیره، تمرکز اصلی روی سلسله مراتب کلاس است؛ در صورتی که در گولنگ تمرکز اصلی روی <a href="http://amirrezaghaderi.ir/post/types/#composition">کامپوزیشن</a> است. کل طراحی زبان گولنگ حول محور «کامپوزیشن» بنا گشته است. از همین رو «اینترفیس» ها و نحوه‌ی پیاده‌سازی آن‌ها در گولنگ از اهمیت بالایی برخوردار است. پیاده‌سازی منحصربه‌فرد گولنگ از مکانیزم اینترفیس، باعث شده است که این زبان قادر به استفاده از <a href="http://amirrezaghaderi.ir/post/types/#duck-typing">داک تایپینگ (Duck typing)</a> باشد. یعنی با اینکه گولنگ یک زبان استاتیک است، اما براحتی قادر است برای قسمتی از کدها حالت داینامیک به خود بگیرد. این قضیه بخش بزرگی از نیاز به جنریک‌ها را در گولنگ کاهش داده است.</p></li>

<li><p>مهم‌ترین کاربرد جنریک در زبان‌های استاتیک، پیاده‌سازی کالکشن‌ها است (ساختارهای داده‌ای ترکیبی). گولنگ به طور پیشفرض یک سری کالکشن پایه ارائه می‌کند که تمام آن‌ها به صورت داخلی حالت جنریک دارند! تایپ‌هایی مانند array و slice و map و توابعی مانند ()new و ()make و ()chan و ()append و غیره نیز همگی حالت جنریک دارند. پایتون‌ کاران را در نظر بگیرید، اگر از آن‌ها بپرسید پر استفاده ترین ساختاری که با کار می‌کنید چیست؟ خواهند گفت List و Dict&hellip; اگر از یک پی‌اچ‌پی کار همین سوال را بپرسید، خواهد گفت: array&hellip; در واقع، هر دوی آن‌ها اعتراف خواهند کرد که تقریبا تمام کدنویسی خود را بر مبنای این ‌ها انجام می دهند و به ندرت از ساختار ترکیبی دیگری استفاده می‌کنند! گولنگ نیز با slice و map و توابع حول و حوش آن‌ها، عملا درصد بسیار بالایی از نیازمندی به جنریک را از بین برده است.</p></li>
</ul>

<p><span class="in-red">
«شاخص‌ترین و قدرتمند‌ترین قابلیت گولنگ، اینترفیس‌های آن است&hellip; مردم از امکانات همروندی گولنگ بیشتر سخن می‌گویند، ولی این امکانات به اندازه‌ی اینترفیس‌ها در کدهای روزانه شما دخیل نیستند&hellip;» &ndash; <em>راب پایک</em>
</span></p>

<p>این دو دلیل، مهم ترین عواملی هستند که شما در گولنگ بسیار کمتر از زبان‌های دیگر نیاز به جنریک را حس خواهید کرد. اما در صورت نیاز به جنریک، چاره چیست&hellip;</p>

<h3 id="کپی-و-پست">کپی و پست</h3>

<p>در چند جای برنامه نیاز به جنریک دارید؟ چند تایپ را قرار است به جنریک وارد کنید؟</p>

<p>اگر در حد ۲-۳ مورد بود، از کپی و پست استفاده کنید! فرضا برای هر تایپ، یک گروه جدید از توابع مخصوص آن تایپ ایجاد کنید. جدی، کاملا جدی!</p>

<p>آیا تا به حال چیزی را به صورت جنریک طراحی کرده اید؟ منظورم این نیست که از جنریک استفاده برده باشید، آیا خودتان مشخصا کتابخانه‌ای حول محور جنریک‌ها طراحی کرده‌اید؟ طراحی کدها بر مبنای جنریک‌ها کار حساسی است و نیاز به دقت بسیار بالایی دارد. حساسیت و دقتی که در خیلی از پروژه‌های روزمره‌مان وقت اش را نداریم!</p>

<p>فرقی هم ندارد در کدام زبان هستید؛ حتی اگر هم زبان شما از جنریک پشتیبانی بکند، بهتر است در چنین شرایطی که استفاده از جنریک‌ها خیلی محدود است، قیدشان را بزنید و از کپی و پست استفاده نمایید! . هم کار خودتان سریع‌تر راه میفتد، و هم کدهای‌تان از پیچیدگی کمتری برخوردار خواهند شد. از همه مهم‌تر، کدهای‌تان بالاترین سرعت را خواهند داشت چرا که به صورت کاملا دستی ساخته شده‌اند!</p>

<p>اینکه در ۲-۳ خط از برنامه نیازمند جنریک شویم، و فقط ۲-۳ تایپ را به آن‌ها وارد کنیم، بخش عمده‌ای از نیاز ما به جنریک در پروژه‌های مختلف را تشکیل می‌دهد!</p>

<p><a name="golang-generic-box"></a></p>

<h3 id="پیاده-سازی-جنریک-ها-در-گولنگ-بسته-بندی-و-بسته-گ-شایی">پیاده‌سازی جنریک‌ها در گولنگ: بسته‌بندی و بسته‌گُشایی</h3>

<p>در زبان‌های استاتیک، تایپی وجود دارد که اصطلاحا آن را Any صدا می‌زنند. تایپ Any، تایپی ایست خنثی که هر تایپ دیگری می‌تواند به جایش بنشیند. در زبان C، این تایپ در قالب *void حضور دارد. در گولنگ نیز چنین تایپی با عبارت {}interface احضار می‌شود.</p>

<p>{}interface در واقع به معنی یک اینترفیس خالی است. تمام تایپ‌ها در گولنگ به طور اتوماتیک از اینترفیس خالی تبعیت می‌کنند، و به همین دلیل می‌توانند به جای {}interface بنشینند. ما از {}interface برای بسته‌بندی سایر تایپ‌ها استفاده می‌کنیم.</p>

<p>فرضا بیاید در گولنگ یک ساختار داده‌ای ترکیبی و جنریک شبیه List ها در پایتون را ایجاد کنیم. ابتدا در مسیر GOPATH/src$ یک پروژه جدید با اسم generic1 ایجاد کنید و فایل‌ها و دایرکتوری‌های آن را با شمایل زیر بچینید:</p>

<pre><code>generic1/
├── genericlist/
│   └── genericlist.go
└── main.go
</code></pre>

<p>پروژه بالا بسیار ساده است. فایل main.go که در ریشه‌ی پروژه قرار دارد فایلی است که تابع اصلی ()main در آن حضور دارد. یک پکیج به اسم genericlist هم ساخته‌ایم که کدهایش در فایل genericlist.go قرار خواهد گرفت (نیاز نیست نام فایل حتما با نام دایرکتوری یکی باشد)</p>

<p>حالا کدهای زیر را در فایل genericlist.go کپی نمایید:</p>

<pre><code>package genericlist


type Element interface{}


type List struct {
  list []Element
}


func NewList() *List {
  return &amp;List { list: []Element{} }
}


func (L *List) Insert(el interface{}) {
  L.list = append(L.list, el)
}


func (L *List) Retrieve(i int) interface{} {
  return L.list[i]
}
</code></pre>

<p>کد بالا ساده و کوتاه است. دقت کنید که چگونه عناصری که در لیست قرار خواهند گرفت را توسط Element بسته بندی کرده ایم. همچنین پارامتر توابع همگی از تایپ {}interface هستند. به این معنی که این تابع می‌تواند هر تایپی را به عنوان ورودی قبول کند.</p>

<p>تایپی که لیست را در آن نگه داری می‌کنیم یک استراکت است با نام List. درون این استراکت هم یک slice از نوع Element تعریف کرده ایم با نام list (حرف اول کوچک است) که عناصر لیست را در آن خواهیم ریخت. برای این استراکت دو متد تعریف کرده ایم:</p>

<ul>
<li>متد Insert که عناصر را به لیست اضافه می‌کند</li>
<li>متد Retrieve که با قبول یک ایندکس، عنصری که در آن ایندکس هست را برمی‌گرداند.</li>
</ul>

<p>برای استفاده از این پکیج، کدهای زیر را در فایل main.go کپی کنید:</p>

<pre><code>package main

import &quot;fmt&quot;

import &quot;generic1/genericlist&quot;


func main() {

  // a list with int items.
  L := genericlist.NewList()

  L.Insert(6)
  L.Insert(8)

  eleven := L.Retrieve(0).(int) + 5
  twelve := L.Retrieve(1).(int) + 4


  // a list with string items.
  L2 := genericlist.NewList()

  L2.Insert(&quot;H&quot;)
  L2.Insert(&quot;J&quot;)

  hello := L2.Retrieve(0).(string) + &quot;ello&quot;
  john  := L2.Retrieve(1).(string) + &quot;ohn&quot;

  // a list with float items.
  L3 := genericlist.NewList()
  L3.Insert(3)
  L3.Insert(3.14)
  L3.Insert(&quot;Pi&quot;)


  fmt.Println(L)
  fmt.Println(eleven)
  fmt.Println(twelve)

  fmt.Println(&quot;------------&quot;)

  fmt.Println(L2)
  fmt.Println(hello)
  fmt.Println(john)

  fmt.Println(&quot;------------&quot;)
  
  fmt.Println(L3)
}
</code></pre>

<p>در کد بالا، ما از پکیج genericlist استفاده کردیم و متغیرهایی به نام‌های L و L2 ساختیم که هر کدام به ترتیب شامل لیست int و string هستند. در آخر هم متغیری به اسم L3 داریم که شامل یک لیست با عناصر ترکیبی است (مشابه چیزی که در زبان‌های داینامیک دارید). ما L3 را با سه تایپ مختلف int و string و float پر کردیم.</p>

<p>دقت کنید در پکیج genericlist آرگومان‌های مربوط به توابع لیست را را با کمک {}interface بست بندی کرده بودیم. از همین رو اگر بخواهیم مقداری را از لیست بیرون بکشیم، باید آن را بسته گشایی کنیم. فرضا برای بسته گشایی مقادیر int از لیست اول، به این شیوه عمل کردیم:</p>

<pre><code>eleven := L.Retrieve(0).(int) + 5
</code></pre>

<p>حواس‌تان به آن (int). که بعد از تابع Retrieve آمده باشد. تابع Retrieve تایپِ بسته بندی شده‌ی {}interface را بر‌می‌گرداند که در داخل خود مقدار اصلی int را نگه داشته است. برای دسترسی به آن مقدار int ، ما از (int). استفاده کردیم. این عمل را باید برای هر تایپ دیگری که مقدارش درون {}interface ها بسته‌بندی شده است نیز انجام دهیم.</p>

<pre><code>$ go install
</code></pre>

<p>دستور بالا پروژه را کامپایل می‌کند و فایل اجرایی تولید شده را در مسیر GOPATH/bin$ قرار می‌دهد. اگر بدرستی شاخه‌ی GOPATH/bin$ را به مسیر اجرایی سیستم اضافه کرده باشید (PATH)، می‌توانید با فراخوانی نام فایل اجرایی، برنامه را اجرا نمایید. در صورت اجرای موفق، خروجی زیر را خواهید داشت:</p>

<pre><code>$ generic1

&amp;{[6 8]}
11
12
------------
&amp;{[H J]}
Hello
John
------------
&amp;{[3 3.14 Pi]}
</code></pre>

<p>اکثر افراد دیگر لازم نیست بیشتر از این برای دستیابی به جنریک‌ها تلاش کنند. تکنیک بسته‌بندی و بسته‌گُشایی در گولنگ انتظار بیشتر افراد را برطرف می‌کند. اما ممکن است عده‌ای معتقد باشند بسته‌بندی و بسته‌گُشایی حالت داینامیک دارد و کامپایلر نمی تواند خطاهای احتمالی را قبل از اجرای برنامه شناسایی کند. برای این افراد، استفاده از بخش بعدی را توصیه می‌کنیم&hellip;</p>

<p><a name="golang-generation"></a></p>

<h3 id="پیاده-سازی-جنریک-ها-در-گولنگ-تولید-کد">پیاده‌سازی جنریک‌ها در گولنگ: تولید کد</h3>

<p>در جامعه‌ی کاربری گولنگ، توسعه‌ی برنامه‌ها با توسل به تکنیک‌های مختلف «تولیدِ کد»  تبدیل به یک ایده‌آل شده است. از نسخه‌ی ۱.۴ گولنگ، ابزاری به نام go generate نیز به جعبه ابزار زبان اضافه شده که عملیات تولید کد را راحت‌تر می‌کند.</p>

<p>همانطور که گفتیم یکی از راه‌های پیاده‌سازی جنریک در زبان‌های مختلف، استفاده از تکنیکِ تولیدِ کد است؛ و گولنگ هم که در تکنیک‌های تولید کد، دستِ توانایی دارد!</p>

<p>شما می‌توانید تکنیک Monomorphization که در زبان‌هایی مانند ++C یا Rust برای پیاده‌سازی جنریک استفاده شده است را در گولنگ نیز پیاده‌سازی کنید. تنها فرق این است که در آن زبان‌ها Monomorphization به طور خودکار و به دور از چشم برنامه‌نویسان اتفاق می‌افتد، ولی در گولنگ به کمک ابزارهای جانبی اینکار انجام می‌شود و برنامه‌نویس باید به طور مستقیم آن ابزار را فراخانی کند. (اختلاف تنها در «یک خط» دستور اضافه‌تر است!)</p>

<p>خوشبختانه برای جنریک‌ها، لازم نیست خودتان ابزار خاصی بسازید. به اندازه‌ی کافی ابزارهای مختلف برای این منظور ساخته شده است:</p>

<pre><code>https://github.com/clipperhouse/gen
https://github.com/cheekybits/genny
https://github.com/joeshaw/gengen
https://github.com/droundy/gotgo
https://github.com/taylorchu/generic
</code></pre>

<p>تمام ابزارهای بالا می‌توانند شما را برای داشتن جنریک با روش تولیدِکد یاری کنند. من در این نوشته به کمک یکی از این ابزارها با نام genny ، کدهای جنریک خود را در گولنگ می‌نویسم و از آن‌ها استفاده می‌کنم. ابتدا باید ابزار genny را نصب کنید. ترمینال را باز کنید و خط زیر را در آن اجرا کنید:</p>

<pre><code>$ go get github.com/cheekybits/genny
</code></pre>

<p>دستور بالا ابزار genny را از اینترنت دریافت می‌کند و آن را در GOPATH$ نصب خواهد کرد. (ممکن است به وی/پی/ان نیاز پیدا کنید).</p>

<p>حالا می‌خواهیم همان پکیج genericlist که در قسمت قبلی تعریف کرده بودیم را به شیوه‌ی جدید بسازیم. ابتدا در مسیر GOPATH/src$ یک پروژه جدید به اسم generic2 ایجاد کنید و فایل‌ها و دایرکتوری‌های آن را با شمایل زیر بچینید:</p>

<pre><code>genric2/
├── genericlist/
│   └── genericlist.go
└── main.go
</code></pre>

<p>حالا کدهای زیر را در فایل genericlist.go کپی نمایید:</p>

<pre><code>//go:generate genny -in=$GOFILE -out=genny-$GOFILE gen &quot;Element=int&quot;

package genericlist


import &quot;github.com/cheekybits/genny/generic&quot;


type Element generic.Type


type ElementList struct {
  list []Element
}


func NewListElement() *ElementList {
  return &amp;ElementList { list: []Element{} }
}


func (L *ElementList) Insert(el Element) {
  L.list = append(L.list, el)
}


func (L *ElementList) Retrieve(index int) Element {
  return L.list[index]
}
</code></pre>

<p>اگر خوب کدها رو بررسی کنید، متوجه می‌شوید که ما تغییرات زیادی به نسبت پکیج قدیمی genericlist اعمال نکرده‌ایم. الگوریتم‌ها همه یکسان است و فقط نام یک سری از عناصر تغییر کرده. اول از همه، پکیج مربوط به ابزار genny را به برنامه وارد کردیم. سپس به جای اینکه Element را از تایپ {}interface تعریف کنیم، آن را با یک تایپ مخصوص به نام generic.Type تعریف کرده ایم که از پکیج مربوط به genny در دسترس خواهد بود.</p>

<p>وقتی Element را از این تایپ تعریف می‌کنیم، یعنی به ابزار genny اعلام کرده‌ایم که این عنصر در واقع یک «متغیرِ تایپ» است و تایپ‌های اصلی در آینده قرار است به جای این عنصر بنشینند.</p>

<p>کاری که genny می کند چیست؟</p>

<p>کد بالا به فرم جنریک نوشته شده است. و اعلام کرده‌ایم که Element همان «متغیرِ تایپ» این کد است و در آینده باید با تایپ‌های اصلی جایگزین شود. ابزار genny این کد را آنالیز می کند، و هر جا که با Element مواجه شد، آن را با تایپ نهایی و مورد نظر ما تعویض می کند. با اینکار، کدهای جنریک ما را تبدیل به کدهای غیر جنریک خواهد کرد.</p>

<p>ما می‌توانیم genny را به شکل مستقل در ترمینال صدا بزنیم. اما فرمان go generate از جعبه ابزار گولنگ، این کار را برای ما راحت تر کرده است. به خط اول از کد بالا دقت کنید. آن خط یک کامنتِ معمولی نیست، یک کامنتِ مخصوص است!</p>

<pre><code>//go:generate genny -in=$GOFILE -out=genny-$GOFILE gen &quot;Element=int&quot;
</code></pre>

<p>تکه‌ی اول که شامل go:generate// است، به کامپایلر گولنگ می‌گوید که در این خط قرار است فرمان مخصوصی را اجرایی کند. این فرمان در مثال بالا همان ابزار genny است. ادامه‌ی خط، مانند صدا کردن genny در ترمینال است.</p>

<ul>
<li>آرگومان in- تعیین می‌کند کدام فایل آنالیز شود (در مثال بالا فایل فعلی پردازش می‌شود).</li>
<li>آرگومان out- تعیین می‌کند که حاصل عملیات genny در چه فایلی ریخته شود.</li>
<li>زیر فرمانِ gen نیز تایپ‌های مقصد را مشخص می‌کند. مثلا در بالا به genny اعلام کرده‌ایم  Element ها را با int جایگزین کند. هر تعداد تایپ دیگر که دوست داریم می توانیم در این قسمت لحاظ کنیم (با , آن‌ها را از هم جدا کنید)</li>
</ul>

<p>اگر در دایرکتوری پروژه هستید، تنها کافیست به دایرکتوری پکیج genericlist وارد شوید و فرمان زیر را در ترمینال اجرا کنید:</p>

<pre><code>$ cd genericlist
$ go generate
</code></pre>

<p>با اینکار genny پردازش ‌اش را انجام می دهد و خروجی کارش را در فایل جدیدی به اسم genny-genericlist.go قرار خواهد داد. اگر این فایل را باز کنید، با کدهای زیر مواجه خواهید شد:</p>

<pre><code>// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package genericlist

type IntList struct {
	list []int
}

func NewListInt() *IntList {
	return &amp;IntList{list: []int{}}
}

func (L *IntList) Insert(el int) {
	L.list = append(L.list, el)
}

func (L *IntList) Retrieve(index int) int {
	return L.list[index]
}
</code></pre>

<p>همانطور که می‌بینید، کدهای اضافی پاک شده‌اند و تمام Element ها با int که تایپ مد نظر ما بوده تعویض شده‌اند.</p>

<p>برای استفاده از پکیج‌ای که ساختیم، کدهای زیر را در main.go کپی کنید:</p>

<pre><code>package main

import &quot;fmt&quot;

import &quot;generic2/genericlist&quot;


func main() {
  L := genericlist.NewListInt()

  L.Insert(6)
  L.Insert(8)

  eleven := L.Retrieve(0) + 5
  twelve := L.Retrieve(1) + 4

  fmt.Println(L)
  fmt.Println(eleven)
  fmt.Println(twelve)
}
</code></pre>

<p>حالا به دایرکتوری ریشه‌ی پروژه برگردید و پروژه را کامپایل و اجرا نمایید:</p>

<pre><code>$ go install

$ generic2

&amp;{[6 8]}
11
12
</code></pre>

<p>این روش کاملا استاتیک است و در زمان کامپایل اتفاق می‌افتد؛ همچنین نیازی به هیچ گونه عملیات زمان اجرا ندارد و از نظر امنیتِ مربوط به تایپ سیستم و سرعت در بالاترین سطح ممکن است. تنهای کاری که باید می کردید این بود که یکبار کدهای‌تان را به شکل جنریک بنویسید، و تنها با یک فرمان go generate آن‌ کد را پردازش نمایید. زیاد سخت نبود، بود؟</p>

<p><a name="end"></a></p>

<h2 id="سخن-آخر">سخن آخر</h2>

<p>اگر کسی از شما پرسید چگونه در گولنگ که فاقد جنریک است برنامه‌نویسی می‌کنید، می‌توانید جواب زیر را به او بدهید.</p>

<ul>
<li><p>با توجه به اینکه گولنگ دارای <a href="http://amirrezaghaderi.ir/post/types/#structural-type-system">تایپ سیستم مبتنی بر ساختار (Structural type system)</a> است و تعدادی کالکشن استاندارد و جنریک را هم به طور پیشفرض در خودش دارد، نیاز ما به جنریک در گولنگ بسیار پایین‌تر از بقیه زبان‌های استاتیک است.</p></li>

<li><p>در موارد معدودی اگر نیاز به جنریک حس شد، می‌توانیم با تکنیک‌های بسته‌بندی و بسته‌گُشایی در زمان اجرا و همچنین تولید کد، جنریک‌ها را در زبان پیاده‌سازی کنیم.</p></li>
</ul>

<p>پ.ن: قصد این نوشته ابدا این نبوده که قابلیت جنریک را بی اهمیت جلوه دهد. جنریک یکی از مفیدترین مکانیزم‌های موجود در زبان‌های استاتیک تایپ است. در مورد گولنگ، شخصا فکر می‌کنم بسیار خوب خواهد شد اگر جنریک به زبان اضافه شود؛ در واقع هدف اصلی این نوشته این بوده که برنامه‌نویسان در هر زبانی که برنامه نویسی می‌کنند، سعی کنند بیشتر از اینکه با قابلیت‌هایش آشنا شوند، با «کم و کاستی» هایش آشنا شوند؛ روی این کم و کاستی‌ها فکر کنند؛ و راه حل‌های جایگزین آن را بررسی نمایند؛ چرا که اگر بخواهند به جای کار مفید و مثبت، مدام در حال بهانه‌جویی باشند، فقط خودشان را خسته کرده‌اند. در دنیای برنامه نویسی، هیچ زبانی بی ایراد نیست!</p>

</div>

<footer class="p5 pt40 pb40">
 
 <div class="cat-links">
  <p><strong>دسته‌بندی:</strong>
  
   <a href="https://amirrezaghaderi.com/fa/topic/%D8%AA%D8%A7%DB%8C%D9%BE-%D8%B3%DB%8C%D8%B3%D8%AA%D9%85">تایپ سیستم</a>.
  
   <a href="https://amirrezaghaderi.com/fa/topic/%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87-%D9%86%D9%88%DB%8C%D8%B3%DB%8C">برنامه نویسی</a>.
  
   <a href="https://amirrezaghaderi.com/fa/topic/%DA%AF%D9%88%D9%84%D9%86%DA%AF">گولنگ</a>.
  
  </p>
 </div>

</footer>
</article>
<!----------------------------------------------------------------------- -->


<div class="comments">
<div>
<h2>نظرات</h2>
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'amirrezaghaderi-ir';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>
Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
</div>



</main>
</div><!-- primary ends. -->
</div><!-- content ends. -->


<footer id="footer" class="absolute bottom-left w100pr pt40 pb40 center bg-black" role="footer">
 <div class="f5">
  <a class="block pb15 gray2" href="https://amirrezaghaderi.com/fa/" rel="copyright">
  امیررضا قادری. تمام حقوق محفوظ است.
  </a>
  <a class="block gray2" href="http://creativecommons.org/licenses/by-nc/4.0/">
  مطالب تحت مجوز کریتیو کامنز (CC BY-NC 4.0) منتشر شده‌اند.
  </a>
 </div>
</footer>

</div><!-- page ends. -->

<script type="text/javascript" src="https://amirrezaghaderi.com/fa/js/site.js" ></script>
</body>
</html>

